/* soapC.cpp
   Generated by gSOAP 2.8.71 for AlertWebService.h

gSOAP XML Web services tools
Copyright (C) 2000-2018, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.8.71 2018-11-21 13:41:44 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, ""))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap);
		if (soap->fault == NULL)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", "");
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_fault_subcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
			return soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
		return NULL;
	}
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)(void*)&soap->fault->faultstring;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_fault_string(struct soap *soap)
{
	return *soap_faultstring(soap);
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
		{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap);
			soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
	{	soap->fault->detail = soap_new_SOAP_ENV__Detail(soap);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
	}
	return (const char**)(void*)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_fault_detail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Detail)
		return soap->fault->SOAP_ENV__Detail->__any;
	if (soap->fault->detail)
		return soap->fault->detail->__any;
	return NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if ((soap->error && soap->error != SOAP_TAG_MISMATCH) || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_ns1__DCenterCordInfo:
		return soap_in_ns1__DCenterCordInfo(soap, NULL, NULL, "ns1:DCenterCordInfo");
	case SOAP_TYPE_SOAP_ENC__string:
		return soap_in_SOAP_ENC__string(soap, NULL, NULL, "SOAP-ENC:string");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_ns1__GetWebServiceName:
		return soap_in_ns1__GetWebServiceName(soap, NULL, NULL, "ns1:GetWebServiceName");
	case SOAP_TYPE_ns1__GetWebServiceNameResponse:
		return soap_in_ns1__GetWebServiceNameResponse(soap, NULL, NULL, "ns1:GetWebServiceNameResponse");
	case SOAP_TYPE_ns1__InsertAlert:
		return soap_in_ns1__InsertAlert(soap, NULL, NULL, "ns1:InsertAlert");
	case SOAP_TYPE_ns1__InsertAlertResponse:
		return soap_in_ns1__InsertAlertResponse(soap, NULL, NULL, "ns1:InsertAlertResponse");
	case SOAP_TYPE_ns1__UpdateAlert:
		return soap_in_ns1__UpdateAlert(soap, NULL, NULL, "ns1:UpdateAlert");
	case SOAP_TYPE_ns1__UpdateAlertResponse:
		return soap_in_ns1__UpdateAlertResponse(soap, NULL, NULL, "ns1:UpdateAlertResponse");
	case SOAP_TYPE_ns1__InsertAlertEvaluation:
		return soap_in_ns1__InsertAlertEvaluation(soap, NULL, NULL, "ns1:InsertAlertEvaluation");
	case SOAP_TYPE_ns1__InsertAlertEvaluationResponse:
		return soap_in_ns1__InsertAlertEvaluationResponse(soap, NULL, NULL, "ns1:InsertAlertEvaluationResponse");
	case SOAP_TYPE_ns1__UpdatetAlertEvaluation:
		return soap_in_ns1__UpdatetAlertEvaluation(soap, NULL, NULL, "ns1:UpdatetAlertEvaluation");
	case SOAP_TYPE_ns1__UpdatetAlertEvaluationResponse:
		return soap_in_ns1__UpdatetAlertEvaluationResponse(soap, NULL, NULL, "ns1:UpdatetAlertEvaluationResponse");
	case SOAP_TYPE_ns1__InsertAlertAction:
		return soap_in_ns1__InsertAlertAction(soap, NULL, NULL, "ns1:InsertAlertAction");
	case SOAP_TYPE_ns1__InsertAlertActionResponse:
		return soap_in_ns1__InsertAlertActionResponse(soap, NULL, NULL, "ns1:InsertAlertActionResponse");
	case SOAP_TYPE_ns1__UpdateAlertAction:
		return soap_in_ns1__UpdateAlertAction(soap, NULL, NULL, "ns1:UpdateAlertAction");
	case SOAP_TYPE_ns1__UpdateAlertActionResponse:
		return soap_in_ns1__UpdateAlertActionResponse(soap, NULL, NULL, "ns1:UpdateAlertActionResponse");
	case SOAP_TYPE_ns1__InsertAlertSchedule:
		return soap_in_ns1__InsertAlertSchedule(soap, NULL, NULL, "ns1:InsertAlertSchedule");
	case SOAP_TYPE_ns1__InsertAlertScheduleResponse:
		return soap_in_ns1__InsertAlertScheduleResponse(soap, NULL, NULL, "ns1:InsertAlertScheduleResponse");
	case SOAP_TYPE_ns1__UpdateAlertSchedule:
		return soap_in_ns1__UpdateAlertSchedule(soap, NULL, NULL, "ns1:UpdateAlertSchedule");
	case SOAP_TYPE_ns1__UpdateAlertScheduleResponse:
		return soap_in_ns1__UpdateAlertScheduleResponse(soap, NULL, NULL, "ns1:UpdateAlertScheduleResponse");
	case SOAP_TYPE_ns1__InsertAlertActionParameter:
		return soap_in_ns1__InsertAlertActionParameter(soap, NULL, NULL, "ns1:InsertAlertActionParameter");
	case SOAP_TYPE_ns1__InsertAlertActionParameterResponse:
		return soap_in_ns1__InsertAlertActionParameterResponse(soap, NULL, NULL, "ns1:InsertAlertActionParameterResponse");
	case SOAP_TYPE_ns1__UpdateAlertActionParameter:
		return soap_in_ns1__UpdateAlertActionParameter(soap, NULL, NULL, "ns1:UpdateAlertActionParameter");
	case SOAP_TYPE_ns1__UpdateAlertActionParameterResponse:
		return soap_in_ns1__UpdateAlertActionParameterResponse(soap, NULL, NULL, "ns1:UpdateAlertActionParameterResponse");
	case SOAP_TYPE_ns1__InsertAlertActionField:
		return soap_in_ns1__InsertAlertActionField(soap, NULL, NULL, "ns1:InsertAlertActionField");
	case SOAP_TYPE_ns1__InsertAlertActionFieldResponse:
		return soap_in_ns1__InsertAlertActionFieldResponse(soap, NULL, NULL, "ns1:InsertAlertActionFieldResponse");
	case SOAP_TYPE_ns1__UpdateAlertActionField:
		return soap_in_ns1__UpdateAlertActionField(soap, NULL, NULL, "ns1:UpdateAlertActionField");
	case SOAP_TYPE_ns1__UpdateAlertActionFieldResponse:
		return soap_in_ns1__UpdateAlertActionFieldResponse(soap, NULL, NULL, "ns1:UpdateAlertActionFieldResponse");
	case SOAP_TYPE_ns1__GetAlertsRecord:
		return soap_in_ns1__GetAlertsRecord(soap, NULL, NULL, "ns1:GetAlertsRecord");
	case SOAP_TYPE_ns1__GetAlertsRecordResponse:
		return soap_in_ns1__GetAlertsRecordResponse(soap, NULL, NULL, "ns1:GetAlertsRecordResponse");
	case SOAP_TYPE_ns1__GetAlertsRecordByDocumentType:
		return soap_in_ns1__GetAlertsRecordByDocumentType(soap, NULL, NULL, "ns1:GetAlertsRecordByDocumentType");
	case SOAP_TYPE_ns1__GetAlertsRecordByDocumentTypeResponse:
		return soap_in_ns1__GetAlertsRecordByDocumentTypeResponse(soap, NULL, NULL, "ns1:GetAlertsRecordByDocumentTypeResponse");
	case SOAP_TYPE_ns1__GetAlertEvaluationsRecord:
		return soap_in_ns1__GetAlertEvaluationsRecord(soap, NULL, NULL, "ns1:GetAlertEvaluationsRecord");
	case SOAP_TYPE_ns1__GetAlertEvaluationsRecordResponse:
		return soap_in_ns1__GetAlertEvaluationsRecordResponse(soap, NULL, NULL, "ns1:GetAlertEvaluationsRecordResponse");
	case SOAP_TYPE_ns1__GetAlertActionsRecord:
		return soap_in_ns1__GetAlertActionsRecord(soap, NULL, NULL, "ns1:GetAlertActionsRecord");
	case SOAP_TYPE_ns1__GetAlertActionsRecordResponse:
		return soap_in_ns1__GetAlertActionsRecordResponse(soap, NULL, NULL, "ns1:GetAlertActionsRecordResponse");
	case SOAP_TYPE_ns1__GetAlertSchedulesRecord:
		return soap_in_ns1__GetAlertSchedulesRecord(soap, NULL, NULL, "ns1:GetAlertSchedulesRecord");
	case SOAP_TYPE_ns1__GetAlertSchedulesRecordResponse:
		return soap_in_ns1__GetAlertSchedulesRecordResponse(soap, NULL, NULL, "ns1:GetAlertSchedulesRecordResponse");
	case SOAP_TYPE_ns1__GetAlertActionParameterRecord:
		return soap_in_ns1__GetAlertActionParameterRecord(soap, NULL, NULL, "ns1:GetAlertActionParameterRecord");
	case SOAP_TYPE_ns1__GetAlertActionParameterRecordResponse:
		return soap_in_ns1__GetAlertActionParameterRecordResponse(soap, NULL, NULL, "ns1:GetAlertActionParameterRecordResponse");
	case SOAP_TYPE_ns1__GetAlertActionFieldsRecord:
		return soap_in_ns1__GetAlertActionFieldsRecord(soap, NULL, NULL, "ns1:GetAlertActionFieldsRecord");
	case SOAP_TYPE_ns1__GetAlertActionFieldsRecordResponse:
		return soap_in_ns1__GetAlertActionFieldsRecordResponse(soap, NULL, NULL, "ns1:GetAlertActionFieldsRecordResponse");
	case SOAP_TYPE_ns1__GetTlkpDocumentTypesRecord:
		return soap_in_ns1__GetTlkpDocumentTypesRecord(soap, NULL, NULL, "ns1:GetTlkpDocumentTypesRecord");
	case SOAP_TYPE_ns1__GetTlkpDocumentTypesRecordResponse:
		return soap_in_ns1__GetTlkpDocumentTypesRecordResponse(soap, NULL, NULL, "ns1:GetTlkpDocumentTypesRecordResponse");
	case SOAP_TYPE_ns1__GetTlkpDocumentTypesRecordByClientType:
		return soap_in_ns1__GetTlkpDocumentTypesRecordByClientType(soap, NULL, NULL, "ns1:GetTlkpDocumentTypesRecordByClientType");
	case SOAP_TYPE_ns1__GetTlkpDocumentTypesRecordByClientTypeResponse:
		return soap_in_ns1__GetTlkpDocumentTypesRecordByClientTypeResponse(soap, NULL, NULL, "ns1:GetTlkpDocumentTypesRecordByClientTypeResponse");
	case SOAP_TYPE_ns1__GetTlkpDocumentFieldsRecord:
		return soap_in_ns1__GetTlkpDocumentFieldsRecord(soap, NULL, NULL, "ns1:GetTlkpDocumentFieldsRecord");
	case SOAP_TYPE_ns1__GetTlkpDocumentFieldsRecordResponse:
		return soap_in_ns1__GetTlkpDocumentFieldsRecordResponse(soap, NULL, NULL, "ns1:GetTlkpDocumentFieldsRecordResponse");
	case SOAP_TYPE_ns1__GetTlkpDocumentFieldTypesRecord:
		return soap_in_ns1__GetTlkpDocumentFieldTypesRecord(soap, NULL, NULL, "ns1:GetTlkpDocumentFieldTypesRecord");
	case SOAP_TYPE_ns1__GetTlkpDocumentFieldTypesRecordResponse:
		return soap_in_ns1__GetTlkpDocumentFieldTypesRecordResponse(soap, NULL, NULL, "ns1:GetTlkpDocumentFieldTypesRecordResponse");
	case SOAP_TYPE_ns1__GetTlkpActionsRecord:
		return soap_in_ns1__GetTlkpActionsRecord(soap, NULL, NULL, "ns1:GetTlkpActionsRecord");
	case SOAP_TYPE_ns1__GetTlkpActionsRecordResponse:
		return soap_in_ns1__GetTlkpActionsRecordResponse(soap, NULL, NULL, "ns1:GetTlkpActionsRecordResponse");
	case SOAP_TYPE_ns1__GetTlkpActionsRecordByAction:
		return soap_in_ns1__GetTlkpActionsRecordByAction(soap, NULL, NULL, "ns1:GetTlkpActionsRecordByAction");
	case SOAP_TYPE_ns1__GetTlkpActionsRecordByActionResponse:
		return soap_in_ns1__GetTlkpActionsRecordByActionResponse(soap, NULL, NULL, "ns1:GetTlkpActionsRecordByActionResponse");
	case SOAP_TYPE_ns1__GetTlkpPriorityLevelRecord:
		return soap_in_ns1__GetTlkpPriorityLevelRecord(soap, NULL, NULL, "ns1:GetTlkpPriorityLevelRecord");
	case SOAP_TYPE_ns1__GetTlkpPriorityLevelRecordResponse:
		return soap_in_ns1__GetTlkpPriorityLevelRecordResponse(soap, NULL, NULL, "ns1:GetTlkpPriorityLevelRecordResponse");
	case SOAP_TYPE_ns1__GetTlkpPriorityLevelRecordByPriorityLevel:
		return soap_in_ns1__GetTlkpPriorityLevelRecordByPriorityLevel(soap, NULL, NULL, "ns1:GetTlkpPriorityLevelRecordByPriorityLevel");
	case SOAP_TYPE_ns1__GetTlkpPriorityLevelRecordByPriorityLevelResponse:
		return soap_in_ns1__GetTlkpPriorityLevelRecordByPriorityLevelResponse(soap, NULL, NULL, "ns1:GetTlkpPriorityLevelRecordByPriorityLevelResponse");
	case SOAP_TYPE_ns1__GetTlkpActionParametersRecord:
		return soap_in_ns1__GetTlkpActionParametersRecord(soap, NULL, NULL, "ns1:GetTlkpActionParametersRecord");
	case SOAP_TYPE_ns1__GetTlkpActionParametersRecordResponse:
		return soap_in_ns1__GetTlkpActionParametersRecordResponse(soap, NULL, NULL, "ns1:GetTlkpActionParametersRecordResponse");
	case SOAP_TYPE_ns1__GetTlkpActionParametersRecordByParameterId:
		return soap_in_ns1__GetTlkpActionParametersRecordByParameterId(soap, NULL, NULL, "ns1:GetTlkpActionParametersRecordByParameterId");
	case SOAP_TYPE_ns1__GetTlkpActionParametersRecordByParameterIdResponse:
		return soap_in_ns1__GetTlkpActionParametersRecordByParameterIdResponse(soap, NULL, NULL, "ns1:GetTlkpActionParametersRecordByParameterIdResponse");
	case SOAP_TYPE_ns1__SendAlert:
		return soap_in_ns1__SendAlert(soap, NULL, NULL, "ns1:SendAlert");
	case SOAP_TYPE_ns1__SendAlertResponse:
		return soap_in_ns1__SendAlertResponse(soap, NULL, NULL, "ns1:SendAlertResponse");
	case SOAP_TYPE_ns1__SendNetworkDocument:
		return soap_in_ns1__SendNetworkDocument(soap, NULL, NULL, "ns1:SendNetworkDocument");
	case SOAP_TYPE_ns1__SendNetworkDocumentResponse:
		return soap_in_ns1__SendNetworkDocumentResponse(soap, NULL, NULL, "ns1:SendNetworkDocumentResponse");
	case SOAP_TYPE_ns1__SubscribeToDocumentType:
		return soap_in_ns1__SubscribeToDocumentType(soap, NULL, NULL, "ns1:SubscribeToDocumentType");
	case SOAP_TYPE_ns1__SubscribeToDocumentTypeResponse:
		return soap_in_ns1__SubscribeToDocumentTypeResponse(soap, NULL, NULL, "ns1:SubscribeToDocumentTypeResponse");
	case SOAP_TYPE_ns1__UnSubscribeToDocumentType:
		return soap_in_ns1__UnSubscribeToDocumentType(soap, NULL, NULL, "ns1:UnSubscribeToDocumentType");
	case SOAP_TYPE_ns1__UnSubscribeToDocumentTypeResponse:
		return soap_in_ns1__UnSubscribeToDocumentTypeResponse(soap, NULL, NULL, "ns1:UnSubscribeToDocumentTypeResponse");
	case SOAP_TYPE_ns1__SendServerUpdateNotification:
		return soap_in_ns1__SendServerUpdateNotification(soap, NULL, NULL, "ns1:SendServerUpdateNotification");
	case SOAP_TYPE_ns1__SendServerUpdateNotificationResponse:
		return soap_in_ns1__SendServerUpdateNotificationResponse(soap, NULL, NULL, "ns1:SendServerUpdateNotificationResponse");
	case SOAP_TYPE_ns1__SetClientType:
		return soap_in_ns1__SetClientType(soap, NULL, NULL, "ns1:SetClientType");
	case SOAP_TYPE_ns1__SetClientTypeResponse:
		return soap_in_ns1__SetClientTypeResponse(soap, NULL, NULL, "ns1:SetClientTypeResponse");
	case SOAP_TYPE_ns1__GetRunningCenterCord:
		return soap_in_ns1__GetRunningCenterCord(soap, NULL, NULL, "ns1:GetRunningCenterCord");
	case SOAP_TYPE_ns1__GetRunningCenterCordResponse:
		return soap_in_ns1__GetRunningCenterCordResponse(soap, NULL, NULL, "ns1:GetRunningCenterCordResponse");
	case SOAP_TYPE_ns1__DeleteAlert:
		return soap_in_ns1__DeleteAlert(soap, NULL, NULL, "ns1:DeleteAlert");
	case SOAP_TYPE_ns1__DeleteAlertResponse:
		return soap_in_ns1__DeleteAlertResponse(soap, NULL, NULL, "ns1:DeleteAlertResponse");
	case SOAP_TYPE_ns1__DeleteAlertEvaluation:
		return soap_in_ns1__DeleteAlertEvaluation(soap, NULL, NULL, "ns1:DeleteAlertEvaluation");
	case SOAP_TYPE_ns1__DeleteAlertEvaluationResponse:
		return soap_in_ns1__DeleteAlertEvaluationResponse(soap, NULL, NULL, "ns1:DeleteAlertEvaluationResponse");
	case SOAP_TYPE_ns1__DeleteAlertEvaluation2:
		return soap_in_ns1__DeleteAlertEvaluation2(soap, NULL, NULL, "ns1:DeleteAlertEvaluation2");
	case SOAP_TYPE_ns1__DeleteAlertEvaluation2Response:
		return soap_in_ns1__DeleteAlertEvaluation2Response(soap, NULL, NULL, "ns1:DeleteAlertEvaluation2Response");
	case SOAP_TYPE_ns1__DeleteAlertAction:
		return soap_in_ns1__DeleteAlertAction(soap, NULL, NULL, "ns1:DeleteAlertAction");
	case SOAP_TYPE_ns1__DeleteAlertActionResponse:
		return soap_in_ns1__DeleteAlertActionResponse(soap, NULL, NULL, "ns1:DeleteAlertActionResponse");
	case SOAP_TYPE_ns1__DeleteAlertAction2:
		return soap_in_ns1__DeleteAlertAction2(soap, NULL, NULL, "ns1:DeleteAlertAction2");
	case SOAP_TYPE_ns1__DeleteAlertAction2Response:
		return soap_in_ns1__DeleteAlertAction2Response(soap, NULL, NULL, "ns1:DeleteAlertAction2Response");
	case SOAP_TYPE_ns1__DeleteAlertSchedule:
		return soap_in_ns1__DeleteAlertSchedule(soap, NULL, NULL, "ns1:DeleteAlertSchedule");
	case SOAP_TYPE_ns1__DeleteAlertScheduleResponse:
		return soap_in_ns1__DeleteAlertScheduleResponse(soap, NULL, NULL, "ns1:DeleteAlertScheduleResponse");
	case SOAP_TYPE_ns1__DeleteAlertScheduleByScheduleId:
		return soap_in_ns1__DeleteAlertScheduleByScheduleId(soap, NULL, NULL, "ns1:DeleteAlertScheduleByScheduleId");
	case SOAP_TYPE_ns1__DeleteAlertScheduleByScheduleIdResponse:
		return soap_in_ns1__DeleteAlertScheduleByScheduleIdResponse(soap, NULL, NULL, "ns1:DeleteAlertScheduleByScheduleIdResponse");
	case SOAP_TYPE_ns1__DeleteAlertActionParameter:
		return soap_in_ns1__DeleteAlertActionParameter(soap, NULL, NULL, "ns1:DeleteAlertActionParameter");
	case SOAP_TYPE_ns1__DeleteAlertActionParameterResponse:
		return soap_in_ns1__DeleteAlertActionParameterResponse(soap, NULL, NULL, "ns1:DeleteAlertActionParameterResponse");
	case SOAP_TYPE_ns1__DeleteAlertActionParameter2:
		return soap_in_ns1__DeleteAlertActionParameter2(soap, NULL, NULL, "ns1:DeleteAlertActionParameter2");
	case SOAP_TYPE_ns1__DeleteAlertActionParameter2Response:
		return soap_in_ns1__DeleteAlertActionParameter2Response(soap, NULL, NULL, "ns1:DeleteAlertActionParameter2Response");
	case SOAP_TYPE_ns1__DeleteAlertActionField:
		return soap_in_ns1__DeleteAlertActionField(soap, NULL, NULL, "ns1:DeleteAlertActionField");
	case SOAP_TYPE_ns1__DeleteAlertActionFieldResponse:
		return soap_in_ns1__DeleteAlertActionFieldResponse(soap, NULL, NULL, "ns1:DeleteAlertActionFieldResponse");
	case SOAP_TYPE_ns1__DeleteAlertActionField2:
		return soap_in_ns1__DeleteAlertActionField2(soap, NULL, NULL, "ns1:DeleteAlertActionField2");
	case SOAP_TYPE_ns1__DeleteAlertActionField2Response:
		return soap_in_ns1__DeleteAlertActionField2Response(soap, NULL, NULL, "ns1:DeleteAlertActionField2Response");
	case SOAP_TYPE_ns1__AcknowledgeSystemAlert:
		return soap_in_ns1__AcknowledgeSystemAlert(soap, NULL, NULL, "ns1:AcknowledgeSystemAlert");
	case SOAP_TYPE_ns1__AcknowledgeSystemAlertResponse:
		return soap_in_ns1__AcknowledgeSystemAlertResponse(soap, NULL, NULL, "ns1:AcknowledgeSystemAlertResponse");
	case SOAP_TYPE_ns1__AcknowledgeApplicationAlert:
		return soap_in_ns1__AcknowledgeApplicationAlert(soap, NULL, NULL, "ns1:AcknowledgeApplicationAlert");
	case SOAP_TYPE_ns1__AcknowledgeApplicationAlertResponse:
		return soap_in_ns1__AcknowledgeApplicationAlertResponse(soap, NULL, NULL, "ns1:AcknowledgeApplicationAlertResponse");
	case SOAP_TYPE_ns1__GetSystemAlerts:
		return soap_in_ns1__GetSystemAlerts(soap, NULL, NULL, "ns1:GetSystemAlerts");
	case SOAP_TYPE_ns1__GetSystemAlertsResponse:
		return soap_in_ns1__GetSystemAlertsResponse(soap, NULL, NULL, "ns1:GetSystemAlertsResponse");
	case SOAP_TYPE_ns1__GetSystemAlertsByStartDate:
		return soap_in_ns1__GetSystemAlertsByStartDate(soap, NULL, NULL, "ns1:GetSystemAlertsByStartDate");
	case SOAP_TYPE_ns1__GetSystemAlertsByStartDateResponse:
		return soap_in_ns1__GetSystemAlertsByStartDateResponse(soap, NULL, NULL, "ns1:GetSystemAlertsByStartDateResponse");
	case SOAP_TYPE_ns1__GetSystemAlertsFilter:
		return soap_in_ns1__GetSystemAlertsFilter(soap, NULL, NULL, "ns1:GetSystemAlertsFilter");
	case SOAP_TYPE_ns1__GetSystemAlertsFilterResponse:
		return soap_in_ns1__GetSystemAlertsFilterResponse(soap, NULL, NULL, "ns1:GetSystemAlertsFilterResponse");
	case SOAP_TYPE_ns1__GetApplicationAlertsFilter:
		return soap_in_ns1__GetApplicationAlertsFilter(soap, NULL, NULL, "ns1:GetApplicationAlertsFilter");
	case SOAP_TYPE_ns1__GetApplicationAlertsFilterResponse:
		return soap_in_ns1__GetApplicationAlertsFilterResponse(soap, NULL, NULL, "ns1:GetApplicationAlertsFilterResponse");
	case SOAP_TYPE_ns1__GetApplicationAlerts:
		return soap_in_ns1__GetApplicationAlerts(soap, NULL, NULL, "ns1:GetApplicationAlerts");
	case SOAP_TYPE_ns1__GetApplicationAlertsResponse:
		return soap_in_ns1__GetApplicationAlertsResponse(soap, NULL, NULL, "ns1:GetApplicationAlertsResponse");
	case SOAP_TYPE_ns1__GetApplicationAlertsByStartDate:
		return soap_in_ns1__GetApplicationAlertsByStartDate(soap, NULL, NULL, "ns1:GetApplicationAlertsByStartDate");
	case SOAP_TYPE_ns1__GetApplicationAlertsByStartDateResponse:
		return soap_in_ns1__GetApplicationAlertsByStartDateResponse(soap, NULL, NULL, "ns1:GetApplicationAlertsByStartDateResponse");
	case SOAP_TYPE_ns1__GetTlkpSystemAlertTypesRecord:
		return soap_in_ns1__GetTlkpSystemAlertTypesRecord(soap, NULL, NULL, "ns1:GetTlkpSystemAlertTypesRecord");
	case SOAP_TYPE_ns1__GetTlkpSystemAlertTypesRecordResponse:
		return soap_in_ns1__GetTlkpSystemAlertTypesRecordResponse(soap, NULL, NULL, "ns1:GetTlkpSystemAlertTypesRecordResponse");
	case SOAP_TYPE_ns1__GetTlkpSystemAlertActionsRecord:
		return soap_in_ns1__GetTlkpSystemAlertActionsRecord(soap, NULL, NULL, "ns1:GetTlkpSystemAlertActionsRecord");
	case SOAP_TYPE_ns1__GetTlkpSystemAlertActionsRecordResponse:
		return soap_in_ns1__GetTlkpSystemAlertActionsRecordResponse(soap, NULL, NULL, "ns1:GetTlkpSystemAlertActionsRecordResponse");
	case SOAP_TYPE_ns1__GetTlkpSystemAlertStatesRecord:
		return soap_in_ns1__GetTlkpSystemAlertStatesRecord(soap, NULL, NULL, "ns1:GetTlkpSystemAlertStatesRecord");
	case SOAP_TYPE_ns1__GetTlkpSystemAlertStatesRecordResponse:
		return soap_in_ns1__GetTlkpSystemAlertStatesRecordResponse(soap, NULL, NULL, "ns1:GetTlkpSystemAlertStatesRecordResponse");
	case SOAP_TYPE_ns1__GetServerRecord:
		return soap_in_ns1__GetServerRecord(soap, NULL, NULL, "ns1:GetServerRecord");
	case SOAP_TYPE_ns1__GetServerRecordResponse:
		return soap_in_ns1__GetServerRecordResponse(soap, NULL, NULL, "ns1:GetServerRecordResponse");
	case SOAP_TYPE_ns1__GetServerTypeRecord:
		return soap_in_ns1__GetServerTypeRecord(soap, NULL, NULL, "ns1:GetServerTypeRecord");
	case SOAP_TYPE_ns1__GetServerTypeRecordResponse:
		return soap_in_ns1__GetServerTypeRecordResponse(soap, NULL, NULL, "ns1:GetServerTypeRecordResponse");
	case SOAP_TYPE_ns1__GetSiteRecord:
		return soap_in_ns1__GetSiteRecord(soap, NULL, NULL, "ns1:GetSiteRecord");
	case SOAP_TYPE_ns1__GetSiteRecordResponse:
		return soap_in_ns1__GetSiteRecordResponse(soap, NULL, NULL, "ns1:GetSiteRecordResponse");
	case SOAP_TYPE_ns1__ClearApplicationAlert:
		return soap_in_ns1__ClearApplicationAlert(soap, NULL, NULL, "ns1:ClearApplicationAlert");
	case SOAP_TYPE_ns1__ClearApplicationAlertResponse:
		return soap_in_ns1__ClearApplicationAlertResponse(soap, NULL, NULL, "ns1:ClearApplicationAlertResponse");
	case SOAP_TYPE_ns1__ClearSystemAlert:
		return soap_in_ns1__ClearSystemAlert(soap, NULL, NULL, "ns1:ClearSystemAlert");
	case SOAP_TYPE_ns1__ClearSystemAlertResponse:
		return soap_in_ns1__ClearSystemAlertResponse(soap, NULL, NULL, "ns1:ClearSystemAlertResponse");
	case SOAP_TYPE_ns1__GetVersion:
		return soap_in_ns1__GetVersion(soap, NULL, NULL, "ns1:GetVersion");
	case SOAP_TYPE_ns1__GetVersionResponse:
		return soap_in_ns1__GetVersionResponse(soap, NULL, NULL, "ns1:GetVersionResponse");
	case SOAP_TYPE_PointerTons1__DCenterCordInfo:
		return soap_in_PointerTons1__DCenterCordInfo(soap, NULL, NULL, "ns1:DCenterCordInfo");
	case SOAP_TYPE_PointerToSOAP_ENC__string:
		return soap_in_PointerToSOAP_ENC__string(soap, NULL, NULL, "SOAP-ENC:string");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "ns1:DCenterCordInfo"))
		{	*type = SOAP_TYPE_ns1__DCenterCordInfo;
			return soap_in_ns1__DCenterCordInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "SOAP-ENC:string"))
		{	*type = SOAP_TYPE_SOAP_ENC__string;
			return soap_in_SOAP_ENC__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetWebServiceName"))
		{	*type = SOAP_TYPE_ns1__GetWebServiceName;
			return soap_in_ns1__GetWebServiceName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetWebServiceNameResponse"))
		{	*type = SOAP_TYPE_ns1__GetWebServiceNameResponse;
			return soap_in_ns1__GetWebServiceNameResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InsertAlert"))
		{	*type = SOAP_TYPE_ns1__InsertAlert;
			return soap_in_ns1__InsertAlert(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InsertAlertResponse"))
		{	*type = SOAP_TYPE_ns1__InsertAlertResponse;
			return soap_in_ns1__InsertAlertResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UpdateAlert"))
		{	*type = SOAP_TYPE_ns1__UpdateAlert;
			return soap_in_ns1__UpdateAlert(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UpdateAlertResponse"))
		{	*type = SOAP_TYPE_ns1__UpdateAlertResponse;
			return soap_in_ns1__UpdateAlertResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InsertAlertEvaluation"))
		{	*type = SOAP_TYPE_ns1__InsertAlertEvaluation;
			return soap_in_ns1__InsertAlertEvaluation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InsertAlertEvaluationResponse"))
		{	*type = SOAP_TYPE_ns1__InsertAlertEvaluationResponse;
			return soap_in_ns1__InsertAlertEvaluationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UpdatetAlertEvaluation"))
		{	*type = SOAP_TYPE_ns1__UpdatetAlertEvaluation;
			return soap_in_ns1__UpdatetAlertEvaluation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UpdatetAlertEvaluationResponse"))
		{	*type = SOAP_TYPE_ns1__UpdatetAlertEvaluationResponse;
			return soap_in_ns1__UpdatetAlertEvaluationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InsertAlertAction"))
		{	*type = SOAP_TYPE_ns1__InsertAlertAction;
			return soap_in_ns1__InsertAlertAction(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InsertAlertActionResponse"))
		{	*type = SOAP_TYPE_ns1__InsertAlertActionResponse;
			return soap_in_ns1__InsertAlertActionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UpdateAlertAction"))
		{	*type = SOAP_TYPE_ns1__UpdateAlertAction;
			return soap_in_ns1__UpdateAlertAction(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UpdateAlertActionResponse"))
		{	*type = SOAP_TYPE_ns1__UpdateAlertActionResponse;
			return soap_in_ns1__UpdateAlertActionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InsertAlertSchedule"))
		{	*type = SOAP_TYPE_ns1__InsertAlertSchedule;
			return soap_in_ns1__InsertAlertSchedule(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InsertAlertScheduleResponse"))
		{	*type = SOAP_TYPE_ns1__InsertAlertScheduleResponse;
			return soap_in_ns1__InsertAlertScheduleResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UpdateAlertSchedule"))
		{	*type = SOAP_TYPE_ns1__UpdateAlertSchedule;
			return soap_in_ns1__UpdateAlertSchedule(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UpdateAlertScheduleResponse"))
		{	*type = SOAP_TYPE_ns1__UpdateAlertScheduleResponse;
			return soap_in_ns1__UpdateAlertScheduleResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InsertAlertActionParameter"))
		{	*type = SOAP_TYPE_ns1__InsertAlertActionParameter;
			return soap_in_ns1__InsertAlertActionParameter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InsertAlertActionParameterResponse"))
		{	*type = SOAP_TYPE_ns1__InsertAlertActionParameterResponse;
			return soap_in_ns1__InsertAlertActionParameterResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UpdateAlertActionParameter"))
		{	*type = SOAP_TYPE_ns1__UpdateAlertActionParameter;
			return soap_in_ns1__UpdateAlertActionParameter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UpdateAlertActionParameterResponse"))
		{	*type = SOAP_TYPE_ns1__UpdateAlertActionParameterResponse;
			return soap_in_ns1__UpdateAlertActionParameterResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InsertAlertActionField"))
		{	*type = SOAP_TYPE_ns1__InsertAlertActionField;
			return soap_in_ns1__InsertAlertActionField(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InsertAlertActionFieldResponse"))
		{	*type = SOAP_TYPE_ns1__InsertAlertActionFieldResponse;
			return soap_in_ns1__InsertAlertActionFieldResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UpdateAlertActionField"))
		{	*type = SOAP_TYPE_ns1__UpdateAlertActionField;
			return soap_in_ns1__UpdateAlertActionField(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UpdateAlertActionFieldResponse"))
		{	*type = SOAP_TYPE_ns1__UpdateAlertActionFieldResponse;
			return soap_in_ns1__UpdateAlertActionFieldResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetAlertsRecord"))
		{	*type = SOAP_TYPE_ns1__GetAlertsRecord;
			return soap_in_ns1__GetAlertsRecord(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetAlertsRecordResponse"))
		{	*type = SOAP_TYPE_ns1__GetAlertsRecordResponse;
			return soap_in_ns1__GetAlertsRecordResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetAlertsRecordByDocumentType"))
		{	*type = SOAP_TYPE_ns1__GetAlertsRecordByDocumentType;
			return soap_in_ns1__GetAlertsRecordByDocumentType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetAlertsRecordByDocumentTypeResponse"))
		{	*type = SOAP_TYPE_ns1__GetAlertsRecordByDocumentTypeResponse;
			return soap_in_ns1__GetAlertsRecordByDocumentTypeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetAlertEvaluationsRecord"))
		{	*type = SOAP_TYPE_ns1__GetAlertEvaluationsRecord;
			return soap_in_ns1__GetAlertEvaluationsRecord(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetAlertEvaluationsRecordResponse"))
		{	*type = SOAP_TYPE_ns1__GetAlertEvaluationsRecordResponse;
			return soap_in_ns1__GetAlertEvaluationsRecordResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetAlertActionsRecord"))
		{	*type = SOAP_TYPE_ns1__GetAlertActionsRecord;
			return soap_in_ns1__GetAlertActionsRecord(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetAlertActionsRecordResponse"))
		{	*type = SOAP_TYPE_ns1__GetAlertActionsRecordResponse;
			return soap_in_ns1__GetAlertActionsRecordResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetAlertSchedulesRecord"))
		{	*type = SOAP_TYPE_ns1__GetAlertSchedulesRecord;
			return soap_in_ns1__GetAlertSchedulesRecord(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetAlertSchedulesRecordResponse"))
		{	*type = SOAP_TYPE_ns1__GetAlertSchedulesRecordResponse;
			return soap_in_ns1__GetAlertSchedulesRecordResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetAlertActionParameterRecord"))
		{	*type = SOAP_TYPE_ns1__GetAlertActionParameterRecord;
			return soap_in_ns1__GetAlertActionParameterRecord(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetAlertActionParameterRecordResponse"))
		{	*type = SOAP_TYPE_ns1__GetAlertActionParameterRecordResponse;
			return soap_in_ns1__GetAlertActionParameterRecordResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetAlertActionFieldsRecord"))
		{	*type = SOAP_TYPE_ns1__GetAlertActionFieldsRecord;
			return soap_in_ns1__GetAlertActionFieldsRecord(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetAlertActionFieldsRecordResponse"))
		{	*type = SOAP_TYPE_ns1__GetAlertActionFieldsRecordResponse;
			return soap_in_ns1__GetAlertActionFieldsRecordResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetTlkpDocumentTypesRecord"))
		{	*type = SOAP_TYPE_ns1__GetTlkpDocumentTypesRecord;
			return soap_in_ns1__GetTlkpDocumentTypesRecord(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetTlkpDocumentTypesRecordResponse"))
		{	*type = SOAP_TYPE_ns1__GetTlkpDocumentTypesRecordResponse;
			return soap_in_ns1__GetTlkpDocumentTypesRecordResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetTlkpDocumentTypesRecordByClientType"))
		{	*type = SOAP_TYPE_ns1__GetTlkpDocumentTypesRecordByClientType;
			return soap_in_ns1__GetTlkpDocumentTypesRecordByClientType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetTlkpDocumentTypesRecordByClientTypeResponse"))
		{	*type = SOAP_TYPE_ns1__GetTlkpDocumentTypesRecordByClientTypeResponse;
			return soap_in_ns1__GetTlkpDocumentTypesRecordByClientTypeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetTlkpDocumentFieldsRecord"))
		{	*type = SOAP_TYPE_ns1__GetTlkpDocumentFieldsRecord;
			return soap_in_ns1__GetTlkpDocumentFieldsRecord(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetTlkpDocumentFieldsRecordResponse"))
		{	*type = SOAP_TYPE_ns1__GetTlkpDocumentFieldsRecordResponse;
			return soap_in_ns1__GetTlkpDocumentFieldsRecordResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetTlkpDocumentFieldTypesRecord"))
		{	*type = SOAP_TYPE_ns1__GetTlkpDocumentFieldTypesRecord;
			return soap_in_ns1__GetTlkpDocumentFieldTypesRecord(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetTlkpDocumentFieldTypesRecordResponse"))
		{	*type = SOAP_TYPE_ns1__GetTlkpDocumentFieldTypesRecordResponse;
			return soap_in_ns1__GetTlkpDocumentFieldTypesRecordResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetTlkpActionsRecord"))
		{	*type = SOAP_TYPE_ns1__GetTlkpActionsRecord;
			return soap_in_ns1__GetTlkpActionsRecord(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetTlkpActionsRecordResponse"))
		{	*type = SOAP_TYPE_ns1__GetTlkpActionsRecordResponse;
			return soap_in_ns1__GetTlkpActionsRecordResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetTlkpActionsRecordByAction"))
		{	*type = SOAP_TYPE_ns1__GetTlkpActionsRecordByAction;
			return soap_in_ns1__GetTlkpActionsRecordByAction(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetTlkpActionsRecordByActionResponse"))
		{	*type = SOAP_TYPE_ns1__GetTlkpActionsRecordByActionResponse;
			return soap_in_ns1__GetTlkpActionsRecordByActionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetTlkpPriorityLevelRecord"))
		{	*type = SOAP_TYPE_ns1__GetTlkpPriorityLevelRecord;
			return soap_in_ns1__GetTlkpPriorityLevelRecord(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetTlkpPriorityLevelRecordResponse"))
		{	*type = SOAP_TYPE_ns1__GetTlkpPriorityLevelRecordResponse;
			return soap_in_ns1__GetTlkpPriorityLevelRecordResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetTlkpPriorityLevelRecordByPriorityLevel"))
		{	*type = SOAP_TYPE_ns1__GetTlkpPriorityLevelRecordByPriorityLevel;
			return soap_in_ns1__GetTlkpPriorityLevelRecordByPriorityLevel(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetTlkpPriorityLevelRecordByPriorityLevelResponse"))
		{	*type = SOAP_TYPE_ns1__GetTlkpPriorityLevelRecordByPriorityLevelResponse;
			return soap_in_ns1__GetTlkpPriorityLevelRecordByPriorityLevelResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetTlkpActionParametersRecord"))
		{	*type = SOAP_TYPE_ns1__GetTlkpActionParametersRecord;
			return soap_in_ns1__GetTlkpActionParametersRecord(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetTlkpActionParametersRecordResponse"))
		{	*type = SOAP_TYPE_ns1__GetTlkpActionParametersRecordResponse;
			return soap_in_ns1__GetTlkpActionParametersRecordResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetTlkpActionParametersRecordByParameterId"))
		{	*type = SOAP_TYPE_ns1__GetTlkpActionParametersRecordByParameterId;
			return soap_in_ns1__GetTlkpActionParametersRecordByParameterId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetTlkpActionParametersRecordByParameterIdResponse"))
		{	*type = SOAP_TYPE_ns1__GetTlkpActionParametersRecordByParameterIdResponse;
			return soap_in_ns1__GetTlkpActionParametersRecordByParameterIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SendAlert"))
		{	*type = SOAP_TYPE_ns1__SendAlert;
			return soap_in_ns1__SendAlert(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SendAlertResponse"))
		{	*type = SOAP_TYPE_ns1__SendAlertResponse;
			return soap_in_ns1__SendAlertResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SendNetworkDocument"))
		{	*type = SOAP_TYPE_ns1__SendNetworkDocument;
			return soap_in_ns1__SendNetworkDocument(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SendNetworkDocumentResponse"))
		{	*type = SOAP_TYPE_ns1__SendNetworkDocumentResponse;
			return soap_in_ns1__SendNetworkDocumentResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SubscribeToDocumentType"))
		{	*type = SOAP_TYPE_ns1__SubscribeToDocumentType;
			return soap_in_ns1__SubscribeToDocumentType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SubscribeToDocumentTypeResponse"))
		{	*type = SOAP_TYPE_ns1__SubscribeToDocumentTypeResponse;
			return soap_in_ns1__SubscribeToDocumentTypeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UnSubscribeToDocumentType"))
		{	*type = SOAP_TYPE_ns1__UnSubscribeToDocumentType;
			return soap_in_ns1__UnSubscribeToDocumentType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UnSubscribeToDocumentTypeResponse"))
		{	*type = SOAP_TYPE_ns1__UnSubscribeToDocumentTypeResponse;
			return soap_in_ns1__UnSubscribeToDocumentTypeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SendServerUpdateNotification"))
		{	*type = SOAP_TYPE_ns1__SendServerUpdateNotification;
			return soap_in_ns1__SendServerUpdateNotification(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SendServerUpdateNotificationResponse"))
		{	*type = SOAP_TYPE_ns1__SendServerUpdateNotificationResponse;
			return soap_in_ns1__SendServerUpdateNotificationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SetClientType"))
		{	*type = SOAP_TYPE_ns1__SetClientType;
			return soap_in_ns1__SetClientType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SetClientTypeResponse"))
		{	*type = SOAP_TYPE_ns1__SetClientTypeResponse;
			return soap_in_ns1__SetClientTypeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetRunningCenterCord"))
		{	*type = SOAP_TYPE_ns1__GetRunningCenterCord;
			return soap_in_ns1__GetRunningCenterCord(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetRunningCenterCordResponse"))
		{	*type = SOAP_TYPE_ns1__GetRunningCenterCordResponse;
			return soap_in_ns1__GetRunningCenterCordResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DeleteAlert"))
		{	*type = SOAP_TYPE_ns1__DeleteAlert;
			return soap_in_ns1__DeleteAlert(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DeleteAlertResponse"))
		{	*type = SOAP_TYPE_ns1__DeleteAlertResponse;
			return soap_in_ns1__DeleteAlertResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DeleteAlertEvaluation"))
		{	*type = SOAP_TYPE_ns1__DeleteAlertEvaluation;
			return soap_in_ns1__DeleteAlertEvaluation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DeleteAlertEvaluationResponse"))
		{	*type = SOAP_TYPE_ns1__DeleteAlertEvaluationResponse;
			return soap_in_ns1__DeleteAlertEvaluationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DeleteAlertEvaluation2"))
		{	*type = SOAP_TYPE_ns1__DeleteAlertEvaluation2;
			return soap_in_ns1__DeleteAlertEvaluation2(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DeleteAlertEvaluation2Response"))
		{	*type = SOAP_TYPE_ns1__DeleteAlertEvaluation2Response;
			return soap_in_ns1__DeleteAlertEvaluation2Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DeleteAlertAction"))
		{	*type = SOAP_TYPE_ns1__DeleteAlertAction;
			return soap_in_ns1__DeleteAlertAction(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DeleteAlertActionResponse"))
		{	*type = SOAP_TYPE_ns1__DeleteAlertActionResponse;
			return soap_in_ns1__DeleteAlertActionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DeleteAlertAction2"))
		{	*type = SOAP_TYPE_ns1__DeleteAlertAction2;
			return soap_in_ns1__DeleteAlertAction2(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DeleteAlertAction2Response"))
		{	*type = SOAP_TYPE_ns1__DeleteAlertAction2Response;
			return soap_in_ns1__DeleteAlertAction2Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DeleteAlertSchedule"))
		{	*type = SOAP_TYPE_ns1__DeleteAlertSchedule;
			return soap_in_ns1__DeleteAlertSchedule(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DeleteAlertScheduleResponse"))
		{	*type = SOAP_TYPE_ns1__DeleteAlertScheduleResponse;
			return soap_in_ns1__DeleteAlertScheduleResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DeleteAlertScheduleByScheduleId"))
		{	*type = SOAP_TYPE_ns1__DeleteAlertScheduleByScheduleId;
			return soap_in_ns1__DeleteAlertScheduleByScheduleId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DeleteAlertScheduleByScheduleIdResponse"))
		{	*type = SOAP_TYPE_ns1__DeleteAlertScheduleByScheduleIdResponse;
			return soap_in_ns1__DeleteAlertScheduleByScheduleIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DeleteAlertActionParameter"))
		{	*type = SOAP_TYPE_ns1__DeleteAlertActionParameter;
			return soap_in_ns1__DeleteAlertActionParameter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DeleteAlertActionParameterResponse"))
		{	*type = SOAP_TYPE_ns1__DeleteAlertActionParameterResponse;
			return soap_in_ns1__DeleteAlertActionParameterResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DeleteAlertActionParameter2"))
		{	*type = SOAP_TYPE_ns1__DeleteAlertActionParameter2;
			return soap_in_ns1__DeleteAlertActionParameter2(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DeleteAlertActionParameter2Response"))
		{	*type = SOAP_TYPE_ns1__DeleteAlertActionParameter2Response;
			return soap_in_ns1__DeleteAlertActionParameter2Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DeleteAlertActionField"))
		{	*type = SOAP_TYPE_ns1__DeleteAlertActionField;
			return soap_in_ns1__DeleteAlertActionField(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DeleteAlertActionFieldResponse"))
		{	*type = SOAP_TYPE_ns1__DeleteAlertActionFieldResponse;
			return soap_in_ns1__DeleteAlertActionFieldResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DeleteAlertActionField2"))
		{	*type = SOAP_TYPE_ns1__DeleteAlertActionField2;
			return soap_in_ns1__DeleteAlertActionField2(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DeleteAlertActionField2Response"))
		{	*type = SOAP_TYPE_ns1__DeleteAlertActionField2Response;
			return soap_in_ns1__DeleteAlertActionField2Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AcknowledgeSystemAlert"))
		{	*type = SOAP_TYPE_ns1__AcknowledgeSystemAlert;
			return soap_in_ns1__AcknowledgeSystemAlert(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AcknowledgeSystemAlertResponse"))
		{	*type = SOAP_TYPE_ns1__AcknowledgeSystemAlertResponse;
			return soap_in_ns1__AcknowledgeSystemAlertResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AcknowledgeApplicationAlert"))
		{	*type = SOAP_TYPE_ns1__AcknowledgeApplicationAlert;
			return soap_in_ns1__AcknowledgeApplicationAlert(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AcknowledgeApplicationAlertResponse"))
		{	*type = SOAP_TYPE_ns1__AcknowledgeApplicationAlertResponse;
			return soap_in_ns1__AcknowledgeApplicationAlertResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetSystemAlerts"))
		{	*type = SOAP_TYPE_ns1__GetSystemAlerts;
			return soap_in_ns1__GetSystemAlerts(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetSystemAlertsResponse"))
		{	*type = SOAP_TYPE_ns1__GetSystemAlertsResponse;
			return soap_in_ns1__GetSystemAlertsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetSystemAlertsByStartDate"))
		{	*type = SOAP_TYPE_ns1__GetSystemAlertsByStartDate;
			return soap_in_ns1__GetSystemAlertsByStartDate(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetSystemAlertsByStartDateResponse"))
		{	*type = SOAP_TYPE_ns1__GetSystemAlertsByStartDateResponse;
			return soap_in_ns1__GetSystemAlertsByStartDateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetSystemAlertsFilter"))
		{	*type = SOAP_TYPE_ns1__GetSystemAlertsFilter;
			return soap_in_ns1__GetSystemAlertsFilter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetSystemAlertsFilterResponse"))
		{	*type = SOAP_TYPE_ns1__GetSystemAlertsFilterResponse;
			return soap_in_ns1__GetSystemAlertsFilterResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetApplicationAlertsFilter"))
		{	*type = SOAP_TYPE_ns1__GetApplicationAlertsFilter;
			return soap_in_ns1__GetApplicationAlertsFilter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetApplicationAlertsFilterResponse"))
		{	*type = SOAP_TYPE_ns1__GetApplicationAlertsFilterResponse;
			return soap_in_ns1__GetApplicationAlertsFilterResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetApplicationAlerts"))
		{	*type = SOAP_TYPE_ns1__GetApplicationAlerts;
			return soap_in_ns1__GetApplicationAlerts(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetApplicationAlertsResponse"))
		{	*type = SOAP_TYPE_ns1__GetApplicationAlertsResponse;
			return soap_in_ns1__GetApplicationAlertsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetApplicationAlertsByStartDate"))
		{	*type = SOAP_TYPE_ns1__GetApplicationAlertsByStartDate;
			return soap_in_ns1__GetApplicationAlertsByStartDate(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetApplicationAlertsByStartDateResponse"))
		{	*type = SOAP_TYPE_ns1__GetApplicationAlertsByStartDateResponse;
			return soap_in_ns1__GetApplicationAlertsByStartDateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetTlkpSystemAlertTypesRecord"))
		{	*type = SOAP_TYPE_ns1__GetTlkpSystemAlertTypesRecord;
			return soap_in_ns1__GetTlkpSystemAlertTypesRecord(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetTlkpSystemAlertTypesRecordResponse"))
		{	*type = SOAP_TYPE_ns1__GetTlkpSystemAlertTypesRecordResponse;
			return soap_in_ns1__GetTlkpSystemAlertTypesRecordResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetTlkpSystemAlertActionsRecord"))
		{	*type = SOAP_TYPE_ns1__GetTlkpSystemAlertActionsRecord;
			return soap_in_ns1__GetTlkpSystemAlertActionsRecord(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetTlkpSystemAlertActionsRecordResponse"))
		{	*type = SOAP_TYPE_ns1__GetTlkpSystemAlertActionsRecordResponse;
			return soap_in_ns1__GetTlkpSystemAlertActionsRecordResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetTlkpSystemAlertStatesRecord"))
		{	*type = SOAP_TYPE_ns1__GetTlkpSystemAlertStatesRecord;
			return soap_in_ns1__GetTlkpSystemAlertStatesRecord(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetTlkpSystemAlertStatesRecordResponse"))
		{	*type = SOAP_TYPE_ns1__GetTlkpSystemAlertStatesRecordResponse;
			return soap_in_ns1__GetTlkpSystemAlertStatesRecordResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetServerRecord"))
		{	*type = SOAP_TYPE_ns1__GetServerRecord;
			return soap_in_ns1__GetServerRecord(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetServerRecordResponse"))
		{	*type = SOAP_TYPE_ns1__GetServerRecordResponse;
			return soap_in_ns1__GetServerRecordResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetServerTypeRecord"))
		{	*type = SOAP_TYPE_ns1__GetServerTypeRecord;
			return soap_in_ns1__GetServerTypeRecord(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetServerTypeRecordResponse"))
		{	*type = SOAP_TYPE_ns1__GetServerTypeRecordResponse;
			return soap_in_ns1__GetServerTypeRecordResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetSiteRecord"))
		{	*type = SOAP_TYPE_ns1__GetSiteRecord;
			return soap_in_ns1__GetSiteRecord(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetSiteRecordResponse"))
		{	*type = SOAP_TYPE_ns1__GetSiteRecordResponse;
			return soap_in_ns1__GetSiteRecordResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ClearApplicationAlert"))
		{	*type = SOAP_TYPE_ns1__ClearApplicationAlert;
			return soap_in_ns1__ClearApplicationAlert(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ClearApplicationAlertResponse"))
		{	*type = SOAP_TYPE_ns1__ClearApplicationAlertResponse;
			return soap_in_ns1__ClearApplicationAlertResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ClearSystemAlert"))
		{	*type = SOAP_TYPE_ns1__ClearSystemAlert;
			return soap_in_ns1__ClearSystemAlert(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ClearSystemAlertResponse"))
		{	*type = SOAP_TYPE_ns1__ClearSystemAlertResponse;
			return soap_in_ns1__ClearSystemAlertResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetVersion"))
		{	*type = SOAP_TYPE_ns1__GetVersion;
			return soap_in_ns1__GetVersion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetVersionResponse"))
		{	*type = SOAP_TYPE_ns1__GetVersionResponse;
			return soap_in_ns1__GetVersionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level = %u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other && !soap->fignore)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && !soap->fignore && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body && soap_ignore(soap))
				return soap->error;
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, SOAP_MULTIREFTAG, pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_ns1__DCenterCordInfo:
		return ((ns1__DCenterCordInfo *)ptr)->soap_out(soap, tag, id, "ns1:DCenterCordInfo");
	case SOAP_TYPE_SOAP_ENC__string:
		return soap_out_SOAP_ENC__string(soap, tag, id, (const std::string *)ptr, "SOAP-ENC:string");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_ns1__GetWebServiceName:
		return soap_out_ns1__GetWebServiceName(soap, tag, id, (const struct ns1__GetWebServiceName *)ptr, "ns1:GetWebServiceName");
	case SOAP_TYPE_ns1__GetWebServiceNameResponse:
		return soap_out_ns1__GetWebServiceNameResponse(soap, tag, id, (const struct ns1__GetWebServiceNameResponse *)ptr, "ns1:GetWebServiceNameResponse");
	case SOAP_TYPE_ns1__InsertAlert:
		return soap_out_ns1__InsertAlert(soap, tag, id, (const struct ns1__InsertAlert *)ptr, "ns1:InsertAlert");
	case SOAP_TYPE_ns1__InsertAlertResponse:
		return soap_out_ns1__InsertAlertResponse(soap, tag, id, (const struct ns1__InsertAlertResponse *)ptr, "ns1:InsertAlertResponse");
	case SOAP_TYPE_ns1__UpdateAlert:
		return soap_out_ns1__UpdateAlert(soap, tag, id, (const struct ns1__UpdateAlert *)ptr, "ns1:UpdateAlert");
	case SOAP_TYPE_ns1__UpdateAlertResponse:
		return soap_out_ns1__UpdateAlertResponse(soap, tag, id, (const struct ns1__UpdateAlertResponse *)ptr, "ns1:UpdateAlertResponse");
	case SOAP_TYPE_ns1__InsertAlertEvaluation:
		return soap_out_ns1__InsertAlertEvaluation(soap, tag, id, (const struct ns1__InsertAlertEvaluation *)ptr, "ns1:InsertAlertEvaluation");
	case SOAP_TYPE_ns1__InsertAlertEvaluationResponse:
		return soap_out_ns1__InsertAlertEvaluationResponse(soap, tag, id, (const struct ns1__InsertAlertEvaluationResponse *)ptr, "ns1:InsertAlertEvaluationResponse");
	case SOAP_TYPE_ns1__UpdatetAlertEvaluation:
		return soap_out_ns1__UpdatetAlertEvaluation(soap, tag, id, (const struct ns1__UpdatetAlertEvaluation *)ptr, "ns1:UpdatetAlertEvaluation");
	case SOAP_TYPE_ns1__UpdatetAlertEvaluationResponse:
		return soap_out_ns1__UpdatetAlertEvaluationResponse(soap, tag, id, (const struct ns1__UpdatetAlertEvaluationResponse *)ptr, "ns1:UpdatetAlertEvaluationResponse");
	case SOAP_TYPE_ns1__InsertAlertAction:
		return soap_out_ns1__InsertAlertAction(soap, tag, id, (const struct ns1__InsertAlertAction *)ptr, "ns1:InsertAlertAction");
	case SOAP_TYPE_ns1__InsertAlertActionResponse:
		return soap_out_ns1__InsertAlertActionResponse(soap, tag, id, (const struct ns1__InsertAlertActionResponse *)ptr, "ns1:InsertAlertActionResponse");
	case SOAP_TYPE_ns1__UpdateAlertAction:
		return soap_out_ns1__UpdateAlertAction(soap, tag, id, (const struct ns1__UpdateAlertAction *)ptr, "ns1:UpdateAlertAction");
	case SOAP_TYPE_ns1__UpdateAlertActionResponse:
		return soap_out_ns1__UpdateAlertActionResponse(soap, tag, id, (const struct ns1__UpdateAlertActionResponse *)ptr, "ns1:UpdateAlertActionResponse");
	case SOAP_TYPE_ns1__InsertAlertSchedule:
		return soap_out_ns1__InsertAlertSchedule(soap, tag, id, (const struct ns1__InsertAlertSchedule *)ptr, "ns1:InsertAlertSchedule");
	case SOAP_TYPE_ns1__InsertAlertScheduleResponse:
		return soap_out_ns1__InsertAlertScheduleResponse(soap, tag, id, (const struct ns1__InsertAlertScheduleResponse *)ptr, "ns1:InsertAlertScheduleResponse");
	case SOAP_TYPE_ns1__UpdateAlertSchedule:
		return soap_out_ns1__UpdateAlertSchedule(soap, tag, id, (const struct ns1__UpdateAlertSchedule *)ptr, "ns1:UpdateAlertSchedule");
	case SOAP_TYPE_ns1__UpdateAlertScheduleResponse:
		return soap_out_ns1__UpdateAlertScheduleResponse(soap, tag, id, (const struct ns1__UpdateAlertScheduleResponse *)ptr, "ns1:UpdateAlertScheduleResponse");
	case SOAP_TYPE_ns1__InsertAlertActionParameter:
		return soap_out_ns1__InsertAlertActionParameter(soap, tag, id, (const struct ns1__InsertAlertActionParameter *)ptr, "ns1:InsertAlertActionParameter");
	case SOAP_TYPE_ns1__InsertAlertActionParameterResponse:
		return soap_out_ns1__InsertAlertActionParameterResponse(soap, tag, id, (const struct ns1__InsertAlertActionParameterResponse *)ptr, "ns1:InsertAlertActionParameterResponse");
	case SOAP_TYPE_ns1__UpdateAlertActionParameter:
		return soap_out_ns1__UpdateAlertActionParameter(soap, tag, id, (const struct ns1__UpdateAlertActionParameter *)ptr, "ns1:UpdateAlertActionParameter");
	case SOAP_TYPE_ns1__UpdateAlertActionParameterResponse:
		return soap_out_ns1__UpdateAlertActionParameterResponse(soap, tag, id, (const struct ns1__UpdateAlertActionParameterResponse *)ptr, "ns1:UpdateAlertActionParameterResponse");
	case SOAP_TYPE_ns1__InsertAlertActionField:
		return soap_out_ns1__InsertAlertActionField(soap, tag, id, (const struct ns1__InsertAlertActionField *)ptr, "ns1:InsertAlertActionField");
	case SOAP_TYPE_ns1__InsertAlertActionFieldResponse:
		return soap_out_ns1__InsertAlertActionFieldResponse(soap, tag, id, (const struct ns1__InsertAlertActionFieldResponse *)ptr, "ns1:InsertAlertActionFieldResponse");
	case SOAP_TYPE_ns1__UpdateAlertActionField:
		return soap_out_ns1__UpdateAlertActionField(soap, tag, id, (const struct ns1__UpdateAlertActionField *)ptr, "ns1:UpdateAlertActionField");
	case SOAP_TYPE_ns1__UpdateAlertActionFieldResponse:
		return soap_out_ns1__UpdateAlertActionFieldResponse(soap, tag, id, (const struct ns1__UpdateAlertActionFieldResponse *)ptr, "ns1:UpdateAlertActionFieldResponse");
	case SOAP_TYPE_ns1__GetAlertsRecord:
		return soap_out_ns1__GetAlertsRecord(soap, tag, id, (const struct ns1__GetAlertsRecord *)ptr, "ns1:GetAlertsRecord");
	case SOAP_TYPE_ns1__GetAlertsRecordResponse:
		return soap_out_ns1__GetAlertsRecordResponse(soap, tag, id, (const struct ns1__GetAlertsRecordResponse *)ptr, "ns1:GetAlertsRecordResponse");
	case SOAP_TYPE_ns1__GetAlertsRecordByDocumentType:
		return soap_out_ns1__GetAlertsRecordByDocumentType(soap, tag, id, (const struct ns1__GetAlertsRecordByDocumentType *)ptr, "ns1:GetAlertsRecordByDocumentType");
	case SOAP_TYPE_ns1__GetAlertsRecordByDocumentTypeResponse:
		return soap_out_ns1__GetAlertsRecordByDocumentTypeResponse(soap, tag, id, (const struct ns1__GetAlertsRecordByDocumentTypeResponse *)ptr, "ns1:GetAlertsRecordByDocumentTypeResponse");
	case SOAP_TYPE_ns1__GetAlertEvaluationsRecord:
		return soap_out_ns1__GetAlertEvaluationsRecord(soap, tag, id, (const struct ns1__GetAlertEvaluationsRecord *)ptr, "ns1:GetAlertEvaluationsRecord");
	case SOAP_TYPE_ns1__GetAlertEvaluationsRecordResponse:
		return soap_out_ns1__GetAlertEvaluationsRecordResponse(soap, tag, id, (const struct ns1__GetAlertEvaluationsRecordResponse *)ptr, "ns1:GetAlertEvaluationsRecordResponse");
	case SOAP_TYPE_ns1__GetAlertActionsRecord:
		return soap_out_ns1__GetAlertActionsRecord(soap, tag, id, (const struct ns1__GetAlertActionsRecord *)ptr, "ns1:GetAlertActionsRecord");
	case SOAP_TYPE_ns1__GetAlertActionsRecordResponse:
		return soap_out_ns1__GetAlertActionsRecordResponse(soap, tag, id, (const struct ns1__GetAlertActionsRecordResponse *)ptr, "ns1:GetAlertActionsRecordResponse");
	case SOAP_TYPE_ns1__GetAlertSchedulesRecord:
		return soap_out_ns1__GetAlertSchedulesRecord(soap, tag, id, (const struct ns1__GetAlertSchedulesRecord *)ptr, "ns1:GetAlertSchedulesRecord");
	case SOAP_TYPE_ns1__GetAlertSchedulesRecordResponse:
		return soap_out_ns1__GetAlertSchedulesRecordResponse(soap, tag, id, (const struct ns1__GetAlertSchedulesRecordResponse *)ptr, "ns1:GetAlertSchedulesRecordResponse");
	case SOAP_TYPE_ns1__GetAlertActionParameterRecord:
		return soap_out_ns1__GetAlertActionParameterRecord(soap, tag, id, (const struct ns1__GetAlertActionParameterRecord *)ptr, "ns1:GetAlertActionParameterRecord");
	case SOAP_TYPE_ns1__GetAlertActionParameterRecordResponse:
		return soap_out_ns1__GetAlertActionParameterRecordResponse(soap, tag, id, (const struct ns1__GetAlertActionParameterRecordResponse *)ptr, "ns1:GetAlertActionParameterRecordResponse");
	case SOAP_TYPE_ns1__GetAlertActionFieldsRecord:
		return soap_out_ns1__GetAlertActionFieldsRecord(soap, tag, id, (const struct ns1__GetAlertActionFieldsRecord *)ptr, "ns1:GetAlertActionFieldsRecord");
	case SOAP_TYPE_ns1__GetAlertActionFieldsRecordResponse:
		return soap_out_ns1__GetAlertActionFieldsRecordResponse(soap, tag, id, (const struct ns1__GetAlertActionFieldsRecordResponse *)ptr, "ns1:GetAlertActionFieldsRecordResponse");
	case SOAP_TYPE_ns1__GetTlkpDocumentTypesRecord:
		return soap_out_ns1__GetTlkpDocumentTypesRecord(soap, tag, id, (const struct ns1__GetTlkpDocumentTypesRecord *)ptr, "ns1:GetTlkpDocumentTypesRecord");
	case SOAP_TYPE_ns1__GetTlkpDocumentTypesRecordResponse:
		return soap_out_ns1__GetTlkpDocumentTypesRecordResponse(soap, tag, id, (const struct ns1__GetTlkpDocumentTypesRecordResponse *)ptr, "ns1:GetTlkpDocumentTypesRecordResponse");
	case SOAP_TYPE_ns1__GetTlkpDocumentTypesRecordByClientType:
		return soap_out_ns1__GetTlkpDocumentTypesRecordByClientType(soap, tag, id, (const struct ns1__GetTlkpDocumentTypesRecordByClientType *)ptr, "ns1:GetTlkpDocumentTypesRecordByClientType");
	case SOAP_TYPE_ns1__GetTlkpDocumentTypesRecordByClientTypeResponse:
		return soap_out_ns1__GetTlkpDocumentTypesRecordByClientTypeResponse(soap, tag, id, (const struct ns1__GetTlkpDocumentTypesRecordByClientTypeResponse *)ptr, "ns1:GetTlkpDocumentTypesRecordByClientTypeResponse");
	case SOAP_TYPE_ns1__GetTlkpDocumentFieldsRecord:
		return soap_out_ns1__GetTlkpDocumentFieldsRecord(soap, tag, id, (const struct ns1__GetTlkpDocumentFieldsRecord *)ptr, "ns1:GetTlkpDocumentFieldsRecord");
	case SOAP_TYPE_ns1__GetTlkpDocumentFieldsRecordResponse:
		return soap_out_ns1__GetTlkpDocumentFieldsRecordResponse(soap, tag, id, (const struct ns1__GetTlkpDocumentFieldsRecordResponse *)ptr, "ns1:GetTlkpDocumentFieldsRecordResponse");
	case SOAP_TYPE_ns1__GetTlkpDocumentFieldTypesRecord:
		return soap_out_ns1__GetTlkpDocumentFieldTypesRecord(soap, tag, id, (const struct ns1__GetTlkpDocumentFieldTypesRecord *)ptr, "ns1:GetTlkpDocumentFieldTypesRecord");
	case SOAP_TYPE_ns1__GetTlkpDocumentFieldTypesRecordResponse:
		return soap_out_ns1__GetTlkpDocumentFieldTypesRecordResponse(soap, tag, id, (const struct ns1__GetTlkpDocumentFieldTypesRecordResponse *)ptr, "ns1:GetTlkpDocumentFieldTypesRecordResponse");
	case SOAP_TYPE_ns1__GetTlkpActionsRecord:
		return soap_out_ns1__GetTlkpActionsRecord(soap, tag, id, (const struct ns1__GetTlkpActionsRecord *)ptr, "ns1:GetTlkpActionsRecord");
	case SOAP_TYPE_ns1__GetTlkpActionsRecordResponse:
		return soap_out_ns1__GetTlkpActionsRecordResponse(soap, tag, id, (const struct ns1__GetTlkpActionsRecordResponse *)ptr, "ns1:GetTlkpActionsRecordResponse");
	case SOAP_TYPE_ns1__GetTlkpActionsRecordByAction:
		return soap_out_ns1__GetTlkpActionsRecordByAction(soap, tag, id, (const struct ns1__GetTlkpActionsRecordByAction *)ptr, "ns1:GetTlkpActionsRecordByAction");
	case SOAP_TYPE_ns1__GetTlkpActionsRecordByActionResponse:
		return soap_out_ns1__GetTlkpActionsRecordByActionResponse(soap, tag, id, (const struct ns1__GetTlkpActionsRecordByActionResponse *)ptr, "ns1:GetTlkpActionsRecordByActionResponse");
	case SOAP_TYPE_ns1__GetTlkpPriorityLevelRecord:
		return soap_out_ns1__GetTlkpPriorityLevelRecord(soap, tag, id, (const struct ns1__GetTlkpPriorityLevelRecord *)ptr, "ns1:GetTlkpPriorityLevelRecord");
	case SOAP_TYPE_ns1__GetTlkpPriorityLevelRecordResponse:
		return soap_out_ns1__GetTlkpPriorityLevelRecordResponse(soap, tag, id, (const struct ns1__GetTlkpPriorityLevelRecordResponse *)ptr, "ns1:GetTlkpPriorityLevelRecordResponse");
	case SOAP_TYPE_ns1__GetTlkpPriorityLevelRecordByPriorityLevel:
		return soap_out_ns1__GetTlkpPriorityLevelRecordByPriorityLevel(soap, tag, id, (const struct ns1__GetTlkpPriorityLevelRecordByPriorityLevel *)ptr, "ns1:GetTlkpPriorityLevelRecordByPriorityLevel");
	case SOAP_TYPE_ns1__GetTlkpPriorityLevelRecordByPriorityLevelResponse:
		return soap_out_ns1__GetTlkpPriorityLevelRecordByPriorityLevelResponse(soap, tag, id, (const struct ns1__GetTlkpPriorityLevelRecordByPriorityLevelResponse *)ptr, "ns1:GetTlkpPriorityLevelRecordByPriorityLevelResponse");
	case SOAP_TYPE_ns1__GetTlkpActionParametersRecord:
		return soap_out_ns1__GetTlkpActionParametersRecord(soap, tag, id, (const struct ns1__GetTlkpActionParametersRecord *)ptr, "ns1:GetTlkpActionParametersRecord");
	case SOAP_TYPE_ns1__GetTlkpActionParametersRecordResponse:
		return soap_out_ns1__GetTlkpActionParametersRecordResponse(soap, tag, id, (const struct ns1__GetTlkpActionParametersRecordResponse *)ptr, "ns1:GetTlkpActionParametersRecordResponse");
	case SOAP_TYPE_ns1__GetTlkpActionParametersRecordByParameterId:
		return soap_out_ns1__GetTlkpActionParametersRecordByParameterId(soap, tag, id, (const struct ns1__GetTlkpActionParametersRecordByParameterId *)ptr, "ns1:GetTlkpActionParametersRecordByParameterId");
	case SOAP_TYPE_ns1__GetTlkpActionParametersRecordByParameterIdResponse:
		return soap_out_ns1__GetTlkpActionParametersRecordByParameterIdResponse(soap, tag, id, (const struct ns1__GetTlkpActionParametersRecordByParameterIdResponse *)ptr, "ns1:GetTlkpActionParametersRecordByParameterIdResponse");
	case SOAP_TYPE_ns1__SendAlert:
		return soap_out_ns1__SendAlert(soap, tag, id, (const struct ns1__SendAlert *)ptr, "ns1:SendAlert");
	case SOAP_TYPE_ns1__SendAlertResponse:
		return soap_out_ns1__SendAlertResponse(soap, tag, id, (const struct ns1__SendAlertResponse *)ptr, "ns1:SendAlertResponse");
	case SOAP_TYPE_ns1__SendNetworkDocument:
		return soap_out_ns1__SendNetworkDocument(soap, tag, id, (const struct ns1__SendNetworkDocument *)ptr, "ns1:SendNetworkDocument");
	case SOAP_TYPE_ns1__SendNetworkDocumentResponse:
		return soap_out_ns1__SendNetworkDocumentResponse(soap, tag, id, (const struct ns1__SendNetworkDocumentResponse *)ptr, "ns1:SendNetworkDocumentResponse");
	case SOAP_TYPE_ns1__SubscribeToDocumentType:
		return soap_out_ns1__SubscribeToDocumentType(soap, tag, id, (const struct ns1__SubscribeToDocumentType *)ptr, "ns1:SubscribeToDocumentType");
	case SOAP_TYPE_ns1__SubscribeToDocumentTypeResponse:
		return soap_out_ns1__SubscribeToDocumentTypeResponse(soap, tag, id, (const struct ns1__SubscribeToDocumentTypeResponse *)ptr, "ns1:SubscribeToDocumentTypeResponse");
	case SOAP_TYPE_ns1__UnSubscribeToDocumentType:
		return soap_out_ns1__UnSubscribeToDocumentType(soap, tag, id, (const struct ns1__UnSubscribeToDocumentType *)ptr, "ns1:UnSubscribeToDocumentType");
	case SOAP_TYPE_ns1__UnSubscribeToDocumentTypeResponse:
		return soap_out_ns1__UnSubscribeToDocumentTypeResponse(soap, tag, id, (const struct ns1__UnSubscribeToDocumentTypeResponse *)ptr, "ns1:UnSubscribeToDocumentTypeResponse");
	case SOAP_TYPE_ns1__SendServerUpdateNotification:
		return soap_out_ns1__SendServerUpdateNotification(soap, tag, id, (const struct ns1__SendServerUpdateNotification *)ptr, "ns1:SendServerUpdateNotification");
	case SOAP_TYPE_ns1__SendServerUpdateNotificationResponse:
		return soap_out_ns1__SendServerUpdateNotificationResponse(soap, tag, id, (const struct ns1__SendServerUpdateNotificationResponse *)ptr, "ns1:SendServerUpdateNotificationResponse");
	case SOAP_TYPE_ns1__SetClientType:
		return soap_out_ns1__SetClientType(soap, tag, id, (const struct ns1__SetClientType *)ptr, "ns1:SetClientType");
	case SOAP_TYPE_ns1__SetClientTypeResponse:
		return soap_out_ns1__SetClientTypeResponse(soap, tag, id, (const struct ns1__SetClientTypeResponse *)ptr, "ns1:SetClientTypeResponse");
	case SOAP_TYPE_ns1__GetRunningCenterCord:
		return soap_out_ns1__GetRunningCenterCord(soap, tag, id, (const struct ns1__GetRunningCenterCord *)ptr, "ns1:GetRunningCenterCord");
	case SOAP_TYPE_ns1__GetRunningCenterCordResponse:
		return soap_out_ns1__GetRunningCenterCordResponse(soap, tag, id, (const struct ns1__GetRunningCenterCordResponse *)ptr, "ns1:GetRunningCenterCordResponse");
	case SOAP_TYPE_ns1__DeleteAlert:
		return soap_out_ns1__DeleteAlert(soap, tag, id, (const struct ns1__DeleteAlert *)ptr, "ns1:DeleteAlert");
	case SOAP_TYPE_ns1__DeleteAlertResponse:
		return soap_out_ns1__DeleteAlertResponse(soap, tag, id, (const struct ns1__DeleteAlertResponse *)ptr, "ns1:DeleteAlertResponse");
	case SOAP_TYPE_ns1__DeleteAlertEvaluation:
		return soap_out_ns1__DeleteAlertEvaluation(soap, tag, id, (const struct ns1__DeleteAlertEvaluation *)ptr, "ns1:DeleteAlertEvaluation");
	case SOAP_TYPE_ns1__DeleteAlertEvaluationResponse:
		return soap_out_ns1__DeleteAlertEvaluationResponse(soap, tag, id, (const struct ns1__DeleteAlertEvaluationResponse *)ptr, "ns1:DeleteAlertEvaluationResponse");
	case SOAP_TYPE_ns1__DeleteAlertEvaluation2:
		return soap_out_ns1__DeleteAlertEvaluation2(soap, tag, id, (const struct ns1__DeleteAlertEvaluation2 *)ptr, "ns1:DeleteAlertEvaluation2");
	case SOAP_TYPE_ns1__DeleteAlertEvaluation2Response:
		return soap_out_ns1__DeleteAlertEvaluation2Response(soap, tag, id, (const struct ns1__DeleteAlertEvaluation2Response *)ptr, "ns1:DeleteAlertEvaluation2Response");
	case SOAP_TYPE_ns1__DeleteAlertAction:
		return soap_out_ns1__DeleteAlertAction(soap, tag, id, (const struct ns1__DeleteAlertAction *)ptr, "ns1:DeleteAlertAction");
	case SOAP_TYPE_ns1__DeleteAlertActionResponse:
		return soap_out_ns1__DeleteAlertActionResponse(soap, tag, id, (const struct ns1__DeleteAlertActionResponse *)ptr, "ns1:DeleteAlertActionResponse");
	case SOAP_TYPE_ns1__DeleteAlertAction2:
		return soap_out_ns1__DeleteAlertAction2(soap, tag, id, (const struct ns1__DeleteAlertAction2 *)ptr, "ns1:DeleteAlertAction2");
	case SOAP_TYPE_ns1__DeleteAlertAction2Response:
		return soap_out_ns1__DeleteAlertAction2Response(soap, tag, id, (const struct ns1__DeleteAlertAction2Response *)ptr, "ns1:DeleteAlertAction2Response");
	case SOAP_TYPE_ns1__DeleteAlertSchedule:
		return soap_out_ns1__DeleteAlertSchedule(soap, tag, id, (const struct ns1__DeleteAlertSchedule *)ptr, "ns1:DeleteAlertSchedule");
	case SOAP_TYPE_ns1__DeleteAlertScheduleResponse:
		return soap_out_ns1__DeleteAlertScheduleResponse(soap, tag, id, (const struct ns1__DeleteAlertScheduleResponse *)ptr, "ns1:DeleteAlertScheduleResponse");
	case SOAP_TYPE_ns1__DeleteAlertScheduleByScheduleId:
		return soap_out_ns1__DeleteAlertScheduleByScheduleId(soap, tag, id, (const struct ns1__DeleteAlertScheduleByScheduleId *)ptr, "ns1:DeleteAlertScheduleByScheduleId");
	case SOAP_TYPE_ns1__DeleteAlertScheduleByScheduleIdResponse:
		return soap_out_ns1__DeleteAlertScheduleByScheduleIdResponse(soap, tag, id, (const struct ns1__DeleteAlertScheduleByScheduleIdResponse *)ptr, "ns1:DeleteAlertScheduleByScheduleIdResponse");
	case SOAP_TYPE_ns1__DeleteAlertActionParameter:
		return soap_out_ns1__DeleteAlertActionParameter(soap, tag, id, (const struct ns1__DeleteAlertActionParameter *)ptr, "ns1:DeleteAlertActionParameter");
	case SOAP_TYPE_ns1__DeleteAlertActionParameterResponse:
		return soap_out_ns1__DeleteAlertActionParameterResponse(soap, tag, id, (const struct ns1__DeleteAlertActionParameterResponse *)ptr, "ns1:DeleteAlertActionParameterResponse");
	case SOAP_TYPE_ns1__DeleteAlertActionParameter2:
		return soap_out_ns1__DeleteAlertActionParameter2(soap, tag, id, (const struct ns1__DeleteAlertActionParameter2 *)ptr, "ns1:DeleteAlertActionParameter2");
	case SOAP_TYPE_ns1__DeleteAlertActionParameter2Response:
		return soap_out_ns1__DeleteAlertActionParameter2Response(soap, tag, id, (const struct ns1__DeleteAlertActionParameter2Response *)ptr, "ns1:DeleteAlertActionParameter2Response");
	case SOAP_TYPE_ns1__DeleteAlertActionField:
		return soap_out_ns1__DeleteAlertActionField(soap, tag, id, (const struct ns1__DeleteAlertActionField *)ptr, "ns1:DeleteAlertActionField");
	case SOAP_TYPE_ns1__DeleteAlertActionFieldResponse:
		return soap_out_ns1__DeleteAlertActionFieldResponse(soap, tag, id, (const struct ns1__DeleteAlertActionFieldResponse *)ptr, "ns1:DeleteAlertActionFieldResponse");
	case SOAP_TYPE_ns1__DeleteAlertActionField2:
		return soap_out_ns1__DeleteAlertActionField2(soap, tag, id, (const struct ns1__DeleteAlertActionField2 *)ptr, "ns1:DeleteAlertActionField2");
	case SOAP_TYPE_ns1__DeleteAlertActionField2Response:
		return soap_out_ns1__DeleteAlertActionField2Response(soap, tag, id, (const struct ns1__DeleteAlertActionField2Response *)ptr, "ns1:DeleteAlertActionField2Response");
	case SOAP_TYPE_ns1__AcknowledgeSystemAlert:
		return soap_out_ns1__AcknowledgeSystemAlert(soap, tag, id, (const struct ns1__AcknowledgeSystemAlert *)ptr, "ns1:AcknowledgeSystemAlert");
	case SOAP_TYPE_ns1__AcknowledgeSystemAlertResponse:
		return soap_out_ns1__AcknowledgeSystemAlertResponse(soap, tag, id, (const struct ns1__AcknowledgeSystemAlertResponse *)ptr, "ns1:AcknowledgeSystemAlertResponse");
	case SOAP_TYPE_ns1__AcknowledgeApplicationAlert:
		return soap_out_ns1__AcknowledgeApplicationAlert(soap, tag, id, (const struct ns1__AcknowledgeApplicationAlert *)ptr, "ns1:AcknowledgeApplicationAlert");
	case SOAP_TYPE_ns1__AcknowledgeApplicationAlertResponse:
		return soap_out_ns1__AcknowledgeApplicationAlertResponse(soap, tag, id, (const struct ns1__AcknowledgeApplicationAlertResponse *)ptr, "ns1:AcknowledgeApplicationAlertResponse");
	case SOAP_TYPE_ns1__GetSystemAlerts:
		return soap_out_ns1__GetSystemAlerts(soap, tag, id, (const struct ns1__GetSystemAlerts *)ptr, "ns1:GetSystemAlerts");
	case SOAP_TYPE_ns1__GetSystemAlertsResponse:
		return soap_out_ns1__GetSystemAlertsResponse(soap, tag, id, (const struct ns1__GetSystemAlertsResponse *)ptr, "ns1:GetSystemAlertsResponse");
	case SOAP_TYPE_ns1__GetSystemAlertsByStartDate:
		return soap_out_ns1__GetSystemAlertsByStartDate(soap, tag, id, (const struct ns1__GetSystemAlertsByStartDate *)ptr, "ns1:GetSystemAlertsByStartDate");
	case SOAP_TYPE_ns1__GetSystemAlertsByStartDateResponse:
		return soap_out_ns1__GetSystemAlertsByStartDateResponse(soap, tag, id, (const struct ns1__GetSystemAlertsByStartDateResponse *)ptr, "ns1:GetSystemAlertsByStartDateResponse");
	case SOAP_TYPE_ns1__GetSystemAlertsFilter:
		return soap_out_ns1__GetSystemAlertsFilter(soap, tag, id, (const struct ns1__GetSystemAlertsFilter *)ptr, "ns1:GetSystemAlertsFilter");
	case SOAP_TYPE_ns1__GetSystemAlertsFilterResponse:
		return soap_out_ns1__GetSystemAlertsFilterResponse(soap, tag, id, (const struct ns1__GetSystemAlertsFilterResponse *)ptr, "ns1:GetSystemAlertsFilterResponse");
	case SOAP_TYPE_ns1__GetApplicationAlertsFilter:
		return soap_out_ns1__GetApplicationAlertsFilter(soap, tag, id, (const struct ns1__GetApplicationAlertsFilter *)ptr, "ns1:GetApplicationAlertsFilter");
	case SOAP_TYPE_ns1__GetApplicationAlertsFilterResponse:
		return soap_out_ns1__GetApplicationAlertsFilterResponse(soap, tag, id, (const struct ns1__GetApplicationAlertsFilterResponse *)ptr, "ns1:GetApplicationAlertsFilterResponse");
	case SOAP_TYPE_ns1__GetApplicationAlerts:
		return soap_out_ns1__GetApplicationAlerts(soap, tag, id, (const struct ns1__GetApplicationAlerts *)ptr, "ns1:GetApplicationAlerts");
	case SOAP_TYPE_ns1__GetApplicationAlertsResponse:
		return soap_out_ns1__GetApplicationAlertsResponse(soap, tag, id, (const struct ns1__GetApplicationAlertsResponse *)ptr, "ns1:GetApplicationAlertsResponse");
	case SOAP_TYPE_ns1__GetApplicationAlertsByStartDate:
		return soap_out_ns1__GetApplicationAlertsByStartDate(soap, tag, id, (const struct ns1__GetApplicationAlertsByStartDate *)ptr, "ns1:GetApplicationAlertsByStartDate");
	case SOAP_TYPE_ns1__GetApplicationAlertsByStartDateResponse:
		return soap_out_ns1__GetApplicationAlertsByStartDateResponse(soap, tag, id, (const struct ns1__GetApplicationAlertsByStartDateResponse *)ptr, "ns1:GetApplicationAlertsByStartDateResponse");
	case SOAP_TYPE_ns1__GetTlkpSystemAlertTypesRecord:
		return soap_out_ns1__GetTlkpSystemAlertTypesRecord(soap, tag, id, (const struct ns1__GetTlkpSystemAlertTypesRecord *)ptr, "ns1:GetTlkpSystemAlertTypesRecord");
	case SOAP_TYPE_ns1__GetTlkpSystemAlertTypesRecordResponse:
		return soap_out_ns1__GetTlkpSystemAlertTypesRecordResponse(soap, tag, id, (const struct ns1__GetTlkpSystemAlertTypesRecordResponse *)ptr, "ns1:GetTlkpSystemAlertTypesRecordResponse");
	case SOAP_TYPE_ns1__GetTlkpSystemAlertActionsRecord:
		return soap_out_ns1__GetTlkpSystemAlertActionsRecord(soap, tag, id, (const struct ns1__GetTlkpSystemAlertActionsRecord *)ptr, "ns1:GetTlkpSystemAlertActionsRecord");
	case SOAP_TYPE_ns1__GetTlkpSystemAlertActionsRecordResponse:
		return soap_out_ns1__GetTlkpSystemAlertActionsRecordResponse(soap, tag, id, (const struct ns1__GetTlkpSystemAlertActionsRecordResponse *)ptr, "ns1:GetTlkpSystemAlertActionsRecordResponse");
	case SOAP_TYPE_ns1__GetTlkpSystemAlertStatesRecord:
		return soap_out_ns1__GetTlkpSystemAlertStatesRecord(soap, tag, id, (const struct ns1__GetTlkpSystemAlertStatesRecord *)ptr, "ns1:GetTlkpSystemAlertStatesRecord");
	case SOAP_TYPE_ns1__GetTlkpSystemAlertStatesRecordResponse:
		return soap_out_ns1__GetTlkpSystemAlertStatesRecordResponse(soap, tag, id, (const struct ns1__GetTlkpSystemAlertStatesRecordResponse *)ptr, "ns1:GetTlkpSystemAlertStatesRecordResponse");
	case SOAP_TYPE_ns1__GetServerRecord:
		return soap_out_ns1__GetServerRecord(soap, tag, id, (const struct ns1__GetServerRecord *)ptr, "ns1:GetServerRecord");
	case SOAP_TYPE_ns1__GetServerRecordResponse:
		return soap_out_ns1__GetServerRecordResponse(soap, tag, id, (const struct ns1__GetServerRecordResponse *)ptr, "ns1:GetServerRecordResponse");
	case SOAP_TYPE_ns1__GetServerTypeRecord:
		return soap_out_ns1__GetServerTypeRecord(soap, tag, id, (const struct ns1__GetServerTypeRecord *)ptr, "ns1:GetServerTypeRecord");
	case SOAP_TYPE_ns1__GetServerTypeRecordResponse:
		return soap_out_ns1__GetServerTypeRecordResponse(soap, tag, id, (const struct ns1__GetServerTypeRecordResponse *)ptr, "ns1:GetServerTypeRecordResponse");
	case SOAP_TYPE_ns1__GetSiteRecord:
		return soap_out_ns1__GetSiteRecord(soap, tag, id, (const struct ns1__GetSiteRecord *)ptr, "ns1:GetSiteRecord");
	case SOAP_TYPE_ns1__GetSiteRecordResponse:
		return soap_out_ns1__GetSiteRecordResponse(soap, tag, id, (const struct ns1__GetSiteRecordResponse *)ptr, "ns1:GetSiteRecordResponse");
	case SOAP_TYPE_ns1__ClearApplicationAlert:
		return soap_out_ns1__ClearApplicationAlert(soap, tag, id, (const struct ns1__ClearApplicationAlert *)ptr, "ns1:ClearApplicationAlert");
	case SOAP_TYPE_ns1__ClearApplicationAlertResponse:
		return soap_out_ns1__ClearApplicationAlertResponse(soap, tag, id, (const struct ns1__ClearApplicationAlertResponse *)ptr, "ns1:ClearApplicationAlertResponse");
	case SOAP_TYPE_ns1__ClearSystemAlert:
		return soap_out_ns1__ClearSystemAlert(soap, tag, id, (const struct ns1__ClearSystemAlert *)ptr, "ns1:ClearSystemAlert");
	case SOAP_TYPE_ns1__ClearSystemAlertResponse:
		return soap_out_ns1__ClearSystemAlertResponse(soap, tag, id, (const struct ns1__ClearSystemAlertResponse *)ptr, "ns1:ClearSystemAlertResponse");
	case SOAP_TYPE_ns1__GetVersion:
		return soap_out_ns1__GetVersion(soap, tag, id, (const struct ns1__GetVersion *)ptr, "ns1:GetVersion");
	case SOAP_TYPE_ns1__GetVersionResponse:
		return soap_out_ns1__GetVersionResponse(soap, tag, id, (const struct ns1__GetVersionResponse *)ptr, "ns1:GetVersionResponse");
	case SOAP_TYPE_PointerTons1__DCenterCordInfo:
		return soap_out_PointerTons1__DCenterCordInfo(soap, tag, id, (ns1__DCenterCordInfo *const*)ptr, "ns1:DCenterCordInfo");
	case SOAP_TYPE_PointerToSOAP_ENC__string:
		return soap_out_PointerToSOAP_ENC__string(soap, tag, id, (std::string *const*)ptr, "SOAP-ENC:string");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:string");
	case 0:
		return SOAP_OK;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_putelement '%s' failed for type %d in soapC.cpp\n", tag ? tag : "", type));
	return soap_element_empty(soap, tag); /* unknown type to serialize */
}
#ifdef __cplusplus
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_ns1__DCenterCordInfo:
		((ns1__DCenterCordInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_SOAP_ENC__string:
		soap_serialize_SOAP_ENC__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns1__GetWebServiceName:
		soap_serialize_ns1__GetWebServiceName(soap, (const struct ns1__GetWebServiceName *)ptr);
		break;
	case SOAP_TYPE_ns1__GetWebServiceNameResponse:
		soap_serialize_ns1__GetWebServiceNameResponse(soap, (const struct ns1__GetWebServiceNameResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__InsertAlert:
		soap_serialize_ns1__InsertAlert(soap, (const struct ns1__InsertAlert *)ptr);
		break;
	case SOAP_TYPE_ns1__InsertAlertResponse:
		soap_serialize_ns1__InsertAlertResponse(soap, (const struct ns1__InsertAlertResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__UpdateAlert:
		soap_serialize_ns1__UpdateAlert(soap, (const struct ns1__UpdateAlert *)ptr);
		break;
	case SOAP_TYPE_ns1__UpdateAlertResponse:
		soap_serialize_ns1__UpdateAlertResponse(soap, (const struct ns1__UpdateAlertResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__InsertAlertEvaluation:
		soap_serialize_ns1__InsertAlertEvaluation(soap, (const struct ns1__InsertAlertEvaluation *)ptr);
		break;
	case SOAP_TYPE_ns1__InsertAlertEvaluationResponse:
		soap_serialize_ns1__InsertAlertEvaluationResponse(soap, (const struct ns1__InsertAlertEvaluationResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__UpdatetAlertEvaluation:
		soap_serialize_ns1__UpdatetAlertEvaluation(soap, (const struct ns1__UpdatetAlertEvaluation *)ptr);
		break;
	case SOAP_TYPE_ns1__UpdatetAlertEvaluationResponse:
		soap_serialize_ns1__UpdatetAlertEvaluationResponse(soap, (const struct ns1__UpdatetAlertEvaluationResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__InsertAlertAction:
		soap_serialize_ns1__InsertAlertAction(soap, (const struct ns1__InsertAlertAction *)ptr);
		break;
	case SOAP_TYPE_ns1__InsertAlertActionResponse:
		soap_serialize_ns1__InsertAlertActionResponse(soap, (const struct ns1__InsertAlertActionResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__UpdateAlertAction:
		soap_serialize_ns1__UpdateAlertAction(soap, (const struct ns1__UpdateAlertAction *)ptr);
		break;
	case SOAP_TYPE_ns1__UpdateAlertActionResponse:
		soap_serialize_ns1__UpdateAlertActionResponse(soap, (const struct ns1__UpdateAlertActionResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__InsertAlertSchedule:
		soap_serialize_ns1__InsertAlertSchedule(soap, (const struct ns1__InsertAlertSchedule *)ptr);
		break;
	case SOAP_TYPE_ns1__InsertAlertScheduleResponse:
		soap_serialize_ns1__InsertAlertScheduleResponse(soap, (const struct ns1__InsertAlertScheduleResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__UpdateAlertSchedule:
		soap_serialize_ns1__UpdateAlertSchedule(soap, (const struct ns1__UpdateAlertSchedule *)ptr);
		break;
	case SOAP_TYPE_ns1__UpdateAlertScheduleResponse:
		soap_serialize_ns1__UpdateAlertScheduleResponse(soap, (const struct ns1__UpdateAlertScheduleResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__InsertAlertActionParameter:
		soap_serialize_ns1__InsertAlertActionParameter(soap, (const struct ns1__InsertAlertActionParameter *)ptr);
		break;
	case SOAP_TYPE_ns1__InsertAlertActionParameterResponse:
		soap_serialize_ns1__InsertAlertActionParameterResponse(soap, (const struct ns1__InsertAlertActionParameterResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__UpdateAlertActionParameter:
		soap_serialize_ns1__UpdateAlertActionParameter(soap, (const struct ns1__UpdateAlertActionParameter *)ptr);
		break;
	case SOAP_TYPE_ns1__UpdateAlertActionParameterResponse:
		soap_serialize_ns1__UpdateAlertActionParameterResponse(soap, (const struct ns1__UpdateAlertActionParameterResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__InsertAlertActionField:
		soap_serialize_ns1__InsertAlertActionField(soap, (const struct ns1__InsertAlertActionField *)ptr);
		break;
	case SOAP_TYPE_ns1__InsertAlertActionFieldResponse:
		soap_serialize_ns1__InsertAlertActionFieldResponse(soap, (const struct ns1__InsertAlertActionFieldResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__UpdateAlertActionField:
		soap_serialize_ns1__UpdateAlertActionField(soap, (const struct ns1__UpdateAlertActionField *)ptr);
		break;
	case SOAP_TYPE_ns1__UpdateAlertActionFieldResponse:
		soap_serialize_ns1__UpdateAlertActionFieldResponse(soap, (const struct ns1__UpdateAlertActionFieldResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__GetAlertsRecord:
		soap_serialize_ns1__GetAlertsRecord(soap, (const struct ns1__GetAlertsRecord *)ptr);
		break;
	case SOAP_TYPE_ns1__GetAlertsRecordResponse:
		soap_serialize_ns1__GetAlertsRecordResponse(soap, (const struct ns1__GetAlertsRecordResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__GetAlertsRecordByDocumentType:
		soap_serialize_ns1__GetAlertsRecordByDocumentType(soap, (const struct ns1__GetAlertsRecordByDocumentType *)ptr);
		break;
	case SOAP_TYPE_ns1__GetAlertsRecordByDocumentTypeResponse:
		soap_serialize_ns1__GetAlertsRecordByDocumentTypeResponse(soap, (const struct ns1__GetAlertsRecordByDocumentTypeResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__GetAlertEvaluationsRecord:
		soap_serialize_ns1__GetAlertEvaluationsRecord(soap, (const struct ns1__GetAlertEvaluationsRecord *)ptr);
		break;
	case SOAP_TYPE_ns1__GetAlertEvaluationsRecordResponse:
		soap_serialize_ns1__GetAlertEvaluationsRecordResponse(soap, (const struct ns1__GetAlertEvaluationsRecordResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__GetAlertActionsRecord:
		soap_serialize_ns1__GetAlertActionsRecord(soap, (const struct ns1__GetAlertActionsRecord *)ptr);
		break;
	case SOAP_TYPE_ns1__GetAlertActionsRecordResponse:
		soap_serialize_ns1__GetAlertActionsRecordResponse(soap, (const struct ns1__GetAlertActionsRecordResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__GetAlertSchedulesRecord:
		soap_serialize_ns1__GetAlertSchedulesRecord(soap, (const struct ns1__GetAlertSchedulesRecord *)ptr);
		break;
	case SOAP_TYPE_ns1__GetAlertSchedulesRecordResponse:
		soap_serialize_ns1__GetAlertSchedulesRecordResponse(soap, (const struct ns1__GetAlertSchedulesRecordResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__GetAlertActionParameterRecord:
		soap_serialize_ns1__GetAlertActionParameterRecord(soap, (const struct ns1__GetAlertActionParameterRecord *)ptr);
		break;
	case SOAP_TYPE_ns1__GetAlertActionParameterRecordResponse:
		soap_serialize_ns1__GetAlertActionParameterRecordResponse(soap, (const struct ns1__GetAlertActionParameterRecordResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__GetAlertActionFieldsRecord:
		soap_serialize_ns1__GetAlertActionFieldsRecord(soap, (const struct ns1__GetAlertActionFieldsRecord *)ptr);
		break;
	case SOAP_TYPE_ns1__GetAlertActionFieldsRecordResponse:
		soap_serialize_ns1__GetAlertActionFieldsRecordResponse(soap, (const struct ns1__GetAlertActionFieldsRecordResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__GetTlkpDocumentTypesRecord:
		soap_serialize_ns1__GetTlkpDocumentTypesRecord(soap, (const struct ns1__GetTlkpDocumentTypesRecord *)ptr);
		break;
	case SOAP_TYPE_ns1__GetTlkpDocumentTypesRecordResponse:
		soap_serialize_ns1__GetTlkpDocumentTypesRecordResponse(soap, (const struct ns1__GetTlkpDocumentTypesRecordResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__GetTlkpDocumentTypesRecordByClientType:
		soap_serialize_ns1__GetTlkpDocumentTypesRecordByClientType(soap, (const struct ns1__GetTlkpDocumentTypesRecordByClientType *)ptr);
		break;
	case SOAP_TYPE_ns1__GetTlkpDocumentTypesRecordByClientTypeResponse:
		soap_serialize_ns1__GetTlkpDocumentTypesRecordByClientTypeResponse(soap, (const struct ns1__GetTlkpDocumentTypesRecordByClientTypeResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__GetTlkpDocumentFieldsRecord:
		soap_serialize_ns1__GetTlkpDocumentFieldsRecord(soap, (const struct ns1__GetTlkpDocumentFieldsRecord *)ptr);
		break;
	case SOAP_TYPE_ns1__GetTlkpDocumentFieldsRecordResponse:
		soap_serialize_ns1__GetTlkpDocumentFieldsRecordResponse(soap, (const struct ns1__GetTlkpDocumentFieldsRecordResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__GetTlkpDocumentFieldTypesRecord:
		soap_serialize_ns1__GetTlkpDocumentFieldTypesRecord(soap, (const struct ns1__GetTlkpDocumentFieldTypesRecord *)ptr);
		break;
	case SOAP_TYPE_ns1__GetTlkpDocumentFieldTypesRecordResponse:
		soap_serialize_ns1__GetTlkpDocumentFieldTypesRecordResponse(soap, (const struct ns1__GetTlkpDocumentFieldTypesRecordResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__GetTlkpActionsRecord:
		soap_serialize_ns1__GetTlkpActionsRecord(soap, (const struct ns1__GetTlkpActionsRecord *)ptr);
		break;
	case SOAP_TYPE_ns1__GetTlkpActionsRecordResponse:
		soap_serialize_ns1__GetTlkpActionsRecordResponse(soap, (const struct ns1__GetTlkpActionsRecordResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__GetTlkpActionsRecordByAction:
		soap_serialize_ns1__GetTlkpActionsRecordByAction(soap, (const struct ns1__GetTlkpActionsRecordByAction *)ptr);
		break;
	case SOAP_TYPE_ns1__GetTlkpActionsRecordByActionResponse:
		soap_serialize_ns1__GetTlkpActionsRecordByActionResponse(soap, (const struct ns1__GetTlkpActionsRecordByActionResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__GetTlkpPriorityLevelRecord:
		soap_serialize_ns1__GetTlkpPriorityLevelRecord(soap, (const struct ns1__GetTlkpPriorityLevelRecord *)ptr);
		break;
	case SOAP_TYPE_ns1__GetTlkpPriorityLevelRecordResponse:
		soap_serialize_ns1__GetTlkpPriorityLevelRecordResponse(soap, (const struct ns1__GetTlkpPriorityLevelRecordResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__GetTlkpPriorityLevelRecordByPriorityLevel:
		soap_serialize_ns1__GetTlkpPriorityLevelRecordByPriorityLevel(soap, (const struct ns1__GetTlkpPriorityLevelRecordByPriorityLevel *)ptr);
		break;
	case SOAP_TYPE_ns1__GetTlkpPriorityLevelRecordByPriorityLevelResponse:
		soap_serialize_ns1__GetTlkpPriorityLevelRecordByPriorityLevelResponse(soap, (const struct ns1__GetTlkpPriorityLevelRecordByPriorityLevelResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__GetTlkpActionParametersRecord:
		soap_serialize_ns1__GetTlkpActionParametersRecord(soap, (const struct ns1__GetTlkpActionParametersRecord *)ptr);
		break;
	case SOAP_TYPE_ns1__GetTlkpActionParametersRecordResponse:
		soap_serialize_ns1__GetTlkpActionParametersRecordResponse(soap, (const struct ns1__GetTlkpActionParametersRecordResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__GetTlkpActionParametersRecordByParameterId:
		soap_serialize_ns1__GetTlkpActionParametersRecordByParameterId(soap, (const struct ns1__GetTlkpActionParametersRecordByParameterId *)ptr);
		break;
	case SOAP_TYPE_ns1__GetTlkpActionParametersRecordByParameterIdResponse:
		soap_serialize_ns1__GetTlkpActionParametersRecordByParameterIdResponse(soap, (const struct ns1__GetTlkpActionParametersRecordByParameterIdResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__SendAlert:
		soap_serialize_ns1__SendAlert(soap, (const struct ns1__SendAlert *)ptr);
		break;
	case SOAP_TYPE_ns1__SendAlertResponse:
		soap_serialize_ns1__SendAlertResponse(soap, (const struct ns1__SendAlertResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__SendNetworkDocument:
		soap_serialize_ns1__SendNetworkDocument(soap, (const struct ns1__SendNetworkDocument *)ptr);
		break;
	case SOAP_TYPE_ns1__SendNetworkDocumentResponse:
		soap_serialize_ns1__SendNetworkDocumentResponse(soap, (const struct ns1__SendNetworkDocumentResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__SubscribeToDocumentType:
		soap_serialize_ns1__SubscribeToDocumentType(soap, (const struct ns1__SubscribeToDocumentType *)ptr);
		break;
	case SOAP_TYPE_ns1__SubscribeToDocumentTypeResponse:
		soap_serialize_ns1__SubscribeToDocumentTypeResponse(soap, (const struct ns1__SubscribeToDocumentTypeResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__UnSubscribeToDocumentType:
		soap_serialize_ns1__UnSubscribeToDocumentType(soap, (const struct ns1__UnSubscribeToDocumentType *)ptr);
		break;
	case SOAP_TYPE_ns1__UnSubscribeToDocumentTypeResponse:
		soap_serialize_ns1__UnSubscribeToDocumentTypeResponse(soap, (const struct ns1__UnSubscribeToDocumentTypeResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__SendServerUpdateNotification:
		soap_serialize_ns1__SendServerUpdateNotification(soap, (const struct ns1__SendServerUpdateNotification *)ptr);
		break;
	case SOAP_TYPE_ns1__SendServerUpdateNotificationResponse:
		soap_serialize_ns1__SendServerUpdateNotificationResponse(soap, (const struct ns1__SendServerUpdateNotificationResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__SetClientType:
		soap_serialize_ns1__SetClientType(soap, (const struct ns1__SetClientType *)ptr);
		break;
	case SOAP_TYPE_ns1__SetClientTypeResponse:
		soap_serialize_ns1__SetClientTypeResponse(soap, (const struct ns1__SetClientTypeResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__GetRunningCenterCord:
		soap_serialize_ns1__GetRunningCenterCord(soap, (const struct ns1__GetRunningCenterCord *)ptr);
		break;
	case SOAP_TYPE_ns1__GetRunningCenterCordResponse:
		soap_serialize_ns1__GetRunningCenterCordResponse(soap, (const struct ns1__GetRunningCenterCordResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__DeleteAlert:
		soap_serialize_ns1__DeleteAlert(soap, (const struct ns1__DeleteAlert *)ptr);
		break;
	case SOAP_TYPE_ns1__DeleteAlertResponse:
		soap_serialize_ns1__DeleteAlertResponse(soap, (const struct ns1__DeleteAlertResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__DeleteAlertEvaluation:
		soap_serialize_ns1__DeleteAlertEvaluation(soap, (const struct ns1__DeleteAlertEvaluation *)ptr);
		break;
	case SOAP_TYPE_ns1__DeleteAlertEvaluationResponse:
		soap_serialize_ns1__DeleteAlertEvaluationResponse(soap, (const struct ns1__DeleteAlertEvaluationResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__DeleteAlertEvaluation2:
		soap_serialize_ns1__DeleteAlertEvaluation2(soap, (const struct ns1__DeleteAlertEvaluation2 *)ptr);
		break;
	case SOAP_TYPE_ns1__DeleteAlertEvaluation2Response:
		soap_serialize_ns1__DeleteAlertEvaluation2Response(soap, (const struct ns1__DeleteAlertEvaluation2Response *)ptr);
		break;
	case SOAP_TYPE_ns1__DeleteAlertAction:
		soap_serialize_ns1__DeleteAlertAction(soap, (const struct ns1__DeleteAlertAction *)ptr);
		break;
	case SOAP_TYPE_ns1__DeleteAlertActionResponse:
		soap_serialize_ns1__DeleteAlertActionResponse(soap, (const struct ns1__DeleteAlertActionResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__DeleteAlertAction2:
		soap_serialize_ns1__DeleteAlertAction2(soap, (const struct ns1__DeleteAlertAction2 *)ptr);
		break;
	case SOAP_TYPE_ns1__DeleteAlertAction2Response:
		soap_serialize_ns1__DeleteAlertAction2Response(soap, (const struct ns1__DeleteAlertAction2Response *)ptr);
		break;
	case SOAP_TYPE_ns1__DeleteAlertSchedule:
		soap_serialize_ns1__DeleteAlertSchedule(soap, (const struct ns1__DeleteAlertSchedule *)ptr);
		break;
	case SOAP_TYPE_ns1__DeleteAlertScheduleResponse:
		soap_serialize_ns1__DeleteAlertScheduleResponse(soap, (const struct ns1__DeleteAlertScheduleResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__DeleteAlertScheduleByScheduleId:
		soap_serialize_ns1__DeleteAlertScheduleByScheduleId(soap, (const struct ns1__DeleteAlertScheduleByScheduleId *)ptr);
		break;
	case SOAP_TYPE_ns1__DeleteAlertScheduleByScheduleIdResponse:
		soap_serialize_ns1__DeleteAlertScheduleByScheduleIdResponse(soap, (const struct ns1__DeleteAlertScheduleByScheduleIdResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__DeleteAlertActionParameter:
		soap_serialize_ns1__DeleteAlertActionParameter(soap, (const struct ns1__DeleteAlertActionParameter *)ptr);
		break;
	case SOAP_TYPE_ns1__DeleteAlertActionParameterResponse:
		soap_serialize_ns1__DeleteAlertActionParameterResponse(soap, (const struct ns1__DeleteAlertActionParameterResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__DeleteAlertActionParameter2:
		soap_serialize_ns1__DeleteAlertActionParameter2(soap, (const struct ns1__DeleteAlertActionParameter2 *)ptr);
		break;
	case SOAP_TYPE_ns1__DeleteAlertActionParameter2Response:
		soap_serialize_ns1__DeleteAlertActionParameter2Response(soap, (const struct ns1__DeleteAlertActionParameter2Response *)ptr);
		break;
	case SOAP_TYPE_ns1__DeleteAlertActionField:
		soap_serialize_ns1__DeleteAlertActionField(soap, (const struct ns1__DeleteAlertActionField *)ptr);
		break;
	case SOAP_TYPE_ns1__DeleteAlertActionFieldResponse:
		soap_serialize_ns1__DeleteAlertActionFieldResponse(soap, (const struct ns1__DeleteAlertActionFieldResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__DeleteAlertActionField2:
		soap_serialize_ns1__DeleteAlertActionField2(soap, (const struct ns1__DeleteAlertActionField2 *)ptr);
		break;
	case SOAP_TYPE_ns1__DeleteAlertActionField2Response:
		soap_serialize_ns1__DeleteAlertActionField2Response(soap, (const struct ns1__DeleteAlertActionField2Response *)ptr);
		break;
	case SOAP_TYPE_ns1__AcknowledgeSystemAlert:
		soap_serialize_ns1__AcknowledgeSystemAlert(soap, (const struct ns1__AcknowledgeSystemAlert *)ptr);
		break;
	case SOAP_TYPE_ns1__AcknowledgeSystemAlertResponse:
		soap_serialize_ns1__AcknowledgeSystemAlertResponse(soap, (const struct ns1__AcknowledgeSystemAlertResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__AcknowledgeApplicationAlert:
		soap_serialize_ns1__AcknowledgeApplicationAlert(soap, (const struct ns1__AcknowledgeApplicationAlert *)ptr);
		break;
	case SOAP_TYPE_ns1__AcknowledgeApplicationAlertResponse:
		soap_serialize_ns1__AcknowledgeApplicationAlertResponse(soap, (const struct ns1__AcknowledgeApplicationAlertResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__GetSystemAlerts:
		soap_serialize_ns1__GetSystemAlerts(soap, (const struct ns1__GetSystemAlerts *)ptr);
		break;
	case SOAP_TYPE_ns1__GetSystemAlertsResponse:
		soap_serialize_ns1__GetSystemAlertsResponse(soap, (const struct ns1__GetSystemAlertsResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__GetSystemAlertsByStartDate:
		soap_serialize_ns1__GetSystemAlertsByStartDate(soap, (const struct ns1__GetSystemAlertsByStartDate *)ptr);
		break;
	case SOAP_TYPE_ns1__GetSystemAlertsByStartDateResponse:
		soap_serialize_ns1__GetSystemAlertsByStartDateResponse(soap, (const struct ns1__GetSystemAlertsByStartDateResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__GetSystemAlertsFilter:
		soap_serialize_ns1__GetSystemAlertsFilter(soap, (const struct ns1__GetSystemAlertsFilter *)ptr);
		break;
	case SOAP_TYPE_ns1__GetSystemAlertsFilterResponse:
		soap_serialize_ns1__GetSystemAlertsFilterResponse(soap, (const struct ns1__GetSystemAlertsFilterResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__GetApplicationAlertsFilter:
		soap_serialize_ns1__GetApplicationAlertsFilter(soap, (const struct ns1__GetApplicationAlertsFilter *)ptr);
		break;
	case SOAP_TYPE_ns1__GetApplicationAlertsFilterResponse:
		soap_serialize_ns1__GetApplicationAlertsFilterResponse(soap, (const struct ns1__GetApplicationAlertsFilterResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__GetApplicationAlerts:
		soap_serialize_ns1__GetApplicationAlerts(soap, (const struct ns1__GetApplicationAlerts *)ptr);
		break;
	case SOAP_TYPE_ns1__GetApplicationAlertsResponse:
		soap_serialize_ns1__GetApplicationAlertsResponse(soap, (const struct ns1__GetApplicationAlertsResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__GetApplicationAlertsByStartDate:
		soap_serialize_ns1__GetApplicationAlertsByStartDate(soap, (const struct ns1__GetApplicationAlertsByStartDate *)ptr);
		break;
	case SOAP_TYPE_ns1__GetApplicationAlertsByStartDateResponse:
		soap_serialize_ns1__GetApplicationAlertsByStartDateResponse(soap, (const struct ns1__GetApplicationAlertsByStartDateResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__GetTlkpSystemAlertTypesRecord:
		soap_serialize_ns1__GetTlkpSystemAlertTypesRecord(soap, (const struct ns1__GetTlkpSystemAlertTypesRecord *)ptr);
		break;
	case SOAP_TYPE_ns1__GetTlkpSystemAlertTypesRecordResponse:
		soap_serialize_ns1__GetTlkpSystemAlertTypesRecordResponse(soap, (const struct ns1__GetTlkpSystemAlertTypesRecordResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__GetTlkpSystemAlertActionsRecord:
		soap_serialize_ns1__GetTlkpSystemAlertActionsRecord(soap, (const struct ns1__GetTlkpSystemAlertActionsRecord *)ptr);
		break;
	case SOAP_TYPE_ns1__GetTlkpSystemAlertActionsRecordResponse:
		soap_serialize_ns1__GetTlkpSystemAlertActionsRecordResponse(soap, (const struct ns1__GetTlkpSystemAlertActionsRecordResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__GetTlkpSystemAlertStatesRecord:
		soap_serialize_ns1__GetTlkpSystemAlertStatesRecord(soap, (const struct ns1__GetTlkpSystemAlertStatesRecord *)ptr);
		break;
	case SOAP_TYPE_ns1__GetTlkpSystemAlertStatesRecordResponse:
		soap_serialize_ns1__GetTlkpSystemAlertStatesRecordResponse(soap, (const struct ns1__GetTlkpSystemAlertStatesRecordResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__GetServerRecord:
		soap_serialize_ns1__GetServerRecord(soap, (const struct ns1__GetServerRecord *)ptr);
		break;
	case SOAP_TYPE_ns1__GetServerRecordResponse:
		soap_serialize_ns1__GetServerRecordResponse(soap, (const struct ns1__GetServerRecordResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__GetServerTypeRecord:
		soap_serialize_ns1__GetServerTypeRecord(soap, (const struct ns1__GetServerTypeRecord *)ptr);
		break;
	case SOAP_TYPE_ns1__GetServerTypeRecordResponse:
		soap_serialize_ns1__GetServerTypeRecordResponse(soap, (const struct ns1__GetServerTypeRecordResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__GetSiteRecord:
		soap_serialize_ns1__GetSiteRecord(soap, (const struct ns1__GetSiteRecord *)ptr);
		break;
	case SOAP_TYPE_ns1__GetSiteRecordResponse:
		soap_serialize_ns1__GetSiteRecordResponse(soap, (const struct ns1__GetSiteRecordResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__ClearApplicationAlert:
		soap_serialize_ns1__ClearApplicationAlert(soap, (const struct ns1__ClearApplicationAlert *)ptr);
		break;
	case SOAP_TYPE_ns1__ClearApplicationAlertResponse:
		soap_serialize_ns1__ClearApplicationAlertResponse(soap, (const struct ns1__ClearApplicationAlertResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__ClearSystemAlert:
		soap_serialize_ns1__ClearSystemAlert(soap, (const struct ns1__ClearSystemAlert *)ptr);
		break;
	case SOAP_TYPE_ns1__ClearSystemAlertResponse:
		soap_serialize_ns1__ClearSystemAlertResponse(soap, (const struct ns1__ClearSystemAlertResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__GetVersion:
		soap_serialize_ns1__GetVersion(soap, (const struct ns1__GetVersion *)ptr);
		break;
	case SOAP_TYPE_ns1__GetVersionResponse:
		soap_serialize_ns1__GetVersionResponse(soap, (const struct ns1__GetVersionResponse *)ptr);
		break;
	case SOAP_TYPE_PointerTons1__DCenterCordInfo:
		soap_serialize_PointerTons1__DCenterCordInfo(soap, (ns1__DCenterCordInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerToSOAP_ENC__string:
		soap_serialize_PointerToSOAP_ENC__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	}
}
#ifdef __cplusplus
}
#endif
#endif

#ifdef __cplusplus
extern "C" {
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_dupelement(struct soap *soap, const void *ptr, int type)
{(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	return NULL;
}
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_delelement(const void *ptr, int type)
{(void)ptr; (void)type; /* appease -Wall -Werror */
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__DCenterCordInfo:
		return (void*)soap_instantiate_ns1__DCenterCordInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetVersionResponse:
		return (void*)soap_instantiate_ns1__GetVersionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetVersion:
		return (void*)soap_instantiate_ns1__GetVersion(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ClearSystemAlertResponse:
		return (void*)soap_instantiate_ns1__ClearSystemAlertResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ClearSystemAlert:
		return (void*)soap_instantiate_ns1__ClearSystemAlert(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ClearApplicationAlertResponse:
		return (void*)soap_instantiate_ns1__ClearApplicationAlertResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ClearApplicationAlert:
		return (void*)soap_instantiate_ns1__ClearApplicationAlert(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetSiteRecordResponse:
		return (void*)soap_instantiate_ns1__GetSiteRecordResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetSiteRecord:
		return (void*)soap_instantiate_ns1__GetSiteRecord(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetServerTypeRecordResponse:
		return (void*)soap_instantiate_ns1__GetServerTypeRecordResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetServerTypeRecord:
		return (void*)soap_instantiate_ns1__GetServerTypeRecord(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetServerRecordResponse:
		return (void*)soap_instantiate_ns1__GetServerRecordResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetServerRecord:
		return (void*)soap_instantiate_ns1__GetServerRecord(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetTlkpSystemAlertStatesRecordResponse:
		return (void*)soap_instantiate_ns1__GetTlkpSystemAlertStatesRecordResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetTlkpSystemAlertStatesRecord:
		return (void*)soap_instantiate_ns1__GetTlkpSystemAlertStatesRecord(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetTlkpSystemAlertActionsRecordResponse:
		return (void*)soap_instantiate_ns1__GetTlkpSystemAlertActionsRecordResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetTlkpSystemAlertActionsRecord:
		return (void*)soap_instantiate_ns1__GetTlkpSystemAlertActionsRecord(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetTlkpSystemAlertTypesRecordResponse:
		return (void*)soap_instantiate_ns1__GetTlkpSystemAlertTypesRecordResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetTlkpSystemAlertTypesRecord:
		return (void*)soap_instantiate_ns1__GetTlkpSystemAlertTypesRecord(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetApplicationAlertsByStartDateResponse:
		return (void*)soap_instantiate_ns1__GetApplicationAlertsByStartDateResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetApplicationAlertsByStartDate:
		return (void*)soap_instantiate_ns1__GetApplicationAlertsByStartDate(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetApplicationAlertsResponse:
		return (void*)soap_instantiate_ns1__GetApplicationAlertsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetApplicationAlerts:
		return (void*)soap_instantiate_ns1__GetApplicationAlerts(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetApplicationAlertsFilterResponse:
		return (void*)soap_instantiate_ns1__GetApplicationAlertsFilterResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetApplicationAlertsFilter:
		return (void*)soap_instantiate_ns1__GetApplicationAlertsFilter(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetSystemAlertsFilterResponse:
		return (void*)soap_instantiate_ns1__GetSystemAlertsFilterResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetSystemAlertsFilter:
		return (void*)soap_instantiate_ns1__GetSystemAlertsFilter(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetSystemAlertsByStartDateResponse:
		return (void*)soap_instantiate_ns1__GetSystemAlertsByStartDateResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetSystemAlertsByStartDate:
		return (void*)soap_instantiate_ns1__GetSystemAlertsByStartDate(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetSystemAlertsResponse:
		return (void*)soap_instantiate_ns1__GetSystemAlertsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetSystemAlerts:
		return (void*)soap_instantiate_ns1__GetSystemAlerts(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__AcknowledgeApplicationAlertResponse:
		return (void*)soap_instantiate_ns1__AcknowledgeApplicationAlertResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__AcknowledgeApplicationAlert:
		return (void*)soap_instantiate_ns1__AcknowledgeApplicationAlert(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__AcknowledgeSystemAlertResponse:
		return (void*)soap_instantiate_ns1__AcknowledgeSystemAlertResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__AcknowledgeSystemAlert:
		return (void*)soap_instantiate_ns1__AcknowledgeSystemAlert(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__DeleteAlertActionField2Response:
		return (void*)soap_instantiate_ns1__DeleteAlertActionField2Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__DeleteAlertActionField2:
		return (void*)soap_instantiate_ns1__DeleteAlertActionField2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__DeleteAlertActionFieldResponse:
		return (void*)soap_instantiate_ns1__DeleteAlertActionFieldResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__DeleteAlertActionField:
		return (void*)soap_instantiate_ns1__DeleteAlertActionField(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__DeleteAlertActionParameter2Response:
		return (void*)soap_instantiate_ns1__DeleteAlertActionParameter2Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__DeleteAlertActionParameter2:
		return (void*)soap_instantiate_ns1__DeleteAlertActionParameter2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__DeleteAlertActionParameterResponse:
		return (void*)soap_instantiate_ns1__DeleteAlertActionParameterResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__DeleteAlertActionParameter:
		return (void*)soap_instantiate_ns1__DeleteAlertActionParameter(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__DeleteAlertScheduleByScheduleIdResponse:
		return (void*)soap_instantiate_ns1__DeleteAlertScheduleByScheduleIdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__DeleteAlertScheduleByScheduleId:
		return (void*)soap_instantiate_ns1__DeleteAlertScheduleByScheduleId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__DeleteAlertScheduleResponse:
		return (void*)soap_instantiate_ns1__DeleteAlertScheduleResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__DeleteAlertSchedule:
		return (void*)soap_instantiate_ns1__DeleteAlertSchedule(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__DeleteAlertAction2Response:
		return (void*)soap_instantiate_ns1__DeleteAlertAction2Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__DeleteAlertAction2:
		return (void*)soap_instantiate_ns1__DeleteAlertAction2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__DeleteAlertActionResponse:
		return (void*)soap_instantiate_ns1__DeleteAlertActionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__DeleteAlertAction:
		return (void*)soap_instantiate_ns1__DeleteAlertAction(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__DeleteAlertEvaluation2Response:
		return (void*)soap_instantiate_ns1__DeleteAlertEvaluation2Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__DeleteAlertEvaluation2:
		return (void*)soap_instantiate_ns1__DeleteAlertEvaluation2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__DeleteAlertEvaluationResponse:
		return (void*)soap_instantiate_ns1__DeleteAlertEvaluationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__DeleteAlertEvaluation:
		return (void*)soap_instantiate_ns1__DeleteAlertEvaluation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__DeleteAlertResponse:
		return (void*)soap_instantiate_ns1__DeleteAlertResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__DeleteAlert:
		return (void*)soap_instantiate_ns1__DeleteAlert(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetRunningCenterCordResponse:
		return (void*)soap_instantiate_ns1__GetRunningCenterCordResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetRunningCenterCord:
		return (void*)soap_instantiate_ns1__GetRunningCenterCord(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SetClientTypeResponse:
		return (void*)soap_instantiate_ns1__SetClientTypeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SetClientType:
		return (void*)soap_instantiate_ns1__SetClientType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SendServerUpdateNotificationResponse:
		return (void*)soap_instantiate_ns1__SendServerUpdateNotificationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SendServerUpdateNotification:
		return (void*)soap_instantiate_ns1__SendServerUpdateNotification(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__UnSubscribeToDocumentTypeResponse:
		return (void*)soap_instantiate_ns1__UnSubscribeToDocumentTypeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__UnSubscribeToDocumentType:
		return (void*)soap_instantiate_ns1__UnSubscribeToDocumentType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SubscribeToDocumentTypeResponse:
		return (void*)soap_instantiate_ns1__SubscribeToDocumentTypeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SubscribeToDocumentType:
		return (void*)soap_instantiate_ns1__SubscribeToDocumentType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SendNetworkDocumentResponse:
		return (void*)soap_instantiate_ns1__SendNetworkDocumentResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SendNetworkDocument:
		return (void*)soap_instantiate_ns1__SendNetworkDocument(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SendAlertResponse:
		return (void*)soap_instantiate_ns1__SendAlertResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SendAlert:
		return (void*)soap_instantiate_ns1__SendAlert(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetTlkpActionParametersRecordByParameterIdResponse:
		return (void*)soap_instantiate_ns1__GetTlkpActionParametersRecordByParameterIdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetTlkpActionParametersRecordByParameterId:
		return (void*)soap_instantiate_ns1__GetTlkpActionParametersRecordByParameterId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetTlkpActionParametersRecordResponse:
		return (void*)soap_instantiate_ns1__GetTlkpActionParametersRecordResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetTlkpActionParametersRecord:
		return (void*)soap_instantiate_ns1__GetTlkpActionParametersRecord(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetTlkpPriorityLevelRecordByPriorityLevelResponse:
		return (void*)soap_instantiate_ns1__GetTlkpPriorityLevelRecordByPriorityLevelResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetTlkpPriorityLevelRecordByPriorityLevel:
		return (void*)soap_instantiate_ns1__GetTlkpPriorityLevelRecordByPriorityLevel(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetTlkpPriorityLevelRecordResponse:
		return (void*)soap_instantiate_ns1__GetTlkpPriorityLevelRecordResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetTlkpPriorityLevelRecord:
		return (void*)soap_instantiate_ns1__GetTlkpPriorityLevelRecord(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetTlkpActionsRecordByActionResponse:
		return (void*)soap_instantiate_ns1__GetTlkpActionsRecordByActionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetTlkpActionsRecordByAction:
		return (void*)soap_instantiate_ns1__GetTlkpActionsRecordByAction(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetTlkpActionsRecordResponse:
		return (void*)soap_instantiate_ns1__GetTlkpActionsRecordResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetTlkpActionsRecord:
		return (void*)soap_instantiate_ns1__GetTlkpActionsRecord(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetTlkpDocumentFieldTypesRecordResponse:
		return (void*)soap_instantiate_ns1__GetTlkpDocumentFieldTypesRecordResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetTlkpDocumentFieldTypesRecord:
		return (void*)soap_instantiate_ns1__GetTlkpDocumentFieldTypesRecord(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetTlkpDocumentFieldsRecordResponse:
		return (void*)soap_instantiate_ns1__GetTlkpDocumentFieldsRecordResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetTlkpDocumentFieldsRecord:
		return (void*)soap_instantiate_ns1__GetTlkpDocumentFieldsRecord(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetTlkpDocumentTypesRecordByClientTypeResponse:
		return (void*)soap_instantiate_ns1__GetTlkpDocumentTypesRecordByClientTypeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetTlkpDocumentTypesRecordByClientType:
		return (void*)soap_instantiate_ns1__GetTlkpDocumentTypesRecordByClientType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetTlkpDocumentTypesRecordResponse:
		return (void*)soap_instantiate_ns1__GetTlkpDocumentTypesRecordResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetTlkpDocumentTypesRecord:
		return (void*)soap_instantiate_ns1__GetTlkpDocumentTypesRecord(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetAlertActionFieldsRecordResponse:
		return (void*)soap_instantiate_ns1__GetAlertActionFieldsRecordResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetAlertActionFieldsRecord:
		return (void*)soap_instantiate_ns1__GetAlertActionFieldsRecord(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetAlertActionParameterRecordResponse:
		return (void*)soap_instantiate_ns1__GetAlertActionParameterRecordResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetAlertActionParameterRecord:
		return (void*)soap_instantiate_ns1__GetAlertActionParameterRecord(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetAlertSchedulesRecordResponse:
		return (void*)soap_instantiate_ns1__GetAlertSchedulesRecordResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetAlertSchedulesRecord:
		return (void*)soap_instantiate_ns1__GetAlertSchedulesRecord(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetAlertActionsRecordResponse:
		return (void*)soap_instantiate_ns1__GetAlertActionsRecordResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetAlertActionsRecord:
		return (void*)soap_instantiate_ns1__GetAlertActionsRecord(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetAlertEvaluationsRecordResponse:
		return (void*)soap_instantiate_ns1__GetAlertEvaluationsRecordResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetAlertEvaluationsRecord:
		return (void*)soap_instantiate_ns1__GetAlertEvaluationsRecord(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetAlertsRecordByDocumentTypeResponse:
		return (void*)soap_instantiate_ns1__GetAlertsRecordByDocumentTypeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetAlertsRecordByDocumentType:
		return (void*)soap_instantiate_ns1__GetAlertsRecordByDocumentType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetAlertsRecordResponse:
		return (void*)soap_instantiate_ns1__GetAlertsRecordResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetAlertsRecord:
		return (void*)soap_instantiate_ns1__GetAlertsRecord(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__UpdateAlertActionFieldResponse:
		return (void*)soap_instantiate_ns1__UpdateAlertActionFieldResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__UpdateAlertActionField:
		return (void*)soap_instantiate_ns1__UpdateAlertActionField(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__InsertAlertActionFieldResponse:
		return (void*)soap_instantiate_ns1__InsertAlertActionFieldResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__InsertAlertActionField:
		return (void*)soap_instantiate_ns1__InsertAlertActionField(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__UpdateAlertActionParameterResponse:
		return (void*)soap_instantiate_ns1__UpdateAlertActionParameterResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__UpdateAlertActionParameter:
		return (void*)soap_instantiate_ns1__UpdateAlertActionParameter(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__InsertAlertActionParameterResponse:
		return (void*)soap_instantiate_ns1__InsertAlertActionParameterResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__InsertAlertActionParameter:
		return (void*)soap_instantiate_ns1__InsertAlertActionParameter(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__UpdateAlertScheduleResponse:
		return (void*)soap_instantiate_ns1__UpdateAlertScheduleResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__UpdateAlertSchedule:
		return (void*)soap_instantiate_ns1__UpdateAlertSchedule(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__InsertAlertScheduleResponse:
		return (void*)soap_instantiate_ns1__InsertAlertScheduleResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__InsertAlertSchedule:
		return (void*)soap_instantiate_ns1__InsertAlertSchedule(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__UpdateAlertActionResponse:
		return (void*)soap_instantiate_ns1__UpdateAlertActionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__UpdateAlertAction:
		return (void*)soap_instantiate_ns1__UpdateAlertAction(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__InsertAlertActionResponse:
		return (void*)soap_instantiate_ns1__InsertAlertActionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__InsertAlertAction:
		return (void*)soap_instantiate_ns1__InsertAlertAction(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__UpdatetAlertEvaluationResponse:
		return (void*)soap_instantiate_ns1__UpdatetAlertEvaluationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__UpdatetAlertEvaluation:
		return (void*)soap_instantiate_ns1__UpdatetAlertEvaluation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__InsertAlertEvaluationResponse:
		return (void*)soap_instantiate_ns1__InsertAlertEvaluationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__InsertAlertEvaluation:
		return (void*)soap_instantiate_ns1__InsertAlertEvaluation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__UpdateAlertResponse:
		return (void*)soap_instantiate_ns1__UpdateAlertResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__UpdateAlert:
		return (void*)soap_instantiate_ns1__UpdateAlert(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__InsertAlertResponse:
		return (void*)soap_instantiate_ns1__InsertAlertResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__InsertAlert:
		return (void*)soap_instantiate_ns1__InsertAlert(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetWebServiceNameResponse:
		return (void*)soap_instantiate_ns1__GetWebServiceNameResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetWebServiceName:
		return (void*)soap_instantiate_ns1__GetWebServiceName(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_SOAP_ENC__string:
		return (void*)soap_instantiate_SOAP_ENC__string(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap *soap, struct soap_clist *p)
{
	(void)soap; /* appease -Wall -Werror */
	if (!p->ptr)
		return SOAP_OK;
	switch (p->type)
	{
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_ns1__DCenterCordInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__DCenterCordInfo*>(p->ptr), ns1__DCenterCordInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__DCenterCordInfo*>(p->ptr), ns1__DCenterCordInfo);
		break;
	case SOAP_TYPE_ns1__GetVersionResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__GetVersionResponse*>(p->ptr), struct ns1__GetVersionResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__GetVersionResponse*>(p->ptr), struct ns1__GetVersionResponse);
		break;
	case SOAP_TYPE_ns1__GetVersion:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__GetVersion*>(p->ptr), struct ns1__GetVersion);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__GetVersion*>(p->ptr), struct ns1__GetVersion);
		break;
	case SOAP_TYPE_ns1__ClearSystemAlertResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__ClearSystemAlertResponse*>(p->ptr), struct ns1__ClearSystemAlertResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__ClearSystemAlertResponse*>(p->ptr), struct ns1__ClearSystemAlertResponse);
		break;
	case SOAP_TYPE_ns1__ClearSystemAlert:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__ClearSystemAlert*>(p->ptr), struct ns1__ClearSystemAlert);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__ClearSystemAlert*>(p->ptr), struct ns1__ClearSystemAlert);
		break;
	case SOAP_TYPE_ns1__ClearApplicationAlertResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__ClearApplicationAlertResponse*>(p->ptr), struct ns1__ClearApplicationAlertResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__ClearApplicationAlertResponse*>(p->ptr), struct ns1__ClearApplicationAlertResponse);
		break;
	case SOAP_TYPE_ns1__ClearApplicationAlert:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__ClearApplicationAlert*>(p->ptr), struct ns1__ClearApplicationAlert);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__ClearApplicationAlert*>(p->ptr), struct ns1__ClearApplicationAlert);
		break;
	case SOAP_TYPE_ns1__GetSiteRecordResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__GetSiteRecordResponse*>(p->ptr), struct ns1__GetSiteRecordResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__GetSiteRecordResponse*>(p->ptr), struct ns1__GetSiteRecordResponse);
		break;
	case SOAP_TYPE_ns1__GetSiteRecord:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__GetSiteRecord*>(p->ptr), struct ns1__GetSiteRecord);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__GetSiteRecord*>(p->ptr), struct ns1__GetSiteRecord);
		break;
	case SOAP_TYPE_ns1__GetServerTypeRecordResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__GetServerTypeRecordResponse*>(p->ptr), struct ns1__GetServerTypeRecordResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__GetServerTypeRecordResponse*>(p->ptr), struct ns1__GetServerTypeRecordResponse);
		break;
	case SOAP_TYPE_ns1__GetServerTypeRecord:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__GetServerTypeRecord*>(p->ptr), struct ns1__GetServerTypeRecord);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__GetServerTypeRecord*>(p->ptr), struct ns1__GetServerTypeRecord);
		break;
	case SOAP_TYPE_ns1__GetServerRecordResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__GetServerRecordResponse*>(p->ptr), struct ns1__GetServerRecordResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__GetServerRecordResponse*>(p->ptr), struct ns1__GetServerRecordResponse);
		break;
	case SOAP_TYPE_ns1__GetServerRecord:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__GetServerRecord*>(p->ptr), struct ns1__GetServerRecord);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__GetServerRecord*>(p->ptr), struct ns1__GetServerRecord);
		break;
	case SOAP_TYPE_ns1__GetTlkpSystemAlertStatesRecordResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__GetTlkpSystemAlertStatesRecordResponse*>(p->ptr), struct ns1__GetTlkpSystemAlertStatesRecordResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__GetTlkpSystemAlertStatesRecordResponse*>(p->ptr), struct ns1__GetTlkpSystemAlertStatesRecordResponse);
		break;
	case SOAP_TYPE_ns1__GetTlkpSystemAlertStatesRecord:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__GetTlkpSystemAlertStatesRecord*>(p->ptr), struct ns1__GetTlkpSystemAlertStatesRecord);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__GetTlkpSystemAlertStatesRecord*>(p->ptr), struct ns1__GetTlkpSystemAlertStatesRecord);
		break;
	case SOAP_TYPE_ns1__GetTlkpSystemAlertActionsRecordResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__GetTlkpSystemAlertActionsRecordResponse*>(p->ptr), struct ns1__GetTlkpSystemAlertActionsRecordResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__GetTlkpSystemAlertActionsRecordResponse*>(p->ptr), struct ns1__GetTlkpSystemAlertActionsRecordResponse);
		break;
	case SOAP_TYPE_ns1__GetTlkpSystemAlertActionsRecord:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__GetTlkpSystemAlertActionsRecord*>(p->ptr), struct ns1__GetTlkpSystemAlertActionsRecord);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__GetTlkpSystemAlertActionsRecord*>(p->ptr), struct ns1__GetTlkpSystemAlertActionsRecord);
		break;
	case SOAP_TYPE_ns1__GetTlkpSystemAlertTypesRecordResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__GetTlkpSystemAlertTypesRecordResponse*>(p->ptr), struct ns1__GetTlkpSystemAlertTypesRecordResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__GetTlkpSystemAlertTypesRecordResponse*>(p->ptr), struct ns1__GetTlkpSystemAlertTypesRecordResponse);
		break;
	case SOAP_TYPE_ns1__GetTlkpSystemAlertTypesRecord:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__GetTlkpSystemAlertTypesRecord*>(p->ptr), struct ns1__GetTlkpSystemAlertTypesRecord);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__GetTlkpSystemAlertTypesRecord*>(p->ptr), struct ns1__GetTlkpSystemAlertTypesRecord);
		break;
	case SOAP_TYPE_ns1__GetApplicationAlertsByStartDateResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__GetApplicationAlertsByStartDateResponse*>(p->ptr), struct ns1__GetApplicationAlertsByStartDateResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__GetApplicationAlertsByStartDateResponse*>(p->ptr), struct ns1__GetApplicationAlertsByStartDateResponse);
		break;
	case SOAP_TYPE_ns1__GetApplicationAlertsByStartDate:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__GetApplicationAlertsByStartDate*>(p->ptr), struct ns1__GetApplicationAlertsByStartDate);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__GetApplicationAlertsByStartDate*>(p->ptr), struct ns1__GetApplicationAlertsByStartDate);
		break;
	case SOAP_TYPE_ns1__GetApplicationAlertsResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__GetApplicationAlertsResponse*>(p->ptr), struct ns1__GetApplicationAlertsResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__GetApplicationAlertsResponse*>(p->ptr), struct ns1__GetApplicationAlertsResponse);
		break;
	case SOAP_TYPE_ns1__GetApplicationAlerts:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__GetApplicationAlerts*>(p->ptr), struct ns1__GetApplicationAlerts);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__GetApplicationAlerts*>(p->ptr), struct ns1__GetApplicationAlerts);
		break;
	case SOAP_TYPE_ns1__GetApplicationAlertsFilterResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__GetApplicationAlertsFilterResponse*>(p->ptr), struct ns1__GetApplicationAlertsFilterResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__GetApplicationAlertsFilterResponse*>(p->ptr), struct ns1__GetApplicationAlertsFilterResponse);
		break;
	case SOAP_TYPE_ns1__GetApplicationAlertsFilter:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__GetApplicationAlertsFilter*>(p->ptr), struct ns1__GetApplicationAlertsFilter);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__GetApplicationAlertsFilter*>(p->ptr), struct ns1__GetApplicationAlertsFilter);
		break;
	case SOAP_TYPE_ns1__GetSystemAlertsFilterResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__GetSystemAlertsFilterResponse*>(p->ptr), struct ns1__GetSystemAlertsFilterResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__GetSystemAlertsFilterResponse*>(p->ptr), struct ns1__GetSystemAlertsFilterResponse);
		break;
	case SOAP_TYPE_ns1__GetSystemAlertsFilter:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__GetSystemAlertsFilter*>(p->ptr), struct ns1__GetSystemAlertsFilter);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__GetSystemAlertsFilter*>(p->ptr), struct ns1__GetSystemAlertsFilter);
		break;
	case SOAP_TYPE_ns1__GetSystemAlertsByStartDateResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__GetSystemAlertsByStartDateResponse*>(p->ptr), struct ns1__GetSystemAlertsByStartDateResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__GetSystemAlertsByStartDateResponse*>(p->ptr), struct ns1__GetSystemAlertsByStartDateResponse);
		break;
	case SOAP_TYPE_ns1__GetSystemAlertsByStartDate:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__GetSystemAlertsByStartDate*>(p->ptr), struct ns1__GetSystemAlertsByStartDate);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__GetSystemAlertsByStartDate*>(p->ptr), struct ns1__GetSystemAlertsByStartDate);
		break;
	case SOAP_TYPE_ns1__GetSystemAlertsResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__GetSystemAlertsResponse*>(p->ptr), struct ns1__GetSystemAlertsResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__GetSystemAlertsResponse*>(p->ptr), struct ns1__GetSystemAlertsResponse);
		break;
	case SOAP_TYPE_ns1__GetSystemAlerts:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__GetSystemAlerts*>(p->ptr), struct ns1__GetSystemAlerts);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__GetSystemAlerts*>(p->ptr), struct ns1__GetSystemAlerts);
		break;
	case SOAP_TYPE_ns1__AcknowledgeApplicationAlertResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__AcknowledgeApplicationAlertResponse*>(p->ptr), struct ns1__AcknowledgeApplicationAlertResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__AcknowledgeApplicationAlertResponse*>(p->ptr), struct ns1__AcknowledgeApplicationAlertResponse);
		break;
	case SOAP_TYPE_ns1__AcknowledgeApplicationAlert:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__AcknowledgeApplicationAlert*>(p->ptr), struct ns1__AcknowledgeApplicationAlert);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__AcknowledgeApplicationAlert*>(p->ptr), struct ns1__AcknowledgeApplicationAlert);
		break;
	case SOAP_TYPE_ns1__AcknowledgeSystemAlertResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__AcknowledgeSystemAlertResponse*>(p->ptr), struct ns1__AcknowledgeSystemAlertResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__AcknowledgeSystemAlertResponse*>(p->ptr), struct ns1__AcknowledgeSystemAlertResponse);
		break;
	case SOAP_TYPE_ns1__AcknowledgeSystemAlert:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__AcknowledgeSystemAlert*>(p->ptr), struct ns1__AcknowledgeSystemAlert);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__AcknowledgeSystemAlert*>(p->ptr), struct ns1__AcknowledgeSystemAlert);
		break;
	case SOAP_TYPE_ns1__DeleteAlertActionField2Response:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__DeleteAlertActionField2Response*>(p->ptr), struct ns1__DeleteAlertActionField2Response);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__DeleteAlertActionField2Response*>(p->ptr), struct ns1__DeleteAlertActionField2Response);
		break;
	case SOAP_TYPE_ns1__DeleteAlertActionField2:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__DeleteAlertActionField2*>(p->ptr), struct ns1__DeleteAlertActionField2);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__DeleteAlertActionField2*>(p->ptr), struct ns1__DeleteAlertActionField2);
		break;
	case SOAP_TYPE_ns1__DeleteAlertActionFieldResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__DeleteAlertActionFieldResponse*>(p->ptr), struct ns1__DeleteAlertActionFieldResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__DeleteAlertActionFieldResponse*>(p->ptr), struct ns1__DeleteAlertActionFieldResponse);
		break;
	case SOAP_TYPE_ns1__DeleteAlertActionField:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__DeleteAlertActionField*>(p->ptr), struct ns1__DeleteAlertActionField);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__DeleteAlertActionField*>(p->ptr), struct ns1__DeleteAlertActionField);
		break;
	case SOAP_TYPE_ns1__DeleteAlertActionParameter2Response:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__DeleteAlertActionParameter2Response*>(p->ptr), struct ns1__DeleteAlertActionParameter2Response);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__DeleteAlertActionParameter2Response*>(p->ptr), struct ns1__DeleteAlertActionParameter2Response);
		break;
	case SOAP_TYPE_ns1__DeleteAlertActionParameter2:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__DeleteAlertActionParameter2*>(p->ptr), struct ns1__DeleteAlertActionParameter2);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__DeleteAlertActionParameter2*>(p->ptr), struct ns1__DeleteAlertActionParameter2);
		break;
	case SOAP_TYPE_ns1__DeleteAlertActionParameterResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__DeleteAlertActionParameterResponse*>(p->ptr), struct ns1__DeleteAlertActionParameterResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__DeleteAlertActionParameterResponse*>(p->ptr), struct ns1__DeleteAlertActionParameterResponse);
		break;
	case SOAP_TYPE_ns1__DeleteAlertActionParameter:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__DeleteAlertActionParameter*>(p->ptr), struct ns1__DeleteAlertActionParameter);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__DeleteAlertActionParameter*>(p->ptr), struct ns1__DeleteAlertActionParameter);
		break;
	case SOAP_TYPE_ns1__DeleteAlertScheduleByScheduleIdResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__DeleteAlertScheduleByScheduleIdResponse*>(p->ptr), struct ns1__DeleteAlertScheduleByScheduleIdResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__DeleteAlertScheduleByScheduleIdResponse*>(p->ptr), struct ns1__DeleteAlertScheduleByScheduleIdResponse);
		break;
	case SOAP_TYPE_ns1__DeleteAlertScheduleByScheduleId:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__DeleteAlertScheduleByScheduleId*>(p->ptr), struct ns1__DeleteAlertScheduleByScheduleId);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__DeleteAlertScheduleByScheduleId*>(p->ptr), struct ns1__DeleteAlertScheduleByScheduleId);
		break;
	case SOAP_TYPE_ns1__DeleteAlertScheduleResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__DeleteAlertScheduleResponse*>(p->ptr), struct ns1__DeleteAlertScheduleResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__DeleteAlertScheduleResponse*>(p->ptr), struct ns1__DeleteAlertScheduleResponse);
		break;
	case SOAP_TYPE_ns1__DeleteAlertSchedule:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__DeleteAlertSchedule*>(p->ptr), struct ns1__DeleteAlertSchedule);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__DeleteAlertSchedule*>(p->ptr), struct ns1__DeleteAlertSchedule);
		break;
	case SOAP_TYPE_ns1__DeleteAlertAction2Response:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__DeleteAlertAction2Response*>(p->ptr), struct ns1__DeleteAlertAction2Response);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__DeleteAlertAction2Response*>(p->ptr), struct ns1__DeleteAlertAction2Response);
		break;
	case SOAP_TYPE_ns1__DeleteAlertAction2:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__DeleteAlertAction2*>(p->ptr), struct ns1__DeleteAlertAction2);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__DeleteAlertAction2*>(p->ptr), struct ns1__DeleteAlertAction2);
		break;
	case SOAP_TYPE_ns1__DeleteAlertActionResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__DeleteAlertActionResponse*>(p->ptr), struct ns1__DeleteAlertActionResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__DeleteAlertActionResponse*>(p->ptr), struct ns1__DeleteAlertActionResponse);
		break;
	case SOAP_TYPE_ns1__DeleteAlertAction:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__DeleteAlertAction*>(p->ptr), struct ns1__DeleteAlertAction);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__DeleteAlertAction*>(p->ptr), struct ns1__DeleteAlertAction);
		break;
	case SOAP_TYPE_ns1__DeleteAlertEvaluation2Response:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__DeleteAlertEvaluation2Response*>(p->ptr), struct ns1__DeleteAlertEvaluation2Response);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__DeleteAlertEvaluation2Response*>(p->ptr), struct ns1__DeleteAlertEvaluation2Response);
		break;
	case SOAP_TYPE_ns1__DeleteAlertEvaluation2:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__DeleteAlertEvaluation2*>(p->ptr), struct ns1__DeleteAlertEvaluation2);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__DeleteAlertEvaluation2*>(p->ptr), struct ns1__DeleteAlertEvaluation2);
		break;
	case SOAP_TYPE_ns1__DeleteAlertEvaluationResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__DeleteAlertEvaluationResponse*>(p->ptr), struct ns1__DeleteAlertEvaluationResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__DeleteAlertEvaluationResponse*>(p->ptr), struct ns1__DeleteAlertEvaluationResponse);
		break;
	case SOAP_TYPE_ns1__DeleteAlertEvaluation:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__DeleteAlertEvaluation*>(p->ptr), struct ns1__DeleteAlertEvaluation);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__DeleteAlertEvaluation*>(p->ptr), struct ns1__DeleteAlertEvaluation);
		break;
	case SOAP_TYPE_ns1__DeleteAlertResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__DeleteAlertResponse*>(p->ptr), struct ns1__DeleteAlertResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__DeleteAlertResponse*>(p->ptr), struct ns1__DeleteAlertResponse);
		break;
	case SOAP_TYPE_ns1__DeleteAlert:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__DeleteAlert*>(p->ptr), struct ns1__DeleteAlert);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__DeleteAlert*>(p->ptr), struct ns1__DeleteAlert);
		break;
	case SOAP_TYPE_ns1__GetRunningCenterCordResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__GetRunningCenterCordResponse*>(p->ptr), struct ns1__GetRunningCenterCordResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__GetRunningCenterCordResponse*>(p->ptr), struct ns1__GetRunningCenterCordResponse);
		break;
	case SOAP_TYPE_ns1__GetRunningCenterCord:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__GetRunningCenterCord*>(p->ptr), struct ns1__GetRunningCenterCord);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__GetRunningCenterCord*>(p->ptr), struct ns1__GetRunningCenterCord);
		break;
	case SOAP_TYPE_ns1__SetClientTypeResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__SetClientTypeResponse*>(p->ptr), struct ns1__SetClientTypeResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__SetClientTypeResponse*>(p->ptr), struct ns1__SetClientTypeResponse);
		break;
	case SOAP_TYPE_ns1__SetClientType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__SetClientType*>(p->ptr), struct ns1__SetClientType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__SetClientType*>(p->ptr), struct ns1__SetClientType);
		break;
	case SOAP_TYPE_ns1__SendServerUpdateNotificationResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__SendServerUpdateNotificationResponse*>(p->ptr), struct ns1__SendServerUpdateNotificationResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__SendServerUpdateNotificationResponse*>(p->ptr), struct ns1__SendServerUpdateNotificationResponse);
		break;
	case SOAP_TYPE_ns1__SendServerUpdateNotification:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__SendServerUpdateNotification*>(p->ptr), struct ns1__SendServerUpdateNotification);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__SendServerUpdateNotification*>(p->ptr), struct ns1__SendServerUpdateNotification);
		break;
	case SOAP_TYPE_ns1__UnSubscribeToDocumentTypeResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__UnSubscribeToDocumentTypeResponse*>(p->ptr), struct ns1__UnSubscribeToDocumentTypeResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__UnSubscribeToDocumentTypeResponse*>(p->ptr), struct ns1__UnSubscribeToDocumentTypeResponse);
		break;
	case SOAP_TYPE_ns1__UnSubscribeToDocumentType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__UnSubscribeToDocumentType*>(p->ptr), struct ns1__UnSubscribeToDocumentType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__UnSubscribeToDocumentType*>(p->ptr), struct ns1__UnSubscribeToDocumentType);
		break;
	case SOAP_TYPE_ns1__SubscribeToDocumentTypeResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__SubscribeToDocumentTypeResponse*>(p->ptr), struct ns1__SubscribeToDocumentTypeResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__SubscribeToDocumentTypeResponse*>(p->ptr), struct ns1__SubscribeToDocumentTypeResponse);
		break;
	case SOAP_TYPE_ns1__SubscribeToDocumentType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__SubscribeToDocumentType*>(p->ptr), struct ns1__SubscribeToDocumentType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__SubscribeToDocumentType*>(p->ptr), struct ns1__SubscribeToDocumentType);
		break;
	case SOAP_TYPE_ns1__SendNetworkDocumentResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__SendNetworkDocumentResponse*>(p->ptr), struct ns1__SendNetworkDocumentResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__SendNetworkDocumentResponse*>(p->ptr), struct ns1__SendNetworkDocumentResponse);
		break;
	case SOAP_TYPE_ns1__SendNetworkDocument:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__SendNetworkDocument*>(p->ptr), struct ns1__SendNetworkDocument);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__SendNetworkDocument*>(p->ptr), struct ns1__SendNetworkDocument);
		break;
	case SOAP_TYPE_ns1__SendAlertResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__SendAlertResponse*>(p->ptr), struct ns1__SendAlertResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__SendAlertResponse*>(p->ptr), struct ns1__SendAlertResponse);
		break;
	case SOAP_TYPE_ns1__SendAlert:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__SendAlert*>(p->ptr), struct ns1__SendAlert);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__SendAlert*>(p->ptr), struct ns1__SendAlert);
		break;
	case SOAP_TYPE_ns1__GetTlkpActionParametersRecordByParameterIdResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__GetTlkpActionParametersRecordByParameterIdResponse*>(p->ptr), struct ns1__GetTlkpActionParametersRecordByParameterIdResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__GetTlkpActionParametersRecordByParameterIdResponse*>(p->ptr), struct ns1__GetTlkpActionParametersRecordByParameterIdResponse);
		break;
	case SOAP_TYPE_ns1__GetTlkpActionParametersRecordByParameterId:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__GetTlkpActionParametersRecordByParameterId*>(p->ptr), struct ns1__GetTlkpActionParametersRecordByParameterId);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__GetTlkpActionParametersRecordByParameterId*>(p->ptr), struct ns1__GetTlkpActionParametersRecordByParameterId);
		break;
	case SOAP_TYPE_ns1__GetTlkpActionParametersRecordResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__GetTlkpActionParametersRecordResponse*>(p->ptr), struct ns1__GetTlkpActionParametersRecordResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__GetTlkpActionParametersRecordResponse*>(p->ptr), struct ns1__GetTlkpActionParametersRecordResponse);
		break;
	case SOAP_TYPE_ns1__GetTlkpActionParametersRecord:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__GetTlkpActionParametersRecord*>(p->ptr), struct ns1__GetTlkpActionParametersRecord);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__GetTlkpActionParametersRecord*>(p->ptr), struct ns1__GetTlkpActionParametersRecord);
		break;
	case SOAP_TYPE_ns1__GetTlkpPriorityLevelRecordByPriorityLevelResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__GetTlkpPriorityLevelRecordByPriorityLevelResponse*>(p->ptr), struct ns1__GetTlkpPriorityLevelRecordByPriorityLevelResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__GetTlkpPriorityLevelRecordByPriorityLevelResponse*>(p->ptr), struct ns1__GetTlkpPriorityLevelRecordByPriorityLevelResponse);
		break;
	case SOAP_TYPE_ns1__GetTlkpPriorityLevelRecordByPriorityLevel:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__GetTlkpPriorityLevelRecordByPriorityLevel*>(p->ptr), struct ns1__GetTlkpPriorityLevelRecordByPriorityLevel);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__GetTlkpPriorityLevelRecordByPriorityLevel*>(p->ptr), struct ns1__GetTlkpPriorityLevelRecordByPriorityLevel);
		break;
	case SOAP_TYPE_ns1__GetTlkpPriorityLevelRecordResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__GetTlkpPriorityLevelRecordResponse*>(p->ptr), struct ns1__GetTlkpPriorityLevelRecordResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__GetTlkpPriorityLevelRecordResponse*>(p->ptr), struct ns1__GetTlkpPriorityLevelRecordResponse);
		break;
	case SOAP_TYPE_ns1__GetTlkpPriorityLevelRecord:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__GetTlkpPriorityLevelRecord*>(p->ptr), struct ns1__GetTlkpPriorityLevelRecord);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__GetTlkpPriorityLevelRecord*>(p->ptr), struct ns1__GetTlkpPriorityLevelRecord);
		break;
	case SOAP_TYPE_ns1__GetTlkpActionsRecordByActionResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__GetTlkpActionsRecordByActionResponse*>(p->ptr), struct ns1__GetTlkpActionsRecordByActionResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__GetTlkpActionsRecordByActionResponse*>(p->ptr), struct ns1__GetTlkpActionsRecordByActionResponse);
		break;
	case SOAP_TYPE_ns1__GetTlkpActionsRecordByAction:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__GetTlkpActionsRecordByAction*>(p->ptr), struct ns1__GetTlkpActionsRecordByAction);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__GetTlkpActionsRecordByAction*>(p->ptr), struct ns1__GetTlkpActionsRecordByAction);
		break;
	case SOAP_TYPE_ns1__GetTlkpActionsRecordResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__GetTlkpActionsRecordResponse*>(p->ptr), struct ns1__GetTlkpActionsRecordResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__GetTlkpActionsRecordResponse*>(p->ptr), struct ns1__GetTlkpActionsRecordResponse);
		break;
	case SOAP_TYPE_ns1__GetTlkpActionsRecord:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__GetTlkpActionsRecord*>(p->ptr), struct ns1__GetTlkpActionsRecord);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__GetTlkpActionsRecord*>(p->ptr), struct ns1__GetTlkpActionsRecord);
		break;
	case SOAP_TYPE_ns1__GetTlkpDocumentFieldTypesRecordResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__GetTlkpDocumentFieldTypesRecordResponse*>(p->ptr), struct ns1__GetTlkpDocumentFieldTypesRecordResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__GetTlkpDocumentFieldTypesRecordResponse*>(p->ptr), struct ns1__GetTlkpDocumentFieldTypesRecordResponse);
		break;
	case SOAP_TYPE_ns1__GetTlkpDocumentFieldTypesRecord:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__GetTlkpDocumentFieldTypesRecord*>(p->ptr), struct ns1__GetTlkpDocumentFieldTypesRecord);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__GetTlkpDocumentFieldTypesRecord*>(p->ptr), struct ns1__GetTlkpDocumentFieldTypesRecord);
		break;
	case SOAP_TYPE_ns1__GetTlkpDocumentFieldsRecordResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__GetTlkpDocumentFieldsRecordResponse*>(p->ptr), struct ns1__GetTlkpDocumentFieldsRecordResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__GetTlkpDocumentFieldsRecordResponse*>(p->ptr), struct ns1__GetTlkpDocumentFieldsRecordResponse);
		break;
	case SOAP_TYPE_ns1__GetTlkpDocumentFieldsRecord:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__GetTlkpDocumentFieldsRecord*>(p->ptr), struct ns1__GetTlkpDocumentFieldsRecord);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__GetTlkpDocumentFieldsRecord*>(p->ptr), struct ns1__GetTlkpDocumentFieldsRecord);
		break;
	case SOAP_TYPE_ns1__GetTlkpDocumentTypesRecordByClientTypeResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__GetTlkpDocumentTypesRecordByClientTypeResponse*>(p->ptr), struct ns1__GetTlkpDocumentTypesRecordByClientTypeResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__GetTlkpDocumentTypesRecordByClientTypeResponse*>(p->ptr), struct ns1__GetTlkpDocumentTypesRecordByClientTypeResponse);
		break;
	case SOAP_TYPE_ns1__GetTlkpDocumentTypesRecordByClientType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__GetTlkpDocumentTypesRecordByClientType*>(p->ptr), struct ns1__GetTlkpDocumentTypesRecordByClientType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__GetTlkpDocumentTypesRecordByClientType*>(p->ptr), struct ns1__GetTlkpDocumentTypesRecordByClientType);
		break;
	case SOAP_TYPE_ns1__GetTlkpDocumentTypesRecordResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__GetTlkpDocumentTypesRecordResponse*>(p->ptr), struct ns1__GetTlkpDocumentTypesRecordResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__GetTlkpDocumentTypesRecordResponse*>(p->ptr), struct ns1__GetTlkpDocumentTypesRecordResponse);
		break;
	case SOAP_TYPE_ns1__GetTlkpDocumentTypesRecord:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__GetTlkpDocumentTypesRecord*>(p->ptr), struct ns1__GetTlkpDocumentTypesRecord);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__GetTlkpDocumentTypesRecord*>(p->ptr), struct ns1__GetTlkpDocumentTypesRecord);
		break;
	case SOAP_TYPE_ns1__GetAlertActionFieldsRecordResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__GetAlertActionFieldsRecordResponse*>(p->ptr), struct ns1__GetAlertActionFieldsRecordResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__GetAlertActionFieldsRecordResponse*>(p->ptr), struct ns1__GetAlertActionFieldsRecordResponse);
		break;
	case SOAP_TYPE_ns1__GetAlertActionFieldsRecord:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__GetAlertActionFieldsRecord*>(p->ptr), struct ns1__GetAlertActionFieldsRecord);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__GetAlertActionFieldsRecord*>(p->ptr), struct ns1__GetAlertActionFieldsRecord);
		break;
	case SOAP_TYPE_ns1__GetAlertActionParameterRecordResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__GetAlertActionParameterRecordResponse*>(p->ptr), struct ns1__GetAlertActionParameterRecordResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__GetAlertActionParameterRecordResponse*>(p->ptr), struct ns1__GetAlertActionParameterRecordResponse);
		break;
	case SOAP_TYPE_ns1__GetAlertActionParameterRecord:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__GetAlertActionParameterRecord*>(p->ptr), struct ns1__GetAlertActionParameterRecord);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__GetAlertActionParameterRecord*>(p->ptr), struct ns1__GetAlertActionParameterRecord);
		break;
	case SOAP_TYPE_ns1__GetAlertSchedulesRecordResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__GetAlertSchedulesRecordResponse*>(p->ptr), struct ns1__GetAlertSchedulesRecordResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__GetAlertSchedulesRecordResponse*>(p->ptr), struct ns1__GetAlertSchedulesRecordResponse);
		break;
	case SOAP_TYPE_ns1__GetAlertSchedulesRecord:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__GetAlertSchedulesRecord*>(p->ptr), struct ns1__GetAlertSchedulesRecord);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__GetAlertSchedulesRecord*>(p->ptr), struct ns1__GetAlertSchedulesRecord);
		break;
	case SOAP_TYPE_ns1__GetAlertActionsRecordResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__GetAlertActionsRecordResponse*>(p->ptr), struct ns1__GetAlertActionsRecordResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__GetAlertActionsRecordResponse*>(p->ptr), struct ns1__GetAlertActionsRecordResponse);
		break;
	case SOAP_TYPE_ns1__GetAlertActionsRecord:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__GetAlertActionsRecord*>(p->ptr), struct ns1__GetAlertActionsRecord);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__GetAlertActionsRecord*>(p->ptr), struct ns1__GetAlertActionsRecord);
		break;
	case SOAP_TYPE_ns1__GetAlertEvaluationsRecordResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__GetAlertEvaluationsRecordResponse*>(p->ptr), struct ns1__GetAlertEvaluationsRecordResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__GetAlertEvaluationsRecordResponse*>(p->ptr), struct ns1__GetAlertEvaluationsRecordResponse);
		break;
	case SOAP_TYPE_ns1__GetAlertEvaluationsRecord:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__GetAlertEvaluationsRecord*>(p->ptr), struct ns1__GetAlertEvaluationsRecord);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__GetAlertEvaluationsRecord*>(p->ptr), struct ns1__GetAlertEvaluationsRecord);
		break;
	case SOAP_TYPE_ns1__GetAlertsRecordByDocumentTypeResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__GetAlertsRecordByDocumentTypeResponse*>(p->ptr), struct ns1__GetAlertsRecordByDocumentTypeResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__GetAlertsRecordByDocumentTypeResponse*>(p->ptr), struct ns1__GetAlertsRecordByDocumentTypeResponse);
		break;
	case SOAP_TYPE_ns1__GetAlertsRecordByDocumentType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__GetAlertsRecordByDocumentType*>(p->ptr), struct ns1__GetAlertsRecordByDocumentType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__GetAlertsRecordByDocumentType*>(p->ptr), struct ns1__GetAlertsRecordByDocumentType);
		break;
	case SOAP_TYPE_ns1__GetAlertsRecordResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__GetAlertsRecordResponse*>(p->ptr), struct ns1__GetAlertsRecordResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__GetAlertsRecordResponse*>(p->ptr), struct ns1__GetAlertsRecordResponse);
		break;
	case SOAP_TYPE_ns1__GetAlertsRecord:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__GetAlertsRecord*>(p->ptr), struct ns1__GetAlertsRecord);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__GetAlertsRecord*>(p->ptr), struct ns1__GetAlertsRecord);
		break;
	case SOAP_TYPE_ns1__UpdateAlertActionFieldResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__UpdateAlertActionFieldResponse*>(p->ptr), struct ns1__UpdateAlertActionFieldResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__UpdateAlertActionFieldResponse*>(p->ptr), struct ns1__UpdateAlertActionFieldResponse);
		break;
	case SOAP_TYPE_ns1__UpdateAlertActionField:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__UpdateAlertActionField*>(p->ptr), struct ns1__UpdateAlertActionField);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__UpdateAlertActionField*>(p->ptr), struct ns1__UpdateAlertActionField);
		break;
	case SOAP_TYPE_ns1__InsertAlertActionFieldResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__InsertAlertActionFieldResponse*>(p->ptr), struct ns1__InsertAlertActionFieldResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__InsertAlertActionFieldResponse*>(p->ptr), struct ns1__InsertAlertActionFieldResponse);
		break;
	case SOAP_TYPE_ns1__InsertAlertActionField:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__InsertAlertActionField*>(p->ptr), struct ns1__InsertAlertActionField);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__InsertAlertActionField*>(p->ptr), struct ns1__InsertAlertActionField);
		break;
	case SOAP_TYPE_ns1__UpdateAlertActionParameterResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__UpdateAlertActionParameterResponse*>(p->ptr), struct ns1__UpdateAlertActionParameterResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__UpdateAlertActionParameterResponse*>(p->ptr), struct ns1__UpdateAlertActionParameterResponse);
		break;
	case SOAP_TYPE_ns1__UpdateAlertActionParameter:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__UpdateAlertActionParameter*>(p->ptr), struct ns1__UpdateAlertActionParameter);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__UpdateAlertActionParameter*>(p->ptr), struct ns1__UpdateAlertActionParameter);
		break;
	case SOAP_TYPE_ns1__InsertAlertActionParameterResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__InsertAlertActionParameterResponse*>(p->ptr), struct ns1__InsertAlertActionParameterResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__InsertAlertActionParameterResponse*>(p->ptr), struct ns1__InsertAlertActionParameterResponse);
		break;
	case SOAP_TYPE_ns1__InsertAlertActionParameter:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__InsertAlertActionParameter*>(p->ptr), struct ns1__InsertAlertActionParameter);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__InsertAlertActionParameter*>(p->ptr), struct ns1__InsertAlertActionParameter);
		break;
	case SOAP_TYPE_ns1__UpdateAlertScheduleResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__UpdateAlertScheduleResponse*>(p->ptr), struct ns1__UpdateAlertScheduleResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__UpdateAlertScheduleResponse*>(p->ptr), struct ns1__UpdateAlertScheduleResponse);
		break;
	case SOAP_TYPE_ns1__UpdateAlertSchedule:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__UpdateAlertSchedule*>(p->ptr), struct ns1__UpdateAlertSchedule);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__UpdateAlertSchedule*>(p->ptr), struct ns1__UpdateAlertSchedule);
		break;
	case SOAP_TYPE_ns1__InsertAlertScheduleResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__InsertAlertScheduleResponse*>(p->ptr), struct ns1__InsertAlertScheduleResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__InsertAlertScheduleResponse*>(p->ptr), struct ns1__InsertAlertScheduleResponse);
		break;
	case SOAP_TYPE_ns1__InsertAlertSchedule:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__InsertAlertSchedule*>(p->ptr), struct ns1__InsertAlertSchedule);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__InsertAlertSchedule*>(p->ptr), struct ns1__InsertAlertSchedule);
		break;
	case SOAP_TYPE_ns1__UpdateAlertActionResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__UpdateAlertActionResponse*>(p->ptr), struct ns1__UpdateAlertActionResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__UpdateAlertActionResponse*>(p->ptr), struct ns1__UpdateAlertActionResponse);
		break;
	case SOAP_TYPE_ns1__UpdateAlertAction:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__UpdateAlertAction*>(p->ptr), struct ns1__UpdateAlertAction);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__UpdateAlertAction*>(p->ptr), struct ns1__UpdateAlertAction);
		break;
	case SOAP_TYPE_ns1__InsertAlertActionResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__InsertAlertActionResponse*>(p->ptr), struct ns1__InsertAlertActionResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__InsertAlertActionResponse*>(p->ptr), struct ns1__InsertAlertActionResponse);
		break;
	case SOAP_TYPE_ns1__InsertAlertAction:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__InsertAlertAction*>(p->ptr), struct ns1__InsertAlertAction);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__InsertAlertAction*>(p->ptr), struct ns1__InsertAlertAction);
		break;
	case SOAP_TYPE_ns1__UpdatetAlertEvaluationResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__UpdatetAlertEvaluationResponse*>(p->ptr), struct ns1__UpdatetAlertEvaluationResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__UpdatetAlertEvaluationResponse*>(p->ptr), struct ns1__UpdatetAlertEvaluationResponse);
		break;
	case SOAP_TYPE_ns1__UpdatetAlertEvaluation:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__UpdatetAlertEvaluation*>(p->ptr), struct ns1__UpdatetAlertEvaluation);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__UpdatetAlertEvaluation*>(p->ptr), struct ns1__UpdatetAlertEvaluation);
		break;
	case SOAP_TYPE_ns1__InsertAlertEvaluationResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__InsertAlertEvaluationResponse*>(p->ptr), struct ns1__InsertAlertEvaluationResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__InsertAlertEvaluationResponse*>(p->ptr), struct ns1__InsertAlertEvaluationResponse);
		break;
	case SOAP_TYPE_ns1__InsertAlertEvaluation:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__InsertAlertEvaluation*>(p->ptr), struct ns1__InsertAlertEvaluation);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__InsertAlertEvaluation*>(p->ptr), struct ns1__InsertAlertEvaluation);
		break;
	case SOAP_TYPE_ns1__UpdateAlertResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__UpdateAlertResponse*>(p->ptr), struct ns1__UpdateAlertResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__UpdateAlertResponse*>(p->ptr), struct ns1__UpdateAlertResponse);
		break;
	case SOAP_TYPE_ns1__UpdateAlert:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__UpdateAlert*>(p->ptr), struct ns1__UpdateAlert);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__UpdateAlert*>(p->ptr), struct ns1__UpdateAlert);
		break;
	case SOAP_TYPE_ns1__InsertAlertResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__InsertAlertResponse*>(p->ptr), struct ns1__InsertAlertResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__InsertAlertResponse*>(p->ptr), struct ns1__InsertAlertResponse);
		break;
	case SOAP_TYPE_ns1__InsertAlert:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__InsertAlert*>(p->ptr), struct ns1__InsertAlert);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__InsertAlert*>(p->ptr), struct ns1__InsertAlert);
		break;
	case SOAP_TYPE_ns1__GetWebServiceNameResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__GetWebServiceNameResponse*>(p->ptr), struct ns1__GetWebServiceNameResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__GetWebServiceNameResponse*>(p->ptr), struct ns1__GetWebServiceNameResponse);
		break;
	case SOAP_TYPE_ns1__GetWebServiceName:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__GetWebServiceName*>(p->ptr), struct ns1__GetWebServiceName);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__GetWebServiceName*>(p->ptr), struct ns1__GetWebServiceName);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Header*>(p->ptr), struct SOAP_ENV__Header);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Header*>(p->ptr), struct SOAP_ENV__Header);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Code*>(p->ptr), struct SOAP_ENV__Code);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Code*>(p->ptr), struct SOAP_ENV__Code);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Detail*>(p->ptr), struct SOAP_ENV__Detail);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Detail*>(p->ptr), struct SOAP_ENV__Detail);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Reason*>(p->ptr), struct SOAP_ENV__Reason);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Reason*>(p->ptr), struct SOAP_ENV__Reason);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Fault*>(p->ptr), struct SOAP_ENV__Fault);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Fault*>(p->ptr), struct SOAP_ENV__Fault);
		break;
#endif
	case SOAP_TYPE_SOAP_ENC__string:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	default:
		return SOAP_ERR;
	}
	return SOAP_OK;
}

#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_fbase(int t, int b)
{
	(void)t; (void)b; /* appease -Wall -Werror */
	return 0;
}
#ifdef WIN32
#pragma warning(pop)
#endif

#ifndef WITH_NOIDREF
#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_finsert(struct soap *soap, int t, int tt, void *p, size_t index, const void *q, void **x)
{
	(void)soap; (void)t; (void)p; (void)index; (void)q; (void)x; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_std__string:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns1__DCenterCordInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__DCenterCordInfo type=%d location=%p object=%p\n", t, p, q));
		*(ns1__DCenterCordInfo*)p = *(ns1__DCenterCordInfo*)q;
		break;
	case SOAP_TYPE_ns1__GetVersionResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__GetVersionResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__GetVersionResponse*)p = *(struct ns1__GetVersionResponse*)q;
		break;
	case SOAP_TYPE_ns1__GetVersion:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__GetVersion type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__GetVersion*)p = *(struct ns1__GetVersion*)q;
		break;
	case SOAP_TYPE_ns1__ClearSystemAlertResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__ClearSystemAlertResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__ClearSystemAlertResponse*)p = *(struct ns1__ClearSystemAlertResponse*)q;
		break;
	case SOAP_TYPE_ns1__ClearSystemAlert:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__ClearSystemAlert type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__ClearSystemAlert*)p = *(struct ns1__ClearSystemAlert*)q;
		break;
	case SOAP_TYPE_ns1__ClearApplicationAlertResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__ClearApplicationAlertResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__ClearApplicationAlertResponse*)p = *(struct ns1__ClearApplicationAlertResponse*)q;
		break;
	case SOAP_TYPE_ns1__ClearApplicationAlert:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__ClearApplicationAlert type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__ClearApplicationAlert*)p = *(struct ns1__ClearApplicationAlert*)q;
		break;
	case SOAP_TYPE_ns1__GetSiteRecordResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__GetSiteRecordResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__GetSiteRecordResponse*)p = *(struct ns1__GetSiteRecordResponse*)q;
		break;
	case SOAP_TYPE_ns1__GetSiteRecord:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__GetSiteRecord type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__GetSiteRecord*)p = *(struct ns1__GetSiteRecord*)q;
		break;
	case SOAP_TYPE_ns1__GetServerTypeRecordResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__GetServerTypeRecordResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__GetServerTypeRecordResponse*)p = *(struct ns1__GetServerTypeRecordResponse*)q;
		break;
	case SOAP_TYPE_ns1__GetServerTypeRecord:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__GetServerTypeRecord type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__GetServerTypeRecord*)p = *(struct ns1__GetServerTypeRecord*)q;
		break;
	case SOAP_TYPE_ns1__GetServerRecordResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__GetServerRecordResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__GetServerRecordResponse*)p = *(struct ns1__GetServerRecordResponse*)q;
		break;
	case SOAP_TYPE_ns1__GetServerRecord:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__GetServerRecord type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__GetServerRecord*)p = *(struct ns1__GetServerRecord*)q;
		break;
	case SOAP_TYPE_ns1__GetTlkpSystemAlertStatesRecordResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__GetTlkpSystemAlertStatesRecordResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__GetTlkpSystemAlertStatesRecordResponse*)p = *(struct ns1__GetTlkpSystemAlertStatesRecordResponse*)q;
		break;
	case SOAP_TYPE_ns1__GetTlkpSystemAlertStatesRecord:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__GetTlkpSystemAlertStatesRecord type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__GetTlkpSystemAlertStatesRecord*)p = *(struct ns1__GetTlkpSystemAlertStatesRecord*)q;
		break;
	case SOAP_TYPE_ns1__GetTlkpSystemAlertActionsRecordResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__GetTlkpSystemAlertActionsRecordResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__GetTlkpSystemAlertActionsRecordResponse*)p = *(struct ns1__GetTlkpSystemAlertActionsRecordResponse*)q;
		break;
	case SOAP_TYPE_ns1__GetTlkpSystemAlertActionsRecord:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__GetTlkpSystemAlertActionsRecord type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__GetTlkpSystemAlertActionsRecord*)p = *(struct ns1__GetTlkpSystemAlertActionsRecord*)q;
		break;
	case SOAP_TYPE_ns1__GetTlkpSystemAlertTypesRecordResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__GetTlkpSystemAlertTypesRecordResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__GetTlkpSystemAlertTypesRecordResponse*)p = *(struct ns1__GetTlkpSystemAlertTypesRecordResponse*)q;
		break;
	case SOAP_TYPE_ns1__GetTlkpSystemAlertTypesRecord:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__GetTlkpSystemAlertTypesRecord type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__GetTlkpSystemAlertTypesRecord*)p = *(struct ns1__GetTlkpSystemAlertTypesRecord*)q;
		break;
	case SOAP_TYPE_ns1__GetApplicationAlertsByStartDateResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__GetApplicationAlertsByStartDateResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__GetApplicationAlertsByStartDateResponse*)p = *(struct ns1__GetApplicationAlertsByStartDateResponse*)q;
		break;
	case SOAP_TYPE_ns1__GetApplicationAlertsByStartDate:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__GetApplicationAlertsByStartDate type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__GetApplicationAlertsByStartDate*)p = *(struct ns1__GetApplicationAlertsByStartDate*)q;
		break;
	case SOAP_TYPE_ns1__GetApplicationAlertsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__GetApplicationAlertsResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__GetApplicationAlertsResponse*)p = *(struct ns1__GetApplicationAlertsResponse*)q;
		break;
	case SOAP_TYPE_ns1__GetApplicationAlerts:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__GetApplicationAlerts type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__GetApplicationAlerts*)p = *(struct ns1__GetApplicationAlerts*)q;
		break;
	case SOAP_TYPE_ns1__GetApplicationAlertsFilterResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__GetApplicationAlertsFilterResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__GetApplicationAlertsFilterResponse*)p = *(struct ns1__GetApplicationAlertsFilterResponse*)q;
		break;
	case SOAP_TYPE_ns1__GetApplicationAlertsFilter:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__GetApplicationAlertsFilter type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__GetApplicationAlertsFilter*)p = *(struct ns1__GetApplicationAlertsFilter*)q;
		break;
	case SOAP_TYPE_ns1__GetSystemAlertsFilterResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__GetSystemAlertsFilterResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__GetSystemAlertsFilterResponse*)p = *(struct ns1__GetSystemAlertsFilterResponse*)q;
		break;
	case SOAP_TYPE_ns1__GetSystemAlertsFilter:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__GetSystemAlertsFilter type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__GetSystemAlertsFilter*)p = *(struct ns1__GetSystemAlertsFilter*)q;
		break;
	case SOAP_TYPE_ns1__GetSystemAlertsByStartDateResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__GetSystemAlertsByStartDateResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__GetSystemAlertsByStartDateResponse*)p = *(struct ns1__GetSystemAlertsByStartDateResponse*)q;
		break;
	case SOAP_TYPE_ns1__GetSystemAlertsByStartDate:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__GetSystemAlertsByStartDate type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__GetSystemAlertsByStartDate*)p = *(struct ns1__GetSystemAlertsByStartDate*)q;
		break;
	case SOAP_TYPE_ns1__GetSystemAlertsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__GetSystemAlertsResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__GetSystemAlertsResponse*)p = *(struct ns1__GetSystemAlertsResponse*)q;
		break;
	case SOAP_TYPE_ns1__GetSystemAlerts:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__GetSystemAlerts type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__GetSystemAlerts*)p = *(struct ns1__GetSystemAlerts*)q;
		break;
	case SOAP_TYPE_ns1__AcknowledgeApplicationAlertResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__AcknowledgeApplicationAlertResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__AcknowledgeApplicationAlertResponse*)p = *(struct ns1__AcknowledgeApplicationAlertResponse*)q;
		break;
	case SOAP_TYPE_ns1__AcknowledgeApplicationAlert:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__AcknowledgeApplicationAlert type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__AcknowledgeApplicationAlert*)p = *(struct ns1__AcknowledgeApplicationAlert*)q;
		break;
	case SOAP_TYPE_ns1__AcknowledgeSystemAlertResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__AcknowledgeSystemAlertResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__AcknowledgeSystemAlertResponse*)p = *(struct ns1__AcknowledgeSystemAlertResponse*)q;
		break;
	case SOAP_TYPE_ns1__AcknowledgeSystemAlert:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__AcknowledgeSystemAlert type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__AcknowledgeSystemAlert*)p = *(struct ns1__AcknowledgeSystemAlert*)q;
		break;
	case SOAP_TYPE_ns1__DeleteAlertActionField2Response:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__DeleteAlertActionField2Response type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__DeleteAlertActionField2Response*)p = *(struct ns1__DeleteAlertActionField2Response*)q;
		break;
	case SOAP_TYPE_ns1__DeleteAlertActionField2:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__DeleteAlertActionField2 type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__DeleteAlertActionField2*)p = *(struct ns1__DeleteAlertActionField2*)q;
		break;
	case SOAP_TYPE_ns1__DeleteAlertActionFieldResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__DeleteAlertActionFieldResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__DeleteAlertActionFieldResponse*)p = *(struct ns1__DeleteAlertActionFieldResponse*)q;
		break;
	case SOAP_TYPE_ns1__DeleteAlertActionField:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__DeleteAlertActionField type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__DeleteAlertActionField*)p = *(struct ns1__DeleteAlertActionField*)q;
		break;
	case SOAP_TYPE_ns1__DeleteAlertActionParameter2Response:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__DeleteAlertActionParameter2Response type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__DeleteAlertActionParameter2Response*)p = *(struct ns1__DeleteAlertActionParameter2Response*)q;
		break;
	case SOAP_TYPE_ns1__DeleteAlertActionParameter2:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__DeleteAlertActionParameter2 type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__DeleteAlertActionParameter2*)p = *(struct ns1__DeleteAlertActionParameter2*)q;
		break;
	case SOAP_TYPE_ns1__DeleteAlertActionParameterResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__DeleteAlertActionParameterResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__DeleteAlertActionParameterResponse*)p = *(struct ns1__DeleteAlertActionParameterResponse*)q;
		break;
	case SOAP_TYPE_ns1__DeleteAlertActionParameter:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__DeleteAlertActionParameter type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__DeleteAlertActionParameter*)p = *(struct ns1__DeleteAlertActionParameter*)q;
		break;
	case SOAP_TYPE_ns1__DeleteAlertScheduleByScheduleIdResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__DeleteAlertScheduleByScheduleIdResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__DeleteAlertScheduleByScheduleIdResponse*)p = *(struct ns1__DeleteAlertScheduleByScheduleIdResponse*)q;
		break;
	case SOAP_TYPE_ns1__DeleteAlertScheduleByScheduleId:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__DeleteAlertScheduleByScheduleId type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__DeleteAlertScheduleByScheduleId*)p = *(struct ns1__DeleteAlertScheduleByScheduleId*)q;
		break;
	case SOAP_TYPE_ns1__DeleteAlertScheduleResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__DeleteAlertScheduleResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__DeleteAlertScheduleResponse*)p = *(struct ns1__DeleteAlertScheduleResponse*)q;
		break;
	case SOAP_TYPE_ns1__DeleteAlertSchedule:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__DeleteAlertSchedule type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__DeleteAlertSchedule*)p = *(struct ns1__DeleteAlertSchedule*)q;
		break;
	case SOAP_TYPE_ns1__DeleteAlertAction2Response:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__DeleteAlertAction2Response type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__DeleteAlertAction2Response*)p = *(struct ns1__DeleteAlertAction2Response*)q;
		break;
	case SOAP_TYPE_ns1__DeleteAlertAction2:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__DeleteAlertAction2 type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__DeleteAlertAction2*)p = *(struct ns1__DeleteAlertAction2*)q;
		break;
	case SOAP_TYPE_ns1__DeleteAlertActionResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__DeleteAlertActionResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__DeleteAlertActionResponse*)p = *(struct ns1__DeleteAlertActionResponse*)q;
		break;
	case SOAP_TYPE_ns1__DeleteAlertAction:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__DeleteAlertAction type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__DeleteAlertAction*)p = *(struct ns1__DeleteAlertAction*)q;
		break;
	case SOAP_TYPE_ns1__DeleteAlertEvaluation2Response:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__DeleteAlertEvaluation2Response type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__DeleteAlertEvaluation2Response*)p = *(struct ns1__DeleteAlertEvaluation2Response*)q;
		break;
	case SOAP_TYPE_ns1__DeleteAlertEvaluation2:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__DeleteAlertEvaluation2 type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__DeleteAlertEvaluation2*)p = *(struct ns1__DeleteAlertEvaluation2*)q;
		break;
	case SOAP_TYPE_ns1__DeleteAlertEvaluationResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__DeleteAlertEvaluationResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__DeleteAlertEvaluationResponse*)p = *(struct ns1__DeleteAlertEvaluationResponse*)q;
		break;
	case SOAP_TYPE_ns1__DeleteAlertEvaluation:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__DeleteAlertEvaluation type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__DeleteAlertEvaluation*)p = *(struct ns1__DeleteAlertEvaluation*)q;
		break;
	case SOAP_TYPE_ns1__DeleteAlertResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__DeleteAlertResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__DeleteAlertResponse*)p = *(struct ns1__DeleteAlertResponse*)q;
		break;
	case SOAP_TYPE_ns1__DeleteAlert:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__DeleteAlert type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__DeleteAlert*)p = *(struct ns1__DeleteAlert*)q;
		break;
	case SOAP_TYPE_ns1__GetRunningCenterCordResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__GetRunningCenterCordResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__GetRunningCenterCordResponse*)p = *(struct ns1__GetRunningCenterCordResponse*)q;
		break;
	case SOAP_TYPE_ns1__GetRunningCenterCord:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__GetRunningCenterCord type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__GetRunningCenterCord*)p = *(struct ns1__GetRunningCenterCord*)q;
		break;
	case SOAP_TYPE_ns1__SetClientTypeResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__SetClientTypeResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__SetClientTypeResponse*)p = *(struct ns1__SetClientTypeResponse*)q;
		break;
	case SOAP_TYPE_ns1__SetClientType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__SetClientType type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__SetClientType*)p = *(struct ns1__SetClientType*)q;
		break;
	case SOAP_TYPE_ns1__SendServerUpdateNotificationResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__SendServerUpdateNotificationResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__SendServerUpdateNotificationResponse*)p = *(struct ns1__SendServerUpdateNotificationResponse*)q;
		break;
	case SOAP_TYPE_ns1__SendServerUpdateNotification:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__SendServerUpdateNotification type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__SendServerUpdateNotification*)p = *(struct ns1__SendServerUpdateNotification*)q;
		break;
	case SOAP_TYPE_ns1__UnSubscribeToDocumentTypeResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__UnSubscribeToDocumentTypeResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__UnSubscribeToDocumentTypeResponse*)p = *(struct ns1__UnSubscribeToDocumentTypeResponse*)q;
		break;
	case SOAP_TYPE_ns1__UnSubscribeToDocumentType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__UnSubscribeToDocumentType type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__UnSubscribeToDocumentType*)p = *(struct ns1__UnSubscribeToDocumentType*)q;
		break;
	case SOAP_TYPE_ns1__SubscribeToDocumentTypeResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__SubscribeToDocumentTypeResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__SubscribeToDocumentTypeResponse*)p = *(struct ns1__SubscribeToDocumentTypeResponse*)q;
		break;
	case SOAP_TYPE_ns1__SubscribeToDocumentType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__SubscribeToDocumentType type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__SubscribeToDocumentType*)p = *(struct ns1__SubscribeToDocumentType*)q;
		break;
	case SOAP_TYPE_ns1__SendNetworkDocumentResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__SendNetworkDocumentResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__SendNetworkDocumentResponse*)p = *(struct ns1__SendNetworkDocumentResponse*)q;
		break;
	case SOAP_TYPE_ns1__SendNetworkDocument:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__SendNetworkDocument type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__SendNetworkDocument*)p = *(struct ns1__SendNetworkDocument*)q;
		break;
	case SOAP_TYPE_ns1__SendAlertResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__SendAlertResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__SendAlertResponse*)p = *(struct ns1__SendAlertResponse*)q;
		break;
	case SOAP_TYPE_ns1__SendAlert:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__SendAlert type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__SendAlert*)p = *(struct ns1__SendAlert*)q;
		break;
	case SOAP_TYPE_ns1__GetTlkpActionParametersRecordByParameterIdResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__GetTlkpActionParametersRecordByParameterIdResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__GetTlkpActionParametersRecordByParameterIdResponse*)p = *(struct ns1__GetTlkpActionParametersRecordByParameterIdResponse*)q;
		break;
	case SOAP_TYPE_ns1__GetTlkpActionParametersRecordByParameterId:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__GetTlkpActionParametersRecordByParameterId type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__GetTlkpActionParametersRecordByParameterId*)p = *(struct ns1__GetTlkpActionParametersRecordByParameterId*)q;
		break;
	case SOAP_TYPE_ns1__GetTlkpActionParametersRecordResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__GetTlkpActionParametersRecordResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__GetTlkpActionParametersRecordResponse*)p = *(struct ns1__GetTlkpActionParametersRecordResponse*)q;
		break;
	case SOAP_TYPE_ns1__GetTlkpActionParametersRecord:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__GetTlkpActionParametersRecord type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__GetTlkpActionParametersRecord*)p = *(struct ns1__GetTlkpActionParametersRecord*)q;
		break;
	case SOAP_TYPE_ns1__GetTlkpPriorityLevelRecordByPriorityLevelResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__GetTlkpPriorityLevelRecordByPriorityLevelResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__GetTlkpPriorityLevelRecordByPriorityLevelResponse*)p = *(struct ns1__GetTlkpPriorityLevelRecordByPriorityLevelResponse*)q;
		break;
	case SOAP_TYPE_ns1__GetTlkpPriorityLevelRecordByPriorityLevel:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__GetTlkpPriorityLevelRecordByPriorityLevel type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__GetTlkpPriorityLevelRecordByPriorityLevel*)p = *(struct ns1__GetTlkpPriorityLevelRecordByPriorityLevel*)q;
		break;
	case SOAP_TYPE_ns1__GetTlkpPriorityLevelRecordResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__GetTlkpPriorityLevelRecordResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__GetTlkpPriorityLevelRecordResponse*)p = *(struct ns1__GetTlkpPriorityLevelRecordResponse*)q;
		break;
	case SOAP_TYPE_ns1__GetTlkpPriorityLevelRecord:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__GetTlkpPriorityLevelRecord type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__GetTlkpPriorityLevelRecord*)p = *(struct ns1__GetTlkpPriorityLevelRecord*)q;
		break;
	case SOAP_TYPE_ns1__GetTlkpActionsRecordByActionResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__GetTlkpActionsRecordByActionResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__GetTlkpActionsRecordByActionResponse*)p = *(struct ns1__GetTlkpActionsRecordByActionResponse*)q;
		break;
	case SOAP_TYPE_ns1__GetTlkpActionsRecordByAction:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__GetTlkpActionsRecordByAction type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__GetTlkpActionsRecordByAction*)p = *(struct ns1__GetTlkpActionsRecordByAction*)q;
		break;
	case SOAP_TYPE_ns1__GetTlkpActionsRecordResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__GetTlkpActionsRecordResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__GetTlkpActionsRecordResponse*)p = *(struct ns1__GetTlkpActionsRecordResponse*)q;
		break;
	case SOAP_TYPE_ns1__GetTlkpActionsRecord:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__GetTlkpActionsRecord type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__GetTlkpActionsRecord*)p = *(struct ns1__GetTlkpActionsRecord*)q;
		break;
	case SOAP_TYPE_ns1__GetTlkpDocumentFieldTypesRecordResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__GetTlkpDocumentFieldTypesRecordResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__GetTlkpDocumentFieldTypesRecordResponse*)p = *(struct ns1__GetTlkpDocumentFieldTypesRecordResponse*)q;
		break;
	case SOAP_TYPE_ns1__GetTlkpDocumentFieldTypesRecord:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__GetTlkpDocumentFieldTypesRecord type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__GetTlkpDocumentFieldTypesRecord*)p = *(struct ns1__GetTlkpDocumentFieldTypesRecord*)q;
		break;
	case SOAP_TYPE_ns1__GetTlkpDocumentFieldsRecordResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__GetTlkpDocumentFieldsRecordResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__GetTlkpDocumentFieldsRecordResponse*)p = *(struct ns1__GetTlkpDocumentFieldsRecordResponse*)q;
		break;
	case SOAP_TYPE_ns1__GetTlkpDocumentFieldsRecord:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__GetTlkpDocumentFieldsRecord type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__GetTlkpDocumentFieldsRecord*)p = *(struct ns1__GetTlkpDocumentFieldsRecord*)q;
		break;
	case SOAP_TYPE_ns1__GetTlkpDocumentTypesRecordByClientTypeResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__GetTlkpDocumentTypesRecordByClientTypeResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__GetTlkpDocumentTypesRecordByClientTypeResponse*)p = *(struct ns1__GetTlkpDocumentTypesRecordByClientTypeResponse*)q;
		break;
	case SOAP_TYPE_ns1__GetTlkpDocumentTypesRecordByClientType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__GetTlkpDocumentTypesRecordByClientType type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__GetTlkpDocumentTypesRecordByClientType*)p = *(struct ns1__GetTlkpDocumentTypesRecordByClientType*)q;
		break;
	case SOAP_TYPE_ns1__GetTlkpDocumentTypesRecordResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__GetTlkpDocumentTypesRecordResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__GetTlkpDocumentTypesRecordResponse*)p = *(struct ns1__GetTlkpDocumentTypesRecordResponse*)q;
		break;
	case SOAP_TYPE_ns1__GetTlkpDocumentTypesRecord:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__GetTlkpDocumentTypesRecord type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__GetTlkpDocumentTypesRecord*)p = *(struct ns1__GetTlkpDocumentTypesRecord*)q;
		break;
	case SOAP_TYPE_ns1__GetAlertActionFieldsRecordResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__GetAlertActionFieldsRecordResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__GetAlertActionFieldsRecordResponse*)p = *(struct ns1__GetAlertActionFieldsRecordResponse*)q;
		break;
	case SOAP_TYPE_ns1__GetAlertActionFieldsRecord:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__GetAlertActionFieldsRecord type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__GetAlertActionFieldsRecord*)p = *(struct ns1__GetAlertActionFieldsRecord*)q;
		break;
	case SOAP_TYPE_ns1__GetAlertActionParameterRecordResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__GetAlertActionParameterRecordResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__GetAlertActionParameterRecordResponse*)p = *(struct ns1__GetAlertActionParameterRecordResponse*)q;
		break;
	case SOAP_TYPE_ns1__GetAlertActionParameterRecord:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__GetAlertActionParameterRecord type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__GetAlertActionParameterRecord*)p = *(struct ns1__GetAlertActionParameterRecord*)q;
		break;
	case SOAP_TYPE_ns1__GetAlertSchedulesRecordResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__GetAlertSchedulesRecordResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__GetAlertSchedulesRecordResponse*)p = *(struct ns1__GetAlertSchedulesRecordResponse*)q;
		break;
	case SOAP_TYPE_ns1__GetAlertSchedulesRecord:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__GetAlertSchedulesRecord type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__GetAlertSchedulesRecord*)p = *(struct ns1__GetAlertSchedulesRecord*)q;
		break;
	case SOAP_TYPE_ns1__GetAlertActionsRecordResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__GetAlertActionsRecordResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__GetAlertActionsRecordResponse*)p = *(struct ns1__GetAlertActionsRecordResponse*)q;
		break;
	case SOAP_TYPE_ns1__GetAlertActionsRecord:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__GetAlertActionsRecord type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__GetAlertActionsRecord*)p = *(struct ns1__GetAlertActionsRecord*)q;
		break;
	case SOAP_TYPE_ns1__GetAlertEvaluationsRecordResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__GetAlertEvaluationsRecordResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__GetAlertEvaluationsRecordResponse*)p = *(struct ns1__GetAlertEvaluationsRecordResponse*)q;
		break;
	case SOAP_TYPE_ns1__GetAlertEvaluationsRecord:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__GetAlertEvaluationsRecord type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__GetAlertEvaluationsRecord*)p = *(struct ns1__GetAlertEvaluationsRecord*)q;
		break;
	case SOAP_TYPE_ns1__GetAlertsRecordByDocumentTypeResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__GetAlertsRecordByDocumentTypeResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__GetAlertsRecordByDocumentTypeResponse*)p = *(struct ns1__GetAlertsRecordByDocumentTypeResponse*)q;
		break;
	case SOAP_TYPE_ns1__GetAlertsRecordByDocumentType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__GetAlertsRecordByDocumentType type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__GetAlertsRecordByDocumentType*)p = *(struct ns1__GetAlertsRecordByDocumentType*)q;
		break;
	case SOAP_TYPE_ns1__GetAlertsRecordResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__GetAlertsRecordResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__GetAlertsRecordResponse*)p = *(struct ns1__GetAlertsRecordResponse*)q;
		break;
	case SOAP_TYPE_ns1__GetAlertsRecord:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__GetAlertsRecord type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__GetAlertsRecord*)p = *(struct ns1__GetAlertsRecord*)q;
		break;
	case SOAP_TYPE_ns1__UpdateAlertActionFieldResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__UpdateAlertActionFieldResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__UpdateAlertActionFieldResponse*)p = *(struct ns1__UpdateAlertActionFieldResponse*)q;
		break;
	case SOAP_TYPE_ns1__UpdateAlertActionField:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__UpdateAlertActionField type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__UpdateAlertActionField*)p = *(struct ns1__UpdateAlertActionField*)q;
		break;
	case SOAP_TYPE_ns1__InsertAlertActionFieldResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__InsertAlertActionFieldResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__InsertAlertActionFieldResponse*)p = *(struct ns1__InsertAlertActionFieldResponse*)q;
		break;
	case SOAP_TYPE_ns1__InsertAlertActionField:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__InsertAlertActionField type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__InsertAlertActionField*)p = *(struct ns1__InsertAlertActionField*)q;
		break;
	case SOAP_TYPE_ns1__UpdateAlertActionParameterResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__UpdateAlertActionParameterResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__UpdateAlertActionParameterResponse*)p = *(struct ns1__UpdateAlertActionParameterResponse*)q;
		break;
	case SOAP_TYPE_ns1__UpdateAlertActionParameter:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__UpdateAlertActionParameter type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__UpdateAlertActionParameter*)p = *(struct ns1__UpdateAlertActionParameter*)q;
		break;
	case SOAP_TYPE_ns1__InsertAlertActionParameterResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__InsertAlertActionParameterResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__InsertAlertActionParameterResponse*)p = *(struct ns1__InsertAlertActionParameterResponse*)q;
		break;
	case SOAP_TYPE_ns1__InsertAlertActionParameter:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__InsertAlertActionParameter type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__InsertAlertActionParameter*)p = *(struct ns1__InsertAlertActionParameter*)q;
		break;
	case SOAP_TYPE_ns1__UpdateAlertScheduleResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__UpdateAlertScheduleResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__UpdateAlertScheduleResponse*)p = *(struct ns1__UpdateAlertScheduleResponse*)q;
		break;
	case SOAP_TYPE_ns1__UpdateAlertSchedule:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__UpdateAlertSchedule type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__UpdateAlertSchedule*)p = *(struct ns1__UpdateAlertSchedule*)q;
		break;
	case SOAP_TYPE_ns1__InsertAlertScheduleResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__InsertAlertScheduleResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__InsertAlertScheduleResponse*)p = *(struct ns1__InsertAlertScheduleResponse*)q;
		break;
	case SOAP_TYPE_ns1__InsertAlertSchedule:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__InsertAlertSchedule type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__InsertAlertSchedule*)p = *(struct ns1__InsertAlertSchedule*)q;
		break;
	case SOAP_TYPE_ns1__UpdateAlertActionResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__UpdateAlertActionResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__UpdateAlertActionResponse*)p = *(struct ns1__UpdateAlertActionResponse*)q;
		break;
	case SOAP_TYPE_ns1__UpdateAlertAction:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__UpdateAlertAction type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__UpdateAlertAction*)p = *(struct ns1__UpdateAlertAction*)q;
		break;
	case SOAP_TYPE_ns1__InsertAlertActionResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__InsertAlertActionResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__InsertAlertActionResponse*)p = *(struct ns1__InsertAlertActionResponse*)q;
		break;
	case SOAP_TYPE_ns1__InsertAlertAction:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__InsertAlertAction type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__InsertAlertAction*)p = *(struct ns1__InsertAlertAction*)q;
		break;
	case SOAP_TYPE_ns1__UpdatetAlertEvaluationResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__UpdatetAlertEvaluationResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__UpdatetAlertEvaluationResponse*)p = *(struct ns1__UpdatetAlertEvaluationResponse*)q;
		break;
	case SOAP_TYPE_ns1__UpdatetAlertEvaluation:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__UpdatetAlertEvaluation type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__UpdatetAlertEvaluation*)p = *(struct ns1__UpdatetAlertEvaluation*)q;
		break;
	case SOAP_TYPE_ns1__InsertAlertEvaluationResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__InsertAlertEvaluationResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__InsertAlertEvaluationResponse*)p = *(struct ns1__InsertAlertEvaluationResponse*)q;
		break;
	case SOAP_TYPE_ns1__InsertAlertEvaluation:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__InsertAlertEvaluation type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__InsertAlertEvaluation*)p = *(struct ns1__InsertAlertEvaluation*)q;
		break;
	case SOAP_TYPE_ns1__UpdateAlertResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__UpdateAlertResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__UpdateAlertResponse*)p = *(struct ns1__UpdateAlertResponse*)q;
		break;
	case SOAP_TYPE_ns1__UpdateAlert:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__UpdateAlert type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__UpdateAlert*)p = *(struct ns1__UpdateAlert*)q;
		break;
	case SOAP_TYPE_ns1__InsertAlertResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__InsertAlertResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__InsertAlertResponse*)p = *(struct ns1__InsertAlertResponse*)q;
		break;
	case SOAP_TYPE_ns1__InsertAlert:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__InsertAlert type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__InsertAlert*)p = *(struct ns1__InsertAlert*)q;
		break;
	case SOAP_TYPE_ns1__GetWebServiceNameResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__GetWebServiceNameResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__GetWebServiceNameResponse*)p = *(struct ns1__GetWebServiceNameResponse*)q;
		break;
	case SOAP_TYPE_ns1__GetWebServiceName:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__GetWebServiceName type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__GetWebServiceName*)p = *(struct ns1__GetWebServiceName*)q;
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Header type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Code type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Detail type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Reason type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Fault type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
		break;
#endif
	case SOAP_TYPE_SOAP_ENC__string:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", t, tt));
	}
}
#ifdef WIN32
#pragma warning(pop)
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	a = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return a;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_new_byte(struct soap *soap, int n)
{
	char *a = static_cast<char *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char)));
	for (char *p = a; p && n--; ++p)
		soap_default_byte(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	if (soap_out_byte(soap, tag ? tag : "byte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	a = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return a;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_new_int(struct soap *soap, int n)
{
	int *a = static_cast<int *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(int)));
	for (int *p = a; p && n--; ++p)
		soap_default_int(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	if (soap_out_int(soap, tag ? tag : "int", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__DCenterCordInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__DCenterCordInfo::AODFeedPortNum);
	soap_default_int(soap, &this->ns1__DCenterCordInfo::AWDPortNum);
	soap_default_int(soap, &this->ns1__DCenterCordInfo::CSLPortNum);
	this->ns1__DCenterCordInfo::IPAddress = NULL;
	soap_default_int(soap, &this->ns1__DCenterCordInfo::clientPortNum);
	soap_default_int(soap, &this->ns1__DCenterCordInfo::extLoggerPortNum);
	soap_default_int(soap, &this->ns1__DCenterCordInfo::serverId);
	soap_default_int(soap, &this->ns1__DCenterCordInfo::siteId);
	soap_default_int(soap, &this->ns1__DCenterCordInfo::tenantId);
	/* transient soap skipped */
}

void ns1__DCenterCordInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToSOAP_ENC__string(soap, &this->ns1__DCenterCordInfo::IPAddress);
#endif
}

int ns1__DCenterCordInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__DCenterCordInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DCenterCordInfo(struct soap *soap, const char *tag, int id, const ns1__DCenterCordInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DCenterCordInfo), type))
		return soap->error;
	if (soap_out_int(soap, "AODFeedPortNum", -1, &a->ns1__DCenterCordInfo::AODFeedPortNum, ""))
		return soap->error;
	if (soap_out_int(soap, "AWDPortNum", -1, &a->ns1__DCenterCordInfo::AWDPortNum, ""))
		return soap->error;
	if (soap_out_int(soap, "CSLPortNum", -1, &a->ns1__DCenterCordInfo::CSLPortNum, ""))
		return soap->error;
	if (!a->ns1__DCenterCordInfo::IPAddress)
	{	if (soap_element_nil(soap, "IPAddress"))
			return soap->error;
	}
	else
	if (soap_out_PointerToSOAP_ENC__string(soap, "IPAddress", -1, &a->ns1__DCenterCordInfo::IPAddress, ""))
		return soap->error;
	if (soap_out_int(soap, "clientPortNum", -1, &a->ns1__DCenterCordInfo::clientPortNum, ""))
		return soap->error;
	if (soap_out_int(soap, "extLoggerPortNum", -1, &a->ns1__DCenterCordInfo::extLoggerPortNum, ""))
		return soap->error;
	if (soap_out_int(soap, "serverId", -1, &a->ns1__DCenterCordInfo::serverId, ""))
		return soap->error;
	if (soap_out_int(soap, "siteId", -1, &a->ns1__DCenterCordInfo::siteId, ""))
		return soap->error;
	if (soap_out_int(soap, "tenantId", -1, &a->ns1__DCenterCordInfo::tenantId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__DCenterCordInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__DCenterCordInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns1__DCenterCordInfo * SOAP_FMAC4 soap_in_ns1__DCenterCordInfo(struct soap *soap, const char *tag, ns1__DCenterCordInfo *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__DCenterCordInfo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DCenterCordInfo, sizeof(ns1__DCenterCordInfo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__DCenterCordInfo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__DCenterCordInfo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_AODFeedPortNum1 = 1;
	size_t soap_flag_AWDPortNum1 = 1;
	size_t soap_flag_CSLPortNum1 = 1;
	size_t soap_flag_IPAddress1 = 1;
	size_t soap_flag_clientPortNum1 = 1;
	size_t soap_flag_extLoggerPortNum1 = 1;
	size_t soap_flag_serverId1 = 1;
	size_t soap_flag_siteId1 = 1;
	size_t soap_flag_tenantId1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AODFeedPortNum1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "AODFeedPortNum", &a->ns1__DCenterCordInfo::AODFeedPortNum, "xsd:int"))
				{	soap_flag_AODFeedPortNum1--;
					continue;
				}
			}
			if (soap_flag_AWDPortNum1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "AWDPortNum", &a->ns1__DCenterCordInfo::AWDPortNum, "xsd:int"))
				{	soap_flag_AWDPortNum1--;
					continue;
				}
			}
			if (soap_flag_CSLPortNum1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "CSLPortNum", &a->ns1__DCenterCordInfo::CSLPortNum, "xsd:int"))
				{	soap_flag_CSLPortNum1--;
					continue;
				}
			}
			if (soap_flag_IPAddress1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToSOAP_ENC__string(soap, "IPAddress", &a->ns1__DCenterCordInfo::IPAddress, "SOAP-ENC:string"))
				{	soap_flag_IPAddress1--;
					continue;
				}
			}
			if (soap_flag_clientPortNum1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "clientPortNum", &a->ns1__DCenterCordInfo::clientPortNum, "xsd:int"))
				{	soap_flag_clientPortNum1--;
					continue;
				}
			}
			if (soap_flag_extLoggerPortNum1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "extLoggerPortNum", &a->ns1__DCenterCordInfo::extLoggerPortNum, "xsd:int"))
				{	soap_flag_extLoggerPortNum1--;
					continue;
				}
			}
			if (soap_flag_serverId1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "serverId", &a->ns1__DCenterCordInfo::serverId, "xsd:int"))
				{	soap_flag_serverId1--;
					continue;
				}
			}
			if (soap_flag_siteId1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "siteId", &a->ns1__DCenterCordInfo::siteId, "xsd:int"))
				{	soap_flag_siteId1--;
					continue;
				}
			}
			if (soap_flag_tenantId1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tenantId", &a->ns1__DCenterCordInfo::tenantId, "xsd:int"))
				{	soap_flag_tenantId1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AODFeedPortNum1 > 0 || soap_flag_AWDPortNum1 > 0 || soap_flag_CSLPortNum1 > 0 || soap_flag_IPAddress1 > 0 || soap_flag_clientPortNum1 > 0 || soap_flag_extLoggerPortNum1 > 0 || soap_flag_serverId1 > 0 || soap_flag_siteId1 > 0 || soap_flag_tenantId1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__DCenterCordInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DCenterCordInfo, SOAP_TYPE_ns1__DCenterCordInfo, sizeof(ns1__DCenterCordInfo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__DCenterCordInfo * SOAP_FMAC2 soap_instantiate_ns1__DCenterCordInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__DCenterCordInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__DCenterCordInfo *p;
	size_t k = sizeof(ns1__DCenterCordInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__DCenterCordInfo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__DCenterCordInfo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__DCenterCordInfo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__DCenterCordInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__DCenterCordInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__DCenterCordInfo(soap, tag ? tag : "ns1:DCenterCordInfo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__DCenterCordInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__DCenterCordInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns1__DCenterCordInfo * SOAP_FMAC4 soap_get_ns1__DCenterCordInfo(struct soap *soap, ns1__DCenterCordInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DCenterCordInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENC__string(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENC__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_SOAP_ENC__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_SOAP_ENC__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_SOAP_ENC__string, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_SOAP_ENC__string, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_SOAP_ENC__string, SOAP_TYPE_SOAP_ENC__string, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENC__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENC__string(soap, tag ? tag : "SOAP-ENC:string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_SOAP_ENC__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENC__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_std__string, SOAP_TYPE_std__string, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::string *p;
	size_t k = sizeof(std::string);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__string, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::string);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::string, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::string location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_std__string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->faultcode);
	soap_serialize_string(soap, (char*const*)&a->faultstring);
	soap_serialize_string(soap, (char*const*)&a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Node);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)(void*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, (char*const*)&a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, (char*const*)&a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, (char*const*)&a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, (char*const*)&a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "faultcode", (char**)&a->faultcode, "xsd:QName"))
				{	soap_flag_faultcode--;
					continue;
				}
			}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultstring", (char**)&a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultactor", (char**)&a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Node", (char**)&a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Role", (char**)&a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Fault *p;
	size_t k = sizeof(struct SOAP_ENV__Fault);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Fault);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Fault, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Fault location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Fault(soap, tag ? tag : "SOAP-ENV:Fault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, (char*const*)&a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Text", (char**)&a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Reason *p;
	size_t k = sizeof(struct SOAP_ENV__Reason);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Reason);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Reason, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Reason location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Detail *p;
	size_t k = sizeof(struct SOAP_ENV__Detail);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Detail);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Detail, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Detail location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)(void*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "SOAP-ENV:Value", (char**)&a->SOAP_ENV__Value, "xsd:QName"))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Code *p;
	size_t k = sizeof(struct SOAP_ENV__Code);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Code);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Code, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Code location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Header *p;
	size_t k = sizeof(struct SOAP_ENV__Header);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Header);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Header, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Header location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Header(soap, tag ? tag : "SOAP-ENV:Header", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetWebServiceName(struct soap *soap, struct ns1__GetWebServiceName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetWebServiceName(struct soap *soap, const struct ns1__GetWebServiceName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetWebServiceName(struct soap *soap, const char *tag, int id, const struct ns1__GetWebServiceName *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetWebServiceName), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetWebServiceName * SOAP_FMAC4 soap_in_ns1__GetWebServiceName(struct soap *soap, const char *tag, struct ns1__GetWebServiceName *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetWebServiceName*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetWebServiceName, sizeof(struct ns1__GetWebServiceName), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__GetWebServiceName(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__GetWebServiceName *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetWebServiceName, SOAP_TYPE_ns1__GetWebServiceName, sizeof(struct ns1__GetWebServiceName), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__GetWebServiceName * SOAP_FMAC2 soap_instantiate_ns1__GetWebServiceName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetWebServiceName(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__GetWebServiceName *p;
	size_t k = sizeof(struct ns1__GetWebServiceName);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GetWebServiceName, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__GetWebServiceName);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__GetWebServiceName, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__GetWebServiceName location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetWebServiceName(struct soap *soap, const struct ns1__GetWebServiceName *a, const char *tag, const char *type)
{
	if (soap_out_ns1__GetWebServiceName(soap, tag ? tag : "ns1:GetWebServiceName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetWebServiceName * SOAP_FMAC4 soap_get_ns1__GetWebServiceName(struct soap *soap, struct ns1__GetWebServiceName *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetWebServiceName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetWebServiceNameResponse(struct soap *soap, struct ns1__GetWebServiceNameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_SOAP_ENC__string(soap, &a->GetWebServiceNameReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetWebServiceNameResponse(struct soap *soap, const struct ns1__GetWebServiceNameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->GetWebServiceNameReturn, SOAP_TYPE_SOAP_ENC__string);
	soap_serialize_SOAP_ENC__string(soap, &a->GetWebServiceNameReturn);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetWebServiceNameResponse(struct soap *soap, const char *tag, int id, const struct ns1__GetWebServiceNameResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetWebServiceNameResponse), type))
		return soap->error;
	if (soap_out_SOAP_ENC__string(soap, "GetWebServiceNameReturn", -1, &a->GetWebServiceNameReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetWebServiceNameResponse * SOAP_FMAC4 soap_in_ns1__GetWebServiceNameResponse(struct soap *soap, const char *tag, struct ns1__GetWebServiceNameResponse *a, const char *type)
{
	size_t soap_flag_GetWebServiceNameReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetWebServiceNameResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetWebServiceNameResponse, sizeof(struct ns1__GetWebServiceNameResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns1__GetWebServiceNameResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetWebServiceNameReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_SOAP_ENC__string(soap, "GetWebServiceNameReturn", &a->GetWebServiceNameReturn, "SOAP-ENC:string"))
				{	soap_flag_GetWebServiceNameReturn--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_GetWebServiceNameReturn > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__GetWebServiceNameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetWebServiceNameResponse, SOAP_TYPE_ns1__GetWebServiceNameResponse, sizeof(struct ns1__GetWebServiceNameResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__GetWebServiceNameResponse * SOAP_FMAC2 soap_instantiate_ns1__GetWebServiceNameResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetWebServiceNameResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__GetWebServiceNameResponse *p;
	size_t k = sizeof(struct ns1__GetWebServiceNameResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GetWebServiceNameResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__GetWebServiceNameResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__GetWebServiceNameResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__GetWebServiceNameResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetWebServiceNameResponse(struct soap *soap, const struct ns1__GetWebServiceNameResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__GetWebServiceNameResponse(soap, tag ? tag : "ns1:GetWebServiceNameResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetWebServiceNameResponse * SOAP_FMAC4 soap_get_ns1__GetWebServiceNameResponse(struct soap *soap, struct ns1__GetWebServiceNameResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetWebServiceNameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__InsertAlert(struct soap *soap, struct ns1__InsertAlert *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_in0);
	soap_default_SOAP_ENC__string(soap, &a->_in1);
	soap_default_SOAP_ENC__string(soap, &a->_in2);
	soap_default_int(soap, &a->_in3);
	soap_default_SOAP_ENC__string(soap, &a->_in4);
	soap_default_int(soap, &a->_in5);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__InsertAlert(struct soap *soap, const struct ns1__InsertAlert *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->_in1, SOAP_TYPE_SOAP_ENC__string);
	soap_serialize_SOAP_ENC__string(soap, &a->_in1);
	soap_embedded(soap, &a->_in2, SOAP_TYPE_SOAP_ENC__string);
	soap_serialize_SOAP_ENC__string(soap, &a->_in2);
	soap_embedded(soap, &a->_in4, SOAP_TYPE_SOAP_ENC__string);
	soap_serialize_SOAP_ENC__string(soap, &a->_in4);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__InsertAlert(struct soap *soap, const char *tag, int id, const struct ns1__InsertAlert *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__InsertAlert), type))
		return soap->error;
	if (soap_out_int(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	if (soap_out_SOAP_ENC__string(soap, "in1", -1, &a->_in1, ""))
		return soap->error;
	if (soap_out_SOAP_ENC__string(soap, "in2", -1, &a->_in2, ""))
		return soap->error;
	if (soap_out_int(soap, "in3", -1, &a->_in3, ""))
		return soap->error;
	if (soap_out_SOAP_ENC__string(soap, "in4", -1, &a->_in4, ""))
		return soap->error;
	if (soap_out_int(soap, "in5", -1, &a->_in5, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__InsertAlert * SOAP_FMAC4 soap_in_ns1__InsertAlert(struct soap *soap, const char *tag, struct ns1__InsertAlert *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	size_t soap_flag__in1 = 1;
	size_t soap_flag__in2 = 1;
	size_t soap_flag__in3 = 1;
	size_t soap_flag__in4 = 1;
	size_t soap_flag__in5 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__InsertAlert*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__InsertAlert, sizeof(struct ns1__InsertAlert), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns1__InsertAlert(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, NULL, &a->_in0, "xsd:int"))
				{	soap_flag__in0--;
					continue;
				}
			}
			if (soap_flag__in1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_SOAP_ENC__string(soap, NULL, &a->_in1, "SOAP-ENC:string"))
				{	soap_flag__in1--;
					continue;
				}
			}
			if (soap_flag__in2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_SOAP_ENC__string(soap, NULL, &a->_in2, "SOAP-ENC:string"))
				{	soap_flag__in2--;
					continue;
				}
			}
			if (soap_flag__in3 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, NULL, &a->_in3, "xsd:int"))
				{	soap_flag__in3--;
					continue;
				}
			}
			if (soap_flag__in4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_SOAP_ENC__string(soap, NULL, &a->_in4, "SOAP-ENC:string"))
				{	soap_flag__in4--;
					continue;
				}
			}
			if (soap_flag__in5 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, NULL, &a->_in5, "xsd:int"))
				{	soap_flag__in5--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__in0 > 0 || soap_flag__in1 > 0 || soap_flag__in2 > 0 || soap_flag__in3 > 0 || soap_flag__in4 > 0 || soap_flag__in5 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__InsertAlert *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__InsertAlert, SOAP_TYPE_ns1__InsertAlert, sizeof(struct ns1__InsertAlert), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__InsertAlert * SOAP_FMAC2 soap_instantiate_ns1__InsertAlert(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__InsertAlert(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__InsertAlert *p;
	size_t k = sizeof(struct ns1__InsertAlert);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__InsertAlert, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__InsertAlert);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__InsertAlert, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__InsertAlert location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__InsertAlert(struct soap *soap, const struct ns1__InsertAlert *a, const char *tag, const char *type)
{
	if (soap_out_ns1__InsertAlert(soap, tag ? tag : "ns1:InsertAlert", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__InsertAlert * SOAP_FMAC4 soap_get_ns1__InsertAlert(struct soap *soap, struct ns1__InsertAlert *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__InsertAlert(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__InsertAlertResponse(struct soap *soap, struct ns1__InsertAlertResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_InsertAlertReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__InsertAlertResponse(struct soap *soap, const struct ns1__InsertAlertResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__InsertAlertResponse(struct soap *soap, const char *tag, int id, const struct ns1__InsertAlertResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__InsertAlertResponse), type))
		return soap->error;
	if (soap_out_int(soap, "InsertAlertReturn", -1, &a->_InsertAlertReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__InsertAlertResponse * SOAP_FMAC4 soap_in_ns1__InsertAlertResponse(struct soap *soap, const char *tag, struct ns1__InsertAlertResponse *a, const char *type)
{
	size_t soap_flag__InsertAlertReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__InsertAlertResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__InsertAlertResponse, sizeof(struct ns1__InsertAlertResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__InsertAlertResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__InsertAlertReturn && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, NULL, &a->_InsertAlertReturn, "xsd:int"))
				{	soap_flag__InsertAlertReturn--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__InsertAlertReturn > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__InsertAlertResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__InsertAlertResponse, SOAP_TYPE_ns1__InsertAlertResponse, sizeof(struct ns1__InsertAlertResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__InsertAlertResponse * SOAP_FMAC2 soap_instantiate_ns1__InsertAlertResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__InsertAlertResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__InsertAlertResponse *p;
	size_t k = sizeof(struct ns1__InsertAlertResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__InsertAlertResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__InsertAlertResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__InsertAlertResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__InsertAlertResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__InsertAlertResponse(struct soap *soap, const struct ns1__InsertAlertResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__InsertAlertResponse(soap, tag ? tag : "ns1:InsertAlertResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__InsertAlertResponse * SOAP_FMAC4 soap_get_ns1__InsertAlertResponse(struct soap *soap, struct ns1__InsertAlertResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__InsertAlertResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__UpdateAlert(struct soap *soap, struct ns1__UpdateAlert *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_in0);
	soap_default_SOAP_ENC__string(soap, &a->_in1);
	soap_default_SOAP_ENC__string(soap, &a->_in2);
	soap_default_int(soap, &a->_in3);
	soap_default_int(soap, &a->_in4);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__UpdateAlert(struct soap *soap, const struct ns1__UpdateAlert *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->_in1, SOAP_TYPE_SOAP_ENC__string);
	soap_serialize_SOAP_ENC__string(soap, &a->_in1);
	soap_embedded(soap, &a->_in2, SOAP_TYPE_SOAP_ENC__string);
	soap_serialize_SOAP_ENC__string(soap, &a->_in2);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__UpdateAlert(struct soap *soap, const char *tag, int id, const struct ns1__UpdateAlert *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__UpdateAlert), type))
		return soap->error;
	if (soap_out_int(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	if (soap_out_SOAP_ENC__string(soap, "in1", -1, &a->_in1, ""))
		return soap->error;
	if (soap_out_SOAP_ENC__string(soap, "in2", -1, &a->_in2, ""))
		return soap->error;
	if (soap_out_int(soap, "in3", -1, &a->_in3, ""))
		return soap->error;
	if (soap_out_int(soap, "in4", -1, &a->_in4, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__UpdateAlert * SOAP_FMAC4 soap_in_ns1__UpdateAlert(struct soap *soap, const char *tag, struct ns1__UpdateAlert *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	size_t soap_flag__in1 = 1;
	size_t soap_flag__in2 = 1;
	size_t soap_flag__in3 = 1;
	size_t soap_flag__in4 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__UpdateAlert*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__UpdateAlert, sizeof(struct ns1__UpdateAlert), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns1__UpdateAlert(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, NULL, &a->_in0, "xsd:int"))
				{	soap_flag__in0--;
					continue;
				}
			}
			if (soap_flag__in1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_SOAP_ENC__string(soap, NULL, &a->_in1, "SOAP-ENC:string"))
				{	soap_flag__in1--;
					continue;
				}
			}
			if (soap_flag__in2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_SOAP_ENC__string(soap, NULL, &a->_in2, "SOAP-ENC:string"))
				{	soap_flag__in2--;
					continue;
				}
			}
			if (soap_flag__in3 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, NULL, &a->_in3, "xsd:int"))
				{	soap_flag__in3--;
					continue;
				}
			}
			if (soap_flag__in4 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, NULL, &a->_in4, "xsd:int"))
				{	soap_flag__in4--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__in0 > 0 || soap_flag__in1 > 0 || soap_flag__in2 > 0 || soap_flag__in3 > 0 || soap_flag__in4 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__UpdateAlert *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__UpdateAlert, SOAP_TYPE_ns1__UpdateAlert, sizeof(struct ns1__UpdateAlert), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__UpdateAlert * SOAP_FMAC2 soap_instantiate_ns1__UpdateAlert(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__UpdateAlert(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__UpdateAlert *p;
	size_t k = sizeof(struct ns1__UpdateAlert);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__UpdateAlert, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__UpdateAlert);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__UpdateAlert, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__UpdateAlert location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__UpdateAlert(struct soap *soap, const struct ns1__UpdateAlert *a, const char *tag, const char *type)
{
	if (soap_out_ns1__UpdateAlert(soap, tag ? tag : "ns1:UpdateAlert", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__UpdateAlert * SOAP_FMAC4 soap_get_ns1__UpdateAlert(struct soap *soap, struct ns1__UpdateAlert *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__UpdateAlert(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__UpdateAlertResponse(struct soap *soap, struct ns1__UpdateAlertResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__UpdateAlertResponse(struct soap *soap, const struct ns1__UpdateAlertResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__UpdateAlertResponse(struct soap *soap, const char *tag, int id, const struct ns1__UpdateAlertResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__UpdateAlertResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__UpdateAlertResponse * SOAP_FMAC4 soap_in_ns1__UpdateAlertResponse(struct soap *soap, const char *tag, struct ns1__UpdateAlertResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__UpdateAlertResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__UpdateAlertResponse, sizeof(struct ns1__UpdateAlertResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__UpdateAlertResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__UpdateAlertResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__UpdateAlertResponse, SOAP_TYPE_ns1__UpdateAlertResponse, sizeof(struct ns1__UpdateAlertResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__UpdateAlertResponse * SOAP_FMAC2 soap_instantiate_ns1__UpdateAlertResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__UpdateAlertResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__UpdateAlertResponse *p;
	size_t k = sizeof(struct ns1__UpdateAlertResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__UpdateAlertResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__UpdateAlertResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__UpdateAlertResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__UpdateAlertResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__UpdateAlertResponse(struct soap *soap, const struct ns1__UpdateAlertResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__UpdateAlertResponse(soap, tag ? tag : "ns1:UpdateAlertResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__UpdateAlertResponse * SOAP_FMAC4 soap_get_ns1__UpdateAlertResponse(struct soap *soap, struct ns1__UpdateAlertResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__UpdateAlertResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__InsertAlertEvaluation(struct soap *soap, struct ns1__InsertAlertEvaluation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_in0);
	soap_default_SOAP_ENC__string(soap, &a->_in1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__InsertAlertEvaluation(struct soap *soap, const struct ns1__InsertAlertEvaluation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->_in1, SOAP_TYPE_SOAP_ENC__string);
	soap_serialize_SOAP_ENC__string(soap, &a->_in1);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__InsertAlertEvaluation(struct soap *soap, const char *tag, int id, const struct ns1__InsertAlertEvaluation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__InsertAlertEvaluation), type))
		return soap->error;
	if (soap_out_int(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	if (soap_out_SOAP_ENC__string(soap, "in1", -1, &a->_in1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__InsertAlertEvaluation * SOAP_FMAC4 soap_in_ns1__InsertAlertEvaluation(struct soap *soap, const char *tag, struct ns1__InsertAlertEvaluation *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	size_t soap_flag__in1 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__InsertAlertEvaluation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__InsertAlertEvaluation, sizeof(struct ns1__InsertAlertEvaluation), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns1__InsertAlertEvaluation(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, NULL, &a->_in0, "xsd:int"))
				{	soap_flag__in0--;
					continue;
				}
			}
			if (soap_flag__in1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_SOAP_ENC__string(soap, NULL, &a->_in1, "SOAP-ENC:string"))
				{	soap_flag__in1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__in0 > 0 || soap_flag__in1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__InsertAlertEvaluation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__InsertAlertEvaluation, SOAP_TYPE_ns1__InsertAlertEvaluation, sizeof(struct ns1__InsertAlertEvaluation), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__InsertAlertEvaluation * SOAP_FMAC2 soap_instantiate_ns1__InsertAlertEvaluation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__InsertAlertEvaluation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__InsertAlertEvaluation *p;
	size_t k = sizeof(struct ns1__InsertAlertEvaluation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__InsertAlertEvaluation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__InsertAlertEvaluation);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__InsertAlertEvaluation, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__InsertAlertEvaluation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__InsertAlertEvaluation(struct soap *soap, const struct ns1__InsertAlertEvaluation *a, const char *tag, const char *type)
{
	if (soap_out_ns1__InsertAlertEvaluation(soap, tag ? tag : "ns1:InsertAlertEvaluation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__InsertAlertEvaluation * SOAP_FMAC4 soap_get_ns1__InsertAlertEvaluation(struct soap *soap, struct ns1__InsertAlertEvaluation *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__InsertAlertEvaluation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__InsertAlertEvaluationResponse(struct soap *soap, struct ns1__InsertAlertEvaluationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_InsertAlertEvaluationReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__InsertAlertEvaluationResponse(struct soap *soap, const struct ns1__InsertAlertEvaluationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__InsertAlertEvaluationResponse(struct soap *soap, const char *tag, int id, const struct ns1__InsertAlertEvaluationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__InsertAlertEvaluationResponse), type))
		return soap->error;
	if (soap_out_int(soap, "InsertAlertEvaluationReturn", -1, &a->_InsertAlertEvaluationReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__InsertAlertEvaluationResponse * SOAP_FMAC4 soap_in_ns1__InsertAlertEvaluationResponse(struct soap *soap, const char *tag, struct ns1__InsertAlertEvaluationResponse *a, const char *type)
{
	size_t soap_flag__InsertAlertEvaluationReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__InsertAlertEvaluationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__InsertAlertEvaluationResponse, sizeof(struct ns1__InsertAlertEvaluationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__InsertAlertEvaluationResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__InsertAlertEvaluationReturn && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, NULL, &a->_InsertAlertEvaluationReturn, "xsd:int"))
				{	soap_flag__InsertAlertEvaluationReturn--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__InsertAlertEvaluationReturn > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__InsertAlertEvaluationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__InsertAlertEvaluationResponse, SOAP_TYPE_ns1__InsertAlertEvaluationResponse, sizeof(struct ns1__InsertAlertEvaluationResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__InsertAlertEvaluationResponse * SOAP_FMAC2 soap_instantiate_ns1__InsertAlertEvaluationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__InsertAlertEvaluationResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__InsertAlertEvaluationResponse *p;
	size_t k = sizeof(struct ns1__InsertAlertEvaluationResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__InsertAlertEvaluationResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__InsertAlertEvaluationResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__InsertAlertEvaluationResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__InsertAlertEvaluationResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__InsertAlertEvaluationResponse(struct soap *soap, const struct ns1__InsertAlertEvaluationResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__InsertAlertEvaluationResponse(soap, tag ? tag : "ns1:InsertAlertEvaluationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__InsertAlertEvaluationResponse * SOAP_FMAC4 soap_get_ns1__InsertAlertEvaluationResponse(struct soap *soap, struct ns1__InsertAlertEvaluationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__InsertAlertEvaluationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__UpdatetAlertEvaluation(struct soap *soap, struct ns1__UpdatetAlertEvaluation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_in0);
	soap_default_SOAP_ENC__string(soap, &a->_in1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__UpdatetAlertEvaluation(struct soap *soap, const struct ns1__UpdatetAlertEvaluation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->_in1, SOAP_TYPE_SOAP_ENC__string);
	soap_serialize_SOAP_ENC__string(soap, &a->_in1);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__UpdatetAlertEvaluation(struct soap *soap, const char *tag, int id, const struct ns1__UpdatetAlertEvaluation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__UpdatetAlertEvaluation), type))
		return soap->error;
	if (soap_out_int(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	if (soap_out_SOAP_ENC__string(soap, "in1", -1, &a->_in1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__UpdatetAlertEvaluation * SOAP_FMAC4 soap_in_ns1__UpdatetAlertEvaluation(struct soap *soap, const char *tag, struct ns1__UpdatetAlertEvaluation *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	size_t soap_flag__in1 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__UpdatetAlertEvaluation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__UpdatetAlertEvaluation, sizeof(struct ns1__UpdatetAlertEvaluation), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns1__UpdatetAlertEvaluation(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, NULL, &a->_in0, "xsd:int"))
				{	soap_flag__in0--;
					continue;
				}
			}
			if (soap_flag__in1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_SOAP_ENC__string(soap, NULL, &a->_in1, "SOAP-ENC:string"))
				{	soap_flag__in1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__in0 > 0 || soap_flag__in1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__UpdatetAlertEvaluation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__UpdatetAlertEvaluation, SOAP_TYPE_ns1__UpdatetAlertEvaluation, sizeof(struct ns1__UpdatetAlertEvaluation), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__UpdatetAlertEvaluation * SOAP_FMAC2 soap_instantiate_ns1__UpdatetAlertEvaluation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__UpdatetAlertEvaluation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__UpdatetAlertEvaluation *p;
	size_t k = sizeof(struct ns1__UpdatetAlertEvaluation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__UpdatetAlertEvaluation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__UpdatetAlertEvaluation);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__UpdatetAlertEvaluation, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__UpdatetAlertEvaluation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__UpdatetAlertEvaluation(struct soap *soap, const struct ns1__UpdatetAlertEvaluation *a, const char *tag, const char *type)
{
	if (soap_out_ns1__UpdatetAlertEvaluation(soap, tag ? tag : "ns1:UpdatetAlertEvaluation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__UpdatetAlertEvaluation * SOAP_FMAC4 soap_get_ns1__UpdatetAlertEvaluation(struct soap *soap, struct ns1__UpdatetAlertEvaluation *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__UpdatetAlertEvaluation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__UpdatetAlertEvaluationResponse(struct soap *soap, struct ns1__UpdatetAlertEvaluationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__UpdatetAlertEvaluationResponse(struct soap *soap, const struct ns1__UpdatetAlertEvaluationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__UpdatetAlertEvaluationResponse(struct soap *soap, const char *tag, int id, const struct ns1__UpdatetAlertEvaluationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__UpdatetAlertEvaluationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__UpdatetAlertEvaluationResponse * SOAP_FMAC4 soap_in_ns1__UpdatetAlertEvaluationResponse(struct soap *soap, const char *tag, struct ns1__UpdatetAlertEvaluationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__UpdatetAlertEvaluationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__UpdatetAlertEvaluationResponse, sizeof(struct ns1__UpdatetAlertEvaluationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__UpdatetAlertEvaluationResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__UpdatetAlertEvaluationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__UpdatetAlertEvaluationResponse, SOAP_TYPE_ns1__UpdatetAlertEvaluationResponse, sizeof(struct ns1__UpdatetAlertEvaluationResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__UpdatetAlertEvaluationResponse * SOAP_FMAC2 soap_instantiate_ns1__UpdatetAlertEvaluationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__UpdatetAlertEvaluationResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__UpdatetAlertEvaluationResponse *p;
	size_t k = sizeof(struct ns1__UpdatetAlertEvaluationResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__UpdatetAlertEvaluationResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__UpdatetAlertEvaluationResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__UpdatetAlertEvaluationResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__UpdatetAlertEvaluationResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__UpdatetAlertEvaluationResponse(struct soap *soap, const struct ns1__UpdatetAlertEvaluationResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__UpdatetAlertEvaluationResponse(soap, tag ? tag : "ns1:UpdatetAlertEvaluationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__UpdatetAlertEvaluationResponse * SOAP_FMAC4 soap_get_ns1__UpdatetAlertEvaluationResponse(struct soap *soap, struct ns1__UpdatetAlertEvaluationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__UpdatetAlertEvaluationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__InsertAlertAction(struct soap *soap, struct ns1__InsertAlertAction *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_in0);
	soap_default_int(soap, &a->_in1);
	soap_default_int(soap, &a->_in2);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__InsertAlertAction(struct soap *soap, const struct ns1__InsertAlertAction *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__InsertAlertAction(struct soap *soap, const char *tag, int id, const struct ns1__InsertAlertAction *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__InsertAlertAction), type))
		return soap->error;
	if (soap_out_int(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	if (soap_out_int(soap, "in1", -1, &a->_in1, ""))
		return soap->error;
	if (soap_out_int(soap, "in2", -1, &a->_in2, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__InsertAlertAction * SOAP_FMAC4 soap_in_ns1__InsertAlertAction(struct soap *soap, const char *tag, struct ns1__InsertAlertAction *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	size_t soap_flag__in1 = 1;
	size_t soap_flag__in2 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__InsertAlertAction*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__InsertAlertAction, sizeof(struct ns1__InsertAlertAction), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__InsertAlertAction(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, NULL, &a->_in0, "xsd:int"))
				{	soap_flag__in0--;
					continue;
				}
			}
			if (soap_flag__in1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, NULL, &a->_in1, "xsd:int"))
				{	soap_flag__in1--;
					continue;
				}
			}
			if (soap_flag__in2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, NULL, &a->_in2, "xsd:int"))
				{	soap_flag__in2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__in0 > 0 || soap_flag__in1 > 0 || soap_flag__in2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__InsertAlertAction *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__InsertAlertAction, SOAP_TYPE_ns1__InsertAlertAction, sizeof(struct ns1__InsertAlertAction), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__InsertAlertAction * SOAP_FMAC2 soap_instantiate_ns1__InsertAlertAction(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__InsertAlertAction(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__InsertAlertAction *p;
	size_t k = sizeof(struct ns1__InsertAlertAction);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__InsertAlertAction, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__InsertAlertAction);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__InsertAlertAction, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__InsertAlertAction location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__InsertAlertAction(struct soap *soap, const struct ns1__InsertAlertAction *a, const char *tag, const char *type)
{
	if (soap_out_ns1__InsertAlertAction(soap, tag ? tag : "ns1:InsertAlertAction", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__InsertAlertAction * SOAP_FMAC4 soap_get_ns1__InsertAlertAction(struct soap *soap, struct ns1__InsertAlertAction *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__InsertAlertAction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__InsertAlertActionResponse(struct soap *soap, struct ns1__InsertAlertActionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_InsertAlertActionReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__InsertAlertActionResponse(struct soap *soap, const struct ns1__InsertAlertActionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__InsertAlertActionResponse(struct soap *soap, const char *tag, int id, const struct ns1__InsertAlertActionResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__InsertAlertActionResponse), type))
		return soap->error;
	if (soap_out_int(soap, "InsertAlertActionReturn", -1, &a->_InsertAlertActionReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__InsertAlertActionResponse * SOAP_FMAC4 soap_in_ns1__InsertAlertActionResponse(struct soap *soap, const char *tag, struct ns1__InsertAlertActionResponse *a, const char *type)
{
	size_t soap_flag__InsertAlertActionReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__InsertAlertActionResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__InsertAlertActionResponse, sizeof(struct ns1__InsertAlertActionResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__InsertAlertActionResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__InsertAlertActionReturn && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, NULL, &a->_InsertAlertActionReturn, "xsd:int"))
				{	soap_flag__InsertAlertActionReturn--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__InsertAlertActionReturn > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__InsertAlertActionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__InsertAlertActionResponse, SOAP_TYPE_ns1__InsertAlertActionResponse, sizeof(struct ns1__InsertAlertActionResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__InsertAlertActionResponse * SOAP_FMAC2 soap_instantiate_ns1__InsertAlertActionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__InsertAlertActionResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__InsertAlertActionResponse *p;
	size_t k = sizeof(struct ns1__InsertAlertActionResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__InsertAlertActionResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__InsertAlertActionResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__InsertAlertActionResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__InsertAlertActionResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__InsertAlertActionResponse(struct soap *soap, const struct ns1__InsertAlertActionResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__InsertAlertActionResponse(soap, tag ? tag : "ns1:InsertAlertActionResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__InsertAlertActionResponse * SOAP_FMAC4 soap_get_ns1__InsertAlertActionResponse(struct soap *soap, struct ns1__InsertAlertActionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__InsertAlertActionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__UpdateAlertAction(struct soap *soap, struct ns1__UpdateAlertAction *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_in0);
	soap_default_int(soap, &a->_in1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__UpdateAlertAction(struct soap *soap, const struct ns1__UpdateAlertAction *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__UpdateAlertAction(struct soap *soap, const char *tag, int id, const struct ns1__UpdateAlertAction *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__UpdateAlertAction), type))
		return soap->error;
	if (soap_out_int(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	if (soap_out_int(soap, "in1", -1, &a->_in1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__UpdateAlertAction * SOAP_FMAC4 soap_in_ns1__UpdateAlertAction(struct soap *soap, const char *tag, struct ns1__UpdateAlertAction *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	size_t soap_flag__in1 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__UpdateAlertAction*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__UpdateAlertAction, sizeof(struct ns1__UpdateAlertAction), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__UpdateAlertAction(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, NULL, &a->_in0, "xsd:int"))
				{	soap_flag__in0--;
					continue;
				}
			}
			if (soap_flag__in1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, NULL, &a->_in1, "xsd:int"))
				{	soap_flag__in1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__in0 > 0 || soap_flag__in1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__UpdateAlertAction *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__UpdateAlertAction, SOAP_TYPE_ns1__UpdateAlertAction, sizeof(struct ns1__UpdateAlertAction), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__UpdateAlertAction * SOAP_FMAC2 soap_instantiate_ns1__UpdateAlertAction(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__UpdateAlertAction(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__UpdateAlertAction *p;
	size_t k = sizeof(struct ns1__UpdateAlertAction);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__UpdateAlertAction, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__UpdateAlertAction);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__UpdateAlertAction, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__UpdateAlertAction location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__UpdateAlertAction(struct soap *soap, const struct ns1__UpdateAlertAction *a, const char *tag, const char *type)
{
	if (soap_out_ns1__UpdateAlertAction(soap, tag ? tag : "ns1:UpdateAlertAction", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__UpdateAlertAction * SOAP_FMAC4 soap_get_ns1__UpdateAlertAction(struct soap *soap, struct ns1__UpdateAlertAction *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__UpdateAlertAction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__UpdateAlertActionResponse(struct soap *soap, struct ns1__UpdateAlertActionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__UpdateAlertActionResponse(struct soap *soap, const struct ns1__UpdateAlertActionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__UpdateAlertActionResponse(struct soap *soap, const char *tag, int id, const struct ns1__UpdateAlertActionResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__UpdateAlertActionResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__UpdateAlertActionResponse * SOAP_FMAC4 soap_in_ns1__UpdateAlertActionResponse(struct soap *soap, const char *tag, struct ns1__UpdateAlertActionResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__UpdateAlertActionResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__UpdateAlertActionResponse, sizeof(struct ns1__UpdateAlertActionResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__UpdateAlertActionResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__UpdateAlertActionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__UpdateAlertActionResponse, SOAP_TYPE_ns1__UpdateAlertActionResponse, sizeof(struct ns1__UpdateAlertActionResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__UpdateAlertActionResponse * SOAP_FMAC2 soap_instantiate_ns1__UpdateAlertActionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__UpdateAlertActionResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__UpdateAlertActionResponse *p;
	size_t k = sizeof(struct ns1__UpdateAlertActionResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__UpdateAlertActionResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__UpdateAlertActionResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__UpdateAlertActionResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__UpdateAlertActionResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__UpdateAlertActionResponse(struct soap *soap, const struct ns1__UpdateAlertActionResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__UpdateAlertActionResponse(soap, tag ? tag : "ns1:UpdateAlertActionResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__UpdateAlertActionResponse * SOAP_FMAC4 soap_get_ns1__UpdateAlertActionResponse(struct soap *soap, struct ns1__UpdateAlertActionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__UpdateAlertActionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__InsertAlertSchedule(struct soap *soap, struct ns1__InsertAlertSchedule *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_in0);
	soap_default_SOAP_ENC__string(soap, &a->_in1);
	soap_default_SOAP_ENC__string(soap, &a->_in2);
	soap_default_SOAP_ENC__string(soap, &a->_in3);
	soap_default_SOAP_ENC__string(soap, &a->_in4);
	soap_default_SOAP_ENC__string(soap, &a->_in5);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__InsertAlertSchedule(struct soap *soap, const struct ns1__InsertAlertSchedule *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->_in1, SOAP_TYPE_SOAP_ENC__string);
	soap_serialize_SOAP_ENC__string(soap, &a->_in1);
	soap_embedded(soap, &a->_in2, SOAP_TYPE_SOAP_ENC__string);
	soap_serialize_SOAP_ENC__string(soap, &a->_in2);
	soap_embedded(soap, &a->_in3, SOAP_TYPE_SOAP_ENC__string);
	soap_serialize_SOAP_ENC__string(soap, &a->_in3);
	soap_embedded(soap, &a->_in4, SOAP_TYPE_SOAP_ENC__string);
	soap_serialize_SOAP_ENC__string(soap, &a->_in4);
	soap_embedded(soap, &a->_in5, SOAP_TYPE_SOAP_ENC__string);
	soap_serialize_SOAP_ENC__string(soap, &a->_in5);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__InsertAlertSchedule(struct soap *soap, const char *tag, int id, const struct ns1__InsertAlertSchedule *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__InsertAlertSchedule), type))
		return soap->error;
	if (soap_out_int(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	if (soap_out_SOAP_ENC__string(soap, "in1", -1, &a->_in1, ""))
		return soap->error;
	if (soap_out_SOAP_ENC__string(soap, "in2", -1, &a->_in2, ""))
		return soap->error;
	if (soap_out_SOAP_ENC__string(soap, "in3", -1, &a->_in3, ""))
		return soap->error;
	if (soap_out_SOAP_ENC__string(soap, "in4", -1, &a->_in4, ""))
		return soap->error;
	if (soap_out_SOAP_ENC__string(soap, "in5", -1, &a->_in5, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__InsertAlertSchedule * SOAP_FMAC4 soap_in_ns1__InsertAlertSchedule(struct soap *soap, const char *tag, struct ns1__InsertAlertSchedule *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	size_t soap_flag__in1 = 1;
	size_t soap_flag__in2 = 1;
	size_t soap_flag__in3 = 1;
	size_t soap_flag__in4 = 1;
	size_t soap_flag__in5 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__InsertAlertSchedule*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__InsertAlertSchedule, sizeof(struct ns1__InsertAlertSchedule), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns1__InsertAlertSchedule(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, NULL, &a->_in0, "xsd:int"))
				{	soap_flag__in0--;
					continue;
				}
			}
			if (soap_flag__in1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_SOAP_ENC__string(soap, NULL, &a->_in1, "SOAP-ENC:string"))
				{	soap_flag__in1--;
					continue;
				}
			}
			if (soap_flag__in2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_SOAP_ENC__string(soap, NULL, &a->_in2, "SOAP-ENC:string"))
				{	soap_flag__in2--;
					continue;
				}
			}
			if (soap_flag__in3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_SOAP_ENC__string(soap, NULL, &a->_in3, "SOAP-ENC:string"))
				{	soap_flag__in3--;
					continue;
				}
			}
			if (soap_flag__in4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_SOAP_ENC__string(soap, NULL, &a->_in4, "SOAP-ENC:string"))
				{	soap_flag__in4--;
					continue;
				}
			}
			if (soap_flag__in5 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_SOAP_ENC__string(soap, NULL, &a->_in5, "SOAP-ENC:string"))
				{	soap_flag__in5--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__in0 > 0 || soap_flag__in1 > 0 || soap_flag__in2 > 0 || soap_flag__in3 > 0 || soap_flag__in4 > 0 || soap_flag__in5 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__InsertAlertSchedule *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__InsertAlertSchedule, SOAP_TYPE_ns1__InsertAlertSchedule, sizeof(struct ns1__InsertAlertSchedule), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__InsertAlertSchedule * SOAP_FMAC2 soap_instantiate_ns1__InsertAlertSchedule(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__InsertAlertSchedule(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__InsertAlertSchedule *p;
	size_t k = sizeof(struct ns1__InsertAlertSchedule);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__InsertAlertSchedule, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__InsertAlertSchedule);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__InsertAlertSchedule, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__InsertAlertSchedule location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__InsertAlertSchedule(struct soap *soap, const struct ns1__InsertAlertSchedule *a, const char *tag, const char *type)
{
	if (soap_out_ns1__InsertAlertSchedule(soap, tag ? tag : "ns1:InsertAlertSchedule", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__InsertAlertSchedule * SOAP_FMAC4 soap_get_ns1__InsertAlertSchedule(struct soap *soap, struct ns1__InsertAlertSchedule *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__InsertAlertSchedule(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__InsertAlertScheduleResponse(struct soap *soap, struct ns1__InsertAlertScheduleResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_InsertAlertScheduleReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__InsertAlertScheduleResponse(struct soap *soap, const struct ns1__InsertAlertScheduleResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__InsertAlertScheduleResponse(struct soap *soap, const char *tag, int id, const struct ns1__InsertAlertScheduleResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__InsertAlertScheduleResponse), type))
		return soap->error;
	if (soap_out_int(soap, "InsertAlertScheduleReturn", -1, &a->_InsertAlertScheduleReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__InsertAlertScheduleResponse * SOAP_FMAC4 soap_in_ns1__InsertAlertScheduleResponse(struct soap *soap, const char *tag, struct ns1__InsertAlertScheduleResponse *a, const char *type)
{
	size_t soap_flag__InsertAlertScheduleReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__InsertAlertScheduleResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__InsertAlertScheduleResponse, sizeof(struct ns1__InsertAlertScheduleResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__InsertAlertScheduleResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__InsertAlertScheduleReturn && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, NULL, &a->_InsertAlertScheduleReturn, "xsd:int"))
				{	soap_flag__InsertAlertScheduleReturn--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__InsertAlertScheduleReturn > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__InsertAlertScheduleResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__InsertAlertScheduleResponse, SOAP_TYPE_ns1__InsertAlertScheduleResponse, sizeof(struct ns1__InsertAlertScheduleResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__InsertAlertScheduleResponse * SOAP_FMAC2 soap_instantiate_ns1__InsertAlertScheduleResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__InsertAlertScheduleResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__InsertAlertScheduleResponse *p;
	size_t k = sizeof(struct ns1__InsertAlertScheduleResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__InsertAlertScheduleResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__InsertAlertScheduleResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__InsertAlertScheduleResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__InsertAlertScheduleResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__InsertAlertScheduleResponse(struct soap *soap, const struct ns1__InsertAlertScheduleResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__InsertAlertScheduleResponse(soap, tag ? tag : "ns1:InsertAlertScheduleResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__InsertAlertScheduleResponse * SOAP_FMAC4 soap_get_ns1__InsertAlertScheduleResponse(struct soap *soap, struct ns1__InsertAlertScheduleResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__InsertAlertScheduleResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__UpdateAlertSchedule(struct soap *soap, struct ns1__UpdateAlertSchedule *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_in0);
	soap_default_SOAP_ENC__string(soap, &a->_in1);
	soap_default_SOAP_ENC__string(soap, &a->_in2);
	soap_default_SOAP_ENC__string(soap, &a->_in3);
	soap_default_SOAP_ENC__string(soap, &a->_in4);
	soap_default_SOAP_ENC__string(soap, &a->_in5);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__UpdateAlertSchedule(struct soap *soap, const struct ns1__UpdateAlertSchedule *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->_in1, SOAP_TYPE_SOAP_ENC__string);
	soap_serialize_SOAP_ENC__string(soap, &a->_in1);
	soap_embedded(soap, &a->_in2, SOAP_TYPE_SOAP_ENC__string);
	soap_serialize_SOAP_ENC__string(soap, &a->_in2);
	soap_embedded(soap, &a->_in3, SOAP_TYPE_SOAP_ENC__string);
	soap_serialize_SOAP_ENC__string(soap, &a->_in3);
	soap_embedded(soap, &a->_in4, SOAP_TYPE_SOAP_ENC__string);
	soap_serialize_SOAP_ENC__string(soap, &a->_in4);
	soap_embedded(soap, &a->_in5, SOAP_TYPE_SOAP_ENC__string);
	soap_serialize_SOAP_ENC__string(soap, &a->_in5);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__UpdateAlertSchedule(struct soap *soap, const char *tag, int id, const struct ns1__UpdateAlertSchedule *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__UpdateAlertSchedule), type))
		return soap->error;
	if (soap_out_int(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	if (soap_out_SOAP_ENC__string(soap, "in1", -1, &a->_in1, ""))
		return soap->error;
	if (soap_out_SOAP_ENC__string(soap, "in2", -1, &a->_in2, ""))
		return soap->error;
	if (soap_out_SOAP_ENC__string(soap, "in3", -1, &a->_in3, ""))
		return soap->error;
	if (soap_out_SOAP_ENC__string(soap, "in4", -1, &a->_in4, ""))
		return soap->error;
	if (soap_out_SOAP_ENC__string(soap, "in5", -1, &a->_in5, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__UpdateAlertSchedule * SOAP_FMAC4 soap_in_ns1__UpdateAlertSchedule(struct soap *soap, const char *tag, struct ns1__UpdateAlertSchedule *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	size_t soap_flag__in1 = 1;
	size_t soap_flag__in2 = 1;
	size_t soap_flag__in3 = 1;
	size_t soap_flag__in4 = 1;
	size_t soap_flag__in5 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__UpdateAlertSchedule*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__UpdateAlertSchedule, sizeof(struct ns1__UpdateAlertSchedule), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns1__UpdateAlertSchedule(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, NULL, &a->_in0, "xsd:int"))
				{	soap_flag__in0--;
					continue;
				}
			}
			if (soap_flag__in1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_SOAP_ENC__string(soap, NULL, &a->_in1, "SOAP-ENC:string"))
				{	soap_flag__in1--;
					continue;
				}
			}
			if (soap_flag__in2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_SOAP_ENC__string(soap, NULL, &a->_in2, "SOAP-ENC:string"))
				{	soap_flag__in2--;
					continue;
				}
			}
			if (soap_flag__in3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_SOAP_ENC__string(soap, NULL, &a->_in3, "SOAP-ENC:string"))
				{	soap_flag__in3--;
					continue;
				}
			}
			if (soap_flag__in4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_SOAP_ENC__string(soap, NULL, &a->_in4, "SOAP-ENC:string"))
				{	soap_flag__in4--;
					continue;
				}
			}
			if (soap_flag__in5 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_SOAP_ENC__string(soap, NULL, &a->_in5, "SOAP-ENC:string"))
				{	soap_flag__in5--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__in0 > 0 || soap_flag__in1 > 0 || soap_flag__in2 > 0 || soap_flag__in3 > 0 || soap_flag__in4 > 0 || soap_flag__in5 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__UpdateAlertSchedule *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__UpdateAlertSchedule, SOAP_TYPE_ns1__UpdateAlertSchedule, sizeof(struct ns1__UpdateAlertSchedule), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__UpdateAlertSchedule * SOAP_FMAC2 soap_instantiate_ns1__UpdateAlertSchedule(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__UpdateAlertSchedule(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__UpdateAlertSchedule *p;
	size_t k = sizeof(struct ns1__UpdateAlertSchedule);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__UpdateAlertSchedule, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__UpdateAlertSchedule);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__UpdateAlertSchedule, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__UpdateAlertSchedule location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__UpdateAlertSchedule(struct soap *soap, const struct ns1__UpdateAlertSchedule *a, const char *tag, const char *type)
{
	if (soap_out_ns1__UpdateAlertSchedule(soap, tag ? tag : "ns1:UpdateAlertSchedule", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__UpdateAlertSchedule * SOAP_FMAC4 soap_get_ns1__UpdateAlertSchedule(struct soap *soap, struct ns1__UpdateAlertSchedule *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__UpdateAlertSchedule(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__UpdateAlertScheduleResponse(struct soap *soap, struct ns1__UpdateAlertScheduleResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__UpdateAlertScheduleResponse(struct soap *soap, const struct ns1__UpdateAlertScheduleResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__UpdateAlertScheduleResponse(struct soap *soap, const char *tag, int id, const struct ns1__UpdateAlertScheduleResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__UpdateAlertScheduleResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__UpdateAlertScheduleResponse * SOAP_FMAC4 soap_in_ns1__UpdateAlertScheduleResponse(struct soap *soap, const char *tag, struct ns1__UpdateAlertScheduleResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__UpdateAlertScheduleResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__UpdateAlertScheduleResponse, sizeof(struct ns1__UpdateAlertScheduleResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__UpdateAlertScheduleResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__UpdateAlertScheduleResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__UpdateAlertScheduleResponse, SOAP_TYPE_ns1__UpdateAlertScheduleResponse, sizeof(struct ns1__UpdateAlertScheduleResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__UpdateAlertScheduleResponse * SOAP_FMAC2 soap_instantiate_ns1__UpdateAlertScheduleResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__UpdateAlertScheduleResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__UpdateAlertScheduleResponse *p;
	size_t k = sizeof(struct ns1__UpdateAlertScheduleResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__UpdateAlertScheduleResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__UpdateAlertScheduleResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__UpdateAlertScheduleResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__UpdateAlertScheduleResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__UpdateAlertScheduleResponse(struct soap *soap, const struct ns1__UpdateAlertScheduleResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__UpdateAlertScheduleResponse(soap, tag ? tag : "ns1:UpdateAlertScheduleResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__UpdateAlertScheduleResponse * SOAP_FMAC4 soap_get_ns1__UpdateAlertScheduleResponse(struct soap *soap, struct ns1__UpdateAlertScheduleResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__UpdateAlertScheduleResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__InsertAlertActionParameter(struct soap *soap, struct ns1__InsertAlertActionParameter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_in0);
	soap_default_int(soap, &a->_in1);
	soap_default_SOAP_ENC__string(soap, &a->_in2);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__InsertAlertActionParameter(struct soap *soap, const struct ns1__InsertAlertActionParameter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->_in2, SOAP_TYPE_SOAP_ENC__string);
	soap_serialize_SOAP_ENC__string(soap, &a->_in2);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__InsertAlertActionParameter(struct soap *soap, const char *tag, int id, const struct ns1__InsertAlertActionParameter *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__InsertAlertActionParameter), type))
		return soap->error;
	if (soap_out_int(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	if (soap_out_int(soap, "in1", -1, &a->_in1, ""))
		return soap->error;
	if (soap_out_SOAP_ENC__string(soap, "in2", -1, &a->_in2, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__InsertAlertActionParameter * SOAP_FMAC4 soap_in_ns1__InsertAlertActionParameter(struct soap *soap, const char *tag, struct ns1__InsertAlertActionParameter *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	size_t soap_flag__in1 = 1;
	size_t soap_flag__in2 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__InsertAlertActionParameter*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__InsertAlertActionParameter, sizeof(struct ns1__InsertAlertActionParameter), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns1__InsertAlertActionParameter(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, NULL, &a->_in0, "xsd:int"))
				{	soap_flag__in0--;
					continue;
				}
			}
			if (soap_flag__in1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, NULL, &a->_in1, "xsd:int"))
				{	soap_flag__in1--;
					continue;
				}
			}
			if (soap_flag__in2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_SOAP_ENC__string(soap, NULL, &a->_in2, "SOAP-ENC:string"))
				{	soap_flag__in2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__in0 > 0 || soap_flag__in1 > 0 || soap_flag__in2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__InsertAlertActionParameter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__InsertAlertActionParameter, SOAP_TYPE_ns1__InsertAlertActionParameter, sizeof(struct ns1__InsertAlertActionParameter), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__InsertAlertActionParameter * SOAP_FMAC2 soap_instantiate_ns1__InsertAlertActionParameter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__InsertAlertActionParameter(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__InsertAlertActionParameter *p;
	size_t k = sizeof(struct ns1__InsertAlertActionParameter);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__InsertAlertActionParameter, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__InsertAlertActionParameter);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__InsertAlertActionParameter, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__InsertAlertActionParameter location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__InsertAlertActionParameter(struct soap *soap, const struct ns1__InsertAlertActionParameter *a, const char *tag, const char *type)
{
	if (soap_out_ns1__InsertAlertActionParameter(soap, tag ? tag : "ns1:InsertAlertActionParameter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__InsertAlertActionParameter * SOAP_FMAC4 soap_get_ns1__InsertAlertActionParameter(struct soap *soap, struct ns1__InsertAlertActionParameter *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__InsertAlertActionParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__InsertAlertActionParameterResponse(struct soap *soap, struct ns1__InsertAlertActionParameterResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__InsertAlertActionParameterResponse(struct soap *soap, const struct ns1__InsertAlertActionParameterResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__InsertAlertActionParameterResponse(struct soap *soap, const char *tag, int id, const struct ns1__InsertAlertActionParameterResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__InsertAlertActionParameterResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__InsertAlertActionParameterResponse * SOAP_FMAC4 soap_in_ns1__InsertAlertActionParameterResponse(struct soap *soap, const char *tag, struct ns1__InsertAlertActionParameterResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__InsertAlertActionParameterResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__InsertAlertActionParameterResponse, sizeof(struct ns1__InsertAlertActionParameterResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__InsertAlertActionParameterResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__InsertAlertActionParameterResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__InsertAlertActionParameterResponse, SOAP_TYPE_ns1__InsertAlertActionParameterResponse, sizeof(struct ns1__InsertAlertActionParameterResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__InsertAlertActionParameterResponse * SOAP_FMAC2 soap_instantiate_ns1__InsertAlertActionParameterResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__InsertAlertActionParameterResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__InsertAlertActionParameterResponse *p;
	size_t k = sizeof(struct ns1__InsertAlertActionParameterResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__InsertAlertActionParameterResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__InsertAlertActionParameterResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__InsertAlertActionParameterResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__InsertAlertActionParameterResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__InsertAlertActionParameterResponse(struct soap *soap, const struct ns1__InsertAlertActionParameterResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__InsertAlertActionParameterResponse(soap, tag ? tag : "ns1:InsertAlertActionParameterResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__InsertAlertActionParameterResponse * SOAP_FMAC4 soap_get_ns1__InsertAlertActionParameterResponse(struct soap *soap, struct ns1__InsertAlertActionParameterResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__InsertAlertActionParameterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__UpdateAlertActionParameter(struct soap *soap, struct ns1__UpdateAlertActionParameter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_in0);
	soap_default_int(soap, &a->_in1);
	soap_default_SOAP_ENC__string(soap, &a->_in2);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__UpdateAlertActionParameter(struct soap *soap, const struct ns1__UpdateAlertActionParameter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->_in2, SOAP_TYPE_SOAP_ENC__string);
	soap_serialize_SOAP_ENC__string(soap, &a->_in2);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__UpdateAlertActionParameter(struct soap *soap, const char *tag, int id, const struct ns1__UpdateAlertActionParameter *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__UpdateAlertActionParameter), type))
		return soap->error;
	if (soap_out_int(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	if (soap_out_int(soap, "in1", -1, &a->_in1, ""))
		return soap->error;
	if (soap_out_SOAP_ENC__string(soap, "in2", -1, &a->_in2, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__UpdateAlertActionParameter * SOAP_FMAC4 soap_in_ns1__UpdateAlertActionParameter(struct soap *soap, const char *tag, struct ns1__UpdateAlertActionParameter *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	size_t soap_flag__in1 = 1;
	size_t soap_flag__in2 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__UpdateAlertActionParameter*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__UpdateAlertActionParameter, sizeof(struct ns1__UpdateAlertActionParameter), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns1__UpdateAlertActionParameter(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, NULL, &a->_in0, "xsd:int"))
				{	soap_flag__in0--;
					continue;
				}
			}
			if (soap_flag__in1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, NULL, &a->_in1, "xsd:int"))
				{	soap_flag__in1--;
					continue;
				}
			}
			if (soap_flag__in2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_SOAP_ENC__string(soap, NULL, &a->_in2, "SOAP-ENC:string"))
				{	soap_flag__in2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__in0 > 0 || soap_flag__in1 > 0 || soap_flag__in2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__UpdateAlertActionParameter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__UpdateAlertActionParameter, SOAP_TYPE_ns1__UpdateAlertActionParameter, sizeof(struct ns1__UpdateAlertActionParameter), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__UpdateAlertActionParameter * SOAP_FMAC2 soap_instantiate_ns1__UpdateAlertActionParameter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__UpdateAlertActionParameter(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__UpdateAlertActionParameter *p;
	size_t k = sizeof(struct ns1__UpdateAlertActionParameter);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__UpdateAlertActionParameter, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__UpdateAlertActionParameter);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__UpdateAlertActionParameter, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__UpdateAlertActionParameter location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__UpdateAlertActionParameter(struct soap *soap, const struct ns1__UpdateAlertActionParameter *a, const char *tag, const char *type)
{
	if (soap_out_ns1__UpdateAlertActionParameter(soap, tag ? tag : "ns1:UpdateAlertActionParameter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__UpdateAlertActionParameter * SOAP_FMAC4 soap_get_ns1__UpdateAlertActionParameter(struct soap *soap, struct ns1__UpdateAlertActionParameter *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__UpdateAlertActionParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__UpdateAlertActionParameterResponse(struct soap *soap, struct ns1__UpdateAlertActionParameterResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__UpdateAlertActionParameterResponse(struct soap *soap, const struct ns1__UpdateAlertActionParameterResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__UpdateAlertActionParameterResponse(struct soap *soap, const char *tag, int id, const struct ns1__UpdateAlertActionParameterResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__UpdateAlertActionParameterResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__UpdateAlertActionParameterResponse * SOAP_FMAC4 soap_in_ns1__UpdateAlertActionParameterResponse(struct soap *soap, const char *tag, struct ns1__UpdateAlertActionParameterResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__UpdateAlertActionParameterResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__UpdateAlertActionParameterResponse, sizeof(struct ns1__UpdateAlertActionParameterResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__UpdateAlertActionParameterResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__UpdateAlertActionParameterResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__UpdateAlertActionParameterResponse, SOAP_TYPE_ns1__UpdateAlertActionParameterResponse, sizeof(struct ns1__UpdateAlertActionParameterResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__UpdateAlertActionParameterResponse * SOAP_FMAC2 soap_instantiate_ns1__UpdateAlertActionParameterResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__UpdateAlertActionParameterResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__UpdateAlertActionParameterResponse *p;
	size_t k = sizeof(struct ns1__UpdateAlertActionParameterResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__UpdateAlertActionParameterResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__UpdateAlertActionParameterResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__UpdateAlertActionParameterResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__UpdateAlertActionParameterResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__UpdateAlertActionParameterResponse(struct soap *soap, const struct ns1__UpdateAlertActionParameterResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__UpdateAlertActionParameterResponse(soap, tag ? tag : "ns1:UpdateAlertActionParameterResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__UpdateAlertActionParameterResponse * SOAP_FMAC4 soap_get_ns1__UpdateAlertActionParameterResponse(struct soap *soap, struct ns1__UpdateAlertActionParameterResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__UpdateAlertActionParameterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__InsertAlertActionField(struct soap *soap, struct ns1__InsertAlertActionField *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_in0);
	soap_default_int(soap, &a->_in1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__InsertAlertActionField(struct soap *soap, const struct ns1__InsertAlertActionField *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__InsertAlertActionField(struct soap *soap, const char *tag, int id, const struct ns1__InsertAlertActionField *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__InsertAlertActionField), type))
		return soap->error;
	if (soap_out_int(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	if (soap_out_int(soap, "in1", -1, &a->_in1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__InsertAlertActionField * SOAP_FMAC4 soap_in_ns1__InsertAlertActionField(struct soap *soap, const char *tag, struct ns1__InsertAlertActionField *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	size_t soap_flag__in1 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__InsertAlertActionField*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__InsertAlertActionField, sizeof(struct ns1__InsertAlertActionField), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__InsertAlertActionField(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, NULL, &a->_in0, "xsd:int"))
				{	soap_flag__in0--;
					continue;
				}
			}
			if (soap_flag__in1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, NULL, &a->_in1, "xsd:int"))
				{	soap_flag__in1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__in0 > 0 || soap_flag__in1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__InsertAlertActionField *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__InsertAlertActionField, SOAP_TYPE_ns1__InsertAlertActionField, sizeof(struct ns1__InsertAlertActionField), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__InsertAlertActionField * SOAP_FMAC2 soap_instantiate_ns1__InsertAlertActionField(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__InsertAlertActionField(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__InsertAlertActionField *p;
	size_t k = sizeof(struct ns1__InsertAlertActionField);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__InsertAlertActionField, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__InsertAlertActionField);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__InsertAlertActionField, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__InsertAlertActionField location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__InsertAlertActionField(struct soap *soap, const struct ns1__InsertAlertActionField *a, const char *tag, const char *type)
{
	if (soap_out_ns1__InsertAlertActionField(soap, tag ? tag : "ns1:InsertAlertActionField", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__InsertAlertActionField * SOAP_FMAC4 soap_get_ns1__InsertAlertActionField(struct soap *soap, struct ns1__InsertAlertActionField *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__InsertAlertActionField(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__InsertAlertActionFieldResponse(struct soap *soap, struct ns1__InsertAlertActionFieldResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__InsertAlertActionFieldResponse(struct soap *soap, const struct ns1__InsertAlertActionFieldResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__InsertAlertActionFieldResponse(struct soap *soap, const char *tag, int id, const struct ns1__InsertAlertActionFieldResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__InsertAlertActionFieldResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__InsertAlertActionFieldResponse * SOAP_FMAC4 soap_in_ns1__InsertAlertActionFieldResponse(struct soap *soap, const char *tag, struct ns1__InsertAlertActionFieldResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__InsertAlertActionFieldResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__InsertAlertActionFieldResponse, sizeof(struct ns1__InsertAlertActionFieldResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__InsertAlertActionFieldResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__InsertAlertActionFieldResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__InsertAlertActionFieldResponse, SOAP_TYPE_ns1__InsertAlertActionFieldResponse, sizeof(struct ns1__InsertAlertActionFieldResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__InsertAlertActionFieldResponse * SOAP_FMAC2 soap_instantiate_ns1__InsertAlertActionFieldResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__InsertAlertActionFieldResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__InsertAlertActionFieldResponse *p;
	size_t k = sizeof(struct ns1__InsertAlertActionFieldResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__InsertAlertActionFieldResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__InsertAlertActionFieldResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__InsertAlertActionFieldResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__InsertAlertActionFieldResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__InsertAlertActionFieldResponse(struct soap *soap, const struct ns1__InsertAlertActionFieldResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__InsertAlertActionFieldResponse(soap, tag ? tag : "ns1:InsertAlertActionFieldResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__InsertAlertActionFieldResponse * SOAP_FMAC4 soap_get_ns1__InsertAlertActionFieldResponse(struct soap *soap, struct ns1__InsertAlertActionFieldResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__InsertAlertActionFieldResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__UpdateAlertActionField(struct soap *soap, struct ns1__UpdateAlertActionField *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_in0);
	soap_default_int(soap, &a->_in1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__UpdateAlertActionField(struct soap *soap, const struct ns1__UpdateAlertActionField *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__UpdateAlertActionField(struct soap *soap, const char *tag, int id, const struct ns1__UpdateAlertActionField *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__UpdateAlertActionField), type))
		return soap->error;
	if (soap_out_int(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	if (soap_out_int(soap, "in1", -1, &a->_in1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__UpdateAlertActionField * SOAP_FMAC4 soap_in_ns1__UpdateAlertActionField(struct soap *soap, const char *tag, struct ns1__UpdateAlertActionField *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	size_t soap_flag__in1 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__UpdateAlertActionField*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__UpdateAlertActionField, sizeof(struct ns1__UpdateAlertActionField), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__UpdateAlertActionField(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, NULL, &a->_in0, "xsd:int"))
				{	soap_flag__in0--;
					continue;
				}
			}
			if (soap_flag__in1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, NULL, &a->_in1, "xsd:int"))
				{	soap_flag__in1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__in0 > 0 || soap_flag__in1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__UpdateAlertActionField *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__UpdateAlertActionField, SOAP_TYPE_ns1__UpdateAlertActionField, sizeof(struct ns1__UpdateAlertActionField), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__UpdateAlertActionField * SOAP_FMAC2 soap_instantiate_ns1__UpdateAlertActionField(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__UpdateAlertActionField(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__UpdateAlertActionField *p;
	size_t k = sizeof(struct ns1__UpdateAlertActionField);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__UpdateAlertActionField, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__UpdateAlertActionField);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__UpdateAlertActionField, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__UpdateAlertActionField location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__UpdateAlertActionField(struct soap *soap, const struct ns1__UpdateAlertActionField *a, const char *tag, const char *type)
{
	if (soap_out_ns1__UpdateAlertActionField(soap, tag ? tag : "ns1:UpdateAlertActionField", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__UpdateAlertActionField * SOAP_FMAC4 soap_get_ns1__UpdateAlertActionField(struct soap *soap, struct ns1__UpdateAlertActionField *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__UpdateAlertActionField(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__UpdateAlertActionFieldResponse(struct soap *soap, struct ns1__UpdateAlertActionFieldResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__UpdateAlertActionFieldResponse(struct soap *soap, const struct ns1__UpdateAlertActionFieldResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__UpdateAlertActionFieldResponse(struct soap *soap, const char *tag, int id, const struct ns1__UpdateAlertActionFieldResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__UpdateAlertActionFieldResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__UpdateAlertActionFieldResponse * SOAP_FMAC4 soap_in_ns1__UpdateAlertActionFieldResponse(struct soap *soap, const char *tag, struct ns1__UpdateAlertActionFieldResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__UpdateAlertActionFieldResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__UpdateAlertActionFieldResponse, sizeof(struct ns1__UpdateAlertActionFieldResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__UpdateAlertActionFieldResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__UpdateAlertActionFieldResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__UpdateAlertActionFieldResponse, SOAP_TYPE_ns1__UpdateAlertActionFieldResponse, sizeof(struct ns1__UpdateAlertActionFieldResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__UpdateAlertActionFieldResponse * SOAP_FMAC2 soap_instantiate_ns1__UpdateAlertActionFieldResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__UpdateAlertActionFieldResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__UpdateAlertActionFieldResponse *p;
	size_t k = sizeof(struct ns1__UpdateAlertActionFieldResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__UpdateAlertActionFieldResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__UpdateAlertActionFieldResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__UpdateAlertActionFieldResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__UpdateAlertActionFieldResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__UpdateAlertActionFieldResponse(struct soap *soap, const struct ns1__UpdateAlertActionFieldResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__UpdateAlertActionFieldResponse(soap, tag ? tag : "ns1:UpdateAlertActionFieldResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__UpdateAlertActionFieldResponse * SOAP_FMAC4 soap_get_ns1__UpdateAlertActionFieldResponse(struct soap *soap, struct ns1__UpdateAlertActionFieldResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__UpdateAlertActionFieldResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetAlertsRecord(struct soap *soap, struct ns1__GetAlertsRecord *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetAlertsRecord(struct soap *soap, const struct ns1__GetAlertsRecord *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetAlertsRecord(struct soap *soap, const char *tag, int id, const struct ns1__GetAlertsRecord *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetAlertsRecord), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetAlertsRecord * SOAP_FMAC4 soap_in_ns1__GetAlertsRecord(struct soap *soap, const char *tag, struct ns1__GetAlertsRecord *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetAlertsRecord*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetAlertsRecord, sizeof(struct ns1__GetAlertsRecord), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__GetAlertsRecord(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__GetAlertsRecord *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetAlertsRecord, SOAP_TYPE_ns1__GetAlertsRecord, sizeof(struct ns1__GetAlertsRecord), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__GetAlertsRecord * SOAP_FMAC2 soap_instantiate_ns1__GetAlertsRecord(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetAlertsRecord(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__GetAlertsRecord *p;
	size_t k = sizeof(struct ns1__GetAlertsRecord);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GetAlertsRecord, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__GetAlertsRecord);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__GetAlertsRecord, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__GetAlertsRecord location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetAlertsRecord(struct soap *soap, const struct ns1__GetAlertsRecord *a, const char *tag, const char *type)
{
	if (soap_out_ns1__GetAlertsRecord(soap, tag ? tag : "ns1:GetAlertsRecord", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetAlertsRecord * SOAP_FMAC4 soap_get_ns1__GetAlertsRecord(struct soap *soap, struct ns1__GetAlertsRecord *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetAlertsRecord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetAlertsRecordResponse(struct soap *soap, struct ns1__GetAlertsRecordResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_SOAP_ENC__string(soap, &a->GetAlertsRecordReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetAlertsRecordResponse(struct soap *soap, const struct ns1__GetAlertsRecordResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->GetAlertsRecordReturn, SOAP_TYPE_SOAP_ENC__string);
	soap_serialize_SOAP_ENC__string(soap, &a->GetAlertsRecordReturn);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetAlertsRecordResponse(struct soap *soap, const char *tag, int id, const struct ns1__GetAlertsRecordResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetAlertsRecordResponse), type))
		return soap->error;
	if (soap_out_SOAP_ENC__string(soap, "GetAlertsRecordReturn", -1, &a->GetAlertsRecordReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetAlertsRecordResponse * SOAP_FMAC4 soap_in_ns1__GetAlertsRecordResponse(struct soap *soap, const char *tag, struct ns1__GetAlertsRecordResponse *a, const char *type)
{
	size_t soap_flag_GetAlertsRecordReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetAlertsRecordResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetAlertsRecordResponse, sizeof(struct ns1__GetAlertsRecordResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns1__GetAlertsRecordResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetAlertsRecordReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_SOAP_ENC__string(soap, "GetAlertsRecordReturn", &a->GetAlertsRecordReturn, "SOAP-ENC:string"))
				{	soap_flag_GetAlertsRecordReturn--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_GetAlertsRecordReturn > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__GetAlertsRecordResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetAlertsRecordResponse, SOAP_TYPE_ns1__GetAlertsRecordResponse, sizeof(struct ns1__GetAlertsRecordResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__GetAlertsRecordResponse * SOAP_FMAC2 soap_instantiate_ns1__GetAlertsRecordResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetAlertsRecordResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__GetAlertsRecordResponse *p;
	size_t k = sizeof(struct ns1__GetAlertsRecordResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GetAlertsRecordResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__GetAlertsRecordResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__GetAlertsRecordResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__GetAlertsRecordResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetAlertsRecordResponse(struct soap *soap, const struct ns1__GetAlertsRecordResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__GetAlertsRecordResponse(soap, tag ? tag : "ns1:GetAlertsRecordResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetAlertsRecordResponse * SOAP_FMAC4 soap_get_ns1__GetAlertsRecordResponse(struct soap *soap, struct ns1__GetAlertsRecordResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetAlertsRecordResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetAlertsRecordByDocumentType(struct soap *soap, struct ns1__GetAlertsRecordByDocumentType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetAlertsRecordByDocumentType(struct soap *soap, const struct ns1__GetAlertsRecordByDocumentType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetAlertsRecordByDocumentType(struct soap *soap, const char *tag, int id, const struct ns1__GetAlertsRecordByDocumentType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetAlertsRecordByDocumentType), type))
		return soap->error;
	if (soap_out_int(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetAlertsRecordByDocumentType * SOAP_FMAC4 soap_in_ns1__GetAlertsRecordByDocumentType(struct soap *soap, const char *tag, struct ns1__GetAlertsRecordByDocumentType *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetAlertsRecordByDocumentType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetAlertsRecordByDocumentType, sizeof(struct ns1__GetAlertsRecordByDocumentType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__GetAlertsRecordByDocumentType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, NULL, &a->_in0, "xsd:int"))
				{	soap_flag__in0--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__in0 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__GetAlertsRecordByDocumentType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetAlertsRecordByDocumentType, SOAP_TYPE_ns1__GetAlertsRecordByDocumentType, sizeof(struct ns1__GetAlertsRecordByDocumentType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__GetAlertsRecordByDocumentType * SOAP_FMAC2 soap_instantiate_ns1__GetAlertsRecordByDocumentType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetAlertsRecordByDocumentType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__GetAlertsRecordByDocumentType *p;
	size_t k = sizeof(struct ns1__GetAlertsRecordByDocumentType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GetAlertsRecordByDocumentType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__GetAlertsRecordByDocumentType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__GetAlertsRecordByDocumentType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__GetAlertsRecordByDocumentType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetAlertsRecordByDocumentType(struct soap *soap, const struct ns1__GetAlertsRecordByDocumentType *a, const char *tag, const char *type)
{
	if (soap_out_ns1__GetAlertsRecordByDocumentType(soap, tag ? tag : "ns1:GetAlertsRecordByDocumentType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetAlertsRecordByDocumentType * SOAP_FMAC4 soap_get_ns1__GetAlertsRecordByDocumentType(struct soap *soap, struct ns1__GetAlertsRecordByDocumentType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetAlertsRecordByDocumentType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetAlertsRecordByDocumentTypeResponse(struct soap *soap, struct ns1__GetAlertsRecordByDocumentTypeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_SOAP_ENC__string(soap, &a->_GetAlertsRecordByDocumentTypeReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetAlertsRecordByDocumentTypeResponse(struct soap *soap, const struct ns1__GetAlertsRecordByDocumentTypeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->_GetAlertsRecordByDocumentTypeReturn, SOAP_TYPE_SOAP_ENC__string);
	soap_serialize_SOAP_ENC__string(soap, &a->_GetAlertsRecordByDocumentTypeReturn);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetAlertsRecordByDocumentTypeResponse(struct soap *soap, const char *tag, int id, const struct ns1__GetAlertsRecordByDocumentTypeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetAlertsRecordByDocumentTypeResponse), type))
		return soap->error;
	if (soap_out_SOAP_ENC__string(soap, "GetAlertsRecordByDocumentTypeReturn", -1, &a->_GetAlertsRecordByDocumentTypeReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetAlertsRecordByDocumentTypeResponse * SOAP_FMAC4 soap_in_ns1__GetAlertsRecordByDocumentTypeResponse(struct soap *soap, const char *tag, struct ns1__GetAlertsRecordByDocumentTypeResponse *a, const char *type)
{
	size_t soap_flag__GetAlertsRecordByDocumentTypeReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetAlertsRecordByDocumentTypeResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetAlertsRecordByDocumentTypeResponse, sizeof(struct ns1__GetAlertsRecordByDocumentTypeResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns1__GetAlertsRecordByDocumentTypeResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__GetAlertsRecordByDocumentTypeReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_SOAP_ENC__string(soap, NULL, &a->_GetAlertsRecordByDocumentTypeReturn, "SOAP-ENC:string"))
				{	soap_flag__GetAlertsRecordByDocumentTypeReturn--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__GetAlertsRecordByDocumentTypeReturn > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__GetAlertsRecordByDocumentTypeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetAlertsRecordByDocumentTypeResponse, SOAP_TYPE_ns1__GetAlertsRecordByDocumentTypeResponse, sizeof(struct ns1__GetAlertsRecordByDocumentTypeResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__GetAlertsRecordByDocumentTypeResponse * SOAP_FMAC2 soap_instantiate_ns1__GetAlertsRecordByDocumentTypeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetAlertsRecordByDocumentTypeResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__GetAlertsRecordByDocumentTypeResponse *p;
	size_t k = sizeof(struct ns1__GetAlertsRecordByDocumentTypeResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GetAlertsRecordByDocumentTypeResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__GetAlertsRecordByDocumentTypeResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__GetAlertsRecordByDocumentTypeResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__GetAlertsRecordByDocumentTypeResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetAlertsRecordByDocumentTypeResponse(struct soap *soap, const struct ns1__GetAlertsRecordByDocumentTypeResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__GetAlertsRecordByDocumentTypeResponse(soap, tag ? tag : "ns1:GetAlertsRecordByDocumentTypeResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetAlertsRecordByDocumentTypeResponse * SOAP_FMAC4 soap_get_ns1__GetAlertsRecordByDocumentTypeResponse(struct soap *soap, struct ns1__GetAlertsRecordByDocumentTypeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetAlertsRecordByDocumentTypeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetAlertEvaluationsRecord(struct soap *soap, struct ns1__GetAlertEvaluationsRecord *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetAlertEvaluationsRecord(struct soap *soap, const struct ns1__GetAlertEvaluationsRecord *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetAlertEvaluationsRecord(struct soap *soap, const char *tag, int id, const struct ns1__GetAlertEvaluationsRecord *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetAlertEvaluationsRecord), type))
		return soap->error;
	if (soap_out_int(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetAlertEvaluationsRecord * SOAP_FMAC4 soap_in_ns1__GetAlertEvaluationsRecord(struct soap *soap, const char *tag, struct ns1__GetAlertEvaluationsRecord *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetAlertEvaluationsRecord*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetAlertEvaluationsRecord, sizeof(struct ns1__GetAlertEvaluationsRecord), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__GetAlertEvaluationsRecord(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, NULL, &a->_in0, "xsd:int"))
				{	soap_flag__in0--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__in0 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__GetAlertEvaluationsRecord *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetAlertEvaluationsRecord, SOAP_TYPE_ns1__GetAlertEvaluationsRecord, sizeof(struct ns1__GetAlertEvaluationsRecord), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__GetAlertEvaluationsRecord * SOAP_FMAC2 soap_instantiate_ns1__GetAlertEvaluationsRecord(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetAlertEvaluationsRecord(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__GetAlertEvaluationsRecord *p;
	size_t k = sizeof(struct ns1__GetAlertEvaluationsRecord);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GetAlertEvaluationsRecord, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__GetAlertEvaluationsRecord);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__GetAlertEvaluationsRecord, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__GetAlertEvaluationsRecord location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetAlertEvaluationsRecord(struct soap *soap, const struct ns1__GetAlertEvaluationsRecord *a, const char *tag, const char *type)
{
	if (soap_out_ns1__GetAlertEvaluationsRecord(soap, tag ? tag : "ns1:GetAlertEvaluationsRecord", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetAlertEvaluationsRecord * SOAP_FMAC4 soap_get_ns1__GetAlertEvaluationsRecord(struct soap *soap, struct ns1__GetAlertEvaluationsRecord *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetAlertEvaluationsRecord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetAlertEvaluationsRecordResponse(struct soap *soap, struct ns1__GetAlertEvaluationsRecordResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_SOAP_ENC__string(soap, &a->_GetAlertEvaluationsRecordReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetAlertEvaluationsRecordResponse(struct soap *soap, const struct ns1__GetAlertEvaluationsRecordResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->_GetAlertEvaluationsRecordReturn, SOAP_TYPE_SOAP_ENC__string);
	soap_serialize_SOAP_ENC__string(soap, &a->_GetAlertEvaluationsRecordReturn);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetAlertEvaluationsRecordResponse(struct soap *soap, const char *tag, int id, const struct ns1__GetAlertEvaluationsRecordResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetAlertEvaluationsRecordResponse), type))
		return soap->error;
	if (soap_out_SOAP_ENC__string(soap, "GetAlertEvaluationsRecordReturn", -1, &a->_GetAlertEvaluationsRecordReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetAlertEvaluationsRecordResponse * SOAP_FMAC4 soap_in_ns1__GetAlertEvaluationsRecordResponse(struct soap *soap, const char *tag, struct ns1__GetAlertEvaluationsRecordResponse *a, const char *type)
{
	size_t soap_flag__GetAlertEvaluationsRecordReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetAlertEvaluationsRecordResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetAlertEvaluationsRecordResponse, sizeof(struct ns1__GetAlertEvaluationsRecordResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns1__GetAlertEvaluationsRecordResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__GetAlertEvaluationsRecordReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_SOAP_ENC__string(soap, NULL, &a->_GetAlertEvaluationsRecordReturn, "SOAP-ENC:string"))
				{	soap_flag__GetAlertEvaluationsRecordReturn--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__GetAlertEvaluationsRecordReturn > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__GetAlertEvaluationsRecordResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetAlertEvaluationsRecordResponse, SOAP_TYPE_ns1__GetAlertEvaluationsRecordResponse, sizeof(struct ns1__GetAlertEvaluationsRecordResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__GetAlertEvaluationsRecordResponse * SOAP_FMAC2 soap_instantiate_ns1__GetAlertEvaluationsRecordResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetAlertEvaluationsRecordResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__GetAlertEvaluationsRecordResponse *p;
	size_t k = sizeof(struct ns1__GetAlertEvaluationsRecordResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GetAlertEvaluationsRecordResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__GetAlertEvaluationsRecordResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__GetAlertEvaluationsRecordResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__GetAlertEvaluationsRecordResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetAlertEvaluationsRecordResponse(struct soap *soap, const struct ns1__GetAlertEvaluationsRecordResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__GetAlertEvaluationsRecordResponse(soap, tag ? tag : "ns1:GetAlertEvaluationsRecordResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetAlertEvaluationsRecordResponse * SOAP_FMAC4 soap_get_ns1__GetAlertEvaluationsRecordResponse(struct soap *soap, struct ns1__GetAlertEvaluationsRecordResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetAlertEvaluationsRecordResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetAlertActionsRecord(struct soap *soap, struct ns1__GetAlertActionsRecord *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetAlertActionsRecord(struct soap *soap, const struct ns1__GetAlertActionsRecord *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetAlertActionsRecord(struct soap *soap, const char *tag, int id, const struct ns1__GetAlertActionsRecord *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetAlertActionsRecord), type))
		return soap->error;
	if (soap_out_int(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetAlertActionsRecord * SOAP_FMAC4 soap_in_ns1__GetAlertActionsRecord(struct soap *soap, const char *tag, struct ns1__GetAlertActionsRecord *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetAlertActionsRecord*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetAlertActionsRecord, sizeof(struct ns1__GetAlertActionsRecord), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__GetAlertActionsRecord(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, NULL, &a->_in0, "xsd:int"))
				{	soap_flag__in0--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__in0 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__GetAlertActionsRecord *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetAlertActionsRecord, SOAP_TYPE_ns1__GetAlertActionsRecord, sizeof(struct ns1__GetAlertActionsRecord), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__GetAlertActionsRecord * SOAP_FMAC2 soap_instantiate_ns1__GetAlertActionsRecord(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetAlertActionsRecord(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__GetAlertActionsRecord *p;
	size_t k = sizeof(struct ns1__GetAlertActionsRecord);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GetAlertActionsRecord, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__GetAlertActionsRecord);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__GetAlertActionsRecord, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__GetAlertActionsRecord location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetAlertActionsRecord(struct soap *soap, const struct ns1__GetAlertActionsRecord *a, const char *tag, const char *type)
{
	if (soap_out_ns1__GetAlertActionsRecord(soap, tag ? tag : "ns1:GetAlertActionsRecord", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetAlertActionsRecord * SOAP_FMAC4 soap_get_ns1__GetAlertActionsRecord(struct soap *soap, struct ns1__GetAlertActionsRecord *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetAlertActionsRecord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetAlertActionsRecordResponse(struct soap *soap, struct ns1__GetAlertActionsRecordResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_SOAP_ENC__string(soap, &a->_GetAlertActionsRecordReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetAlertActionsRecordResponse(struct soap *soap, const struct ns1__GetAlertActionsRecordResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->_GetAlertActionsRecordReturn, SOAP_TYPE_SOAP_ENC__string);
	soap_serialize_SOAP_ENC__string(soap, &a->_GetAlertActionsRecordReturn);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetAlertActionsRecordResponse(struct soap *soap, const char *tag, int id, const struct ns1__GetAlertActionsRecordResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetAlertActionsRecordResponse), type))
		return soap->error;
	if (soap_out_SOAP_ENC__string(soap, "GetAlertActionsRecordReturn", -1, &a->_GetAlertActionsRecordReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetAlertActionsRecordResponse * SOAP_FMAC4 soap_in_ns1__GetAlertActionsRecordResponse(struct soap *soap, const char *tag, struct ns1__GetAlertActionsRecordResponse *a, const char *type)
{
	size_t soap_flag__GetAlertActionsRecordReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetAlertActionsRecordResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetAlertActionsRecordResponse, sizeof(struct ns1__GetAlertActionsRecordResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns1__GetAlertActionsRecordResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__GetAlertActionsRecordReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_SOAP_ENC__string(soap, NULL, &a->_GetAlertActionsRecordReturn, "SOAP-ENC:string"))
				{	soap_flag__GetAlertActionsRecordReturn--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__GetAlertActionsRecordReturn > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__GetAlertActionsRecordResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetAlertActionsRecordResponse, SOAP_TYPE_ns1__GetAlertActionsRecordResponse, sizeof(struct ns1__GetAlertActionsRecordResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__GetAlertActionsRecordResponse * SOAP_FMAC2 soap_instantiate_ns1__GetAlertActionsRecordResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetAlertActionsRecordResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__GetAlertActionsRecordResponse *p;
	size_t k = sizeof(struct ns1__GetAlertActionsRecordResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GetAlertActionsRecordResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__GetAlertActionsRecordResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__GetAlertActionsRecordResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__GetAlertActionsRecordResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetAlertActionsRecordResponse(struct soap *soap, const struct ns1__GetAlertActionsRecordResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__GetAlertActionsRecordResponse(soap, tag ? tag : "ns1:GetAlertActionsRecordResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetAlertActionsRecordResponse * SOAP_FMAC4 soap_get_ns1__GetAlertActionsRecordResponse(struct soap *soap, struct ns1__GetAlertActionsRecordResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetAlertActionsRecordResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetAlertSchedulesRecord(struct soap *soap, struct ns1__GetAlertSchedulesRecord *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetAlertSchedulesRecord(struct soap *soap, const struct ns1__GetAlertSchedulesRecord *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetAlertSchedulesRecord(struct soap *soap, const char *tag, int id, const struct ns1__GetAlertSchedulesRecord *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetAlertSchedulesRecord), type))
		return soap->error;
	if (soap_out_int(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetAlertSchedulesRecord * SOAP_FMAC4 soap_in_ns1__GetAlertSchedulesRecord(struct soap *soap, const char *tag, struct ns1__GetAlertSchedulesRecord *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetAlertSchedulesRecord*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetAlertSchedulesRecord, sizeof(struct ns1__GetAlertSchedulesRecord), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__GetAlertSchedulesRecord(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, NULL, &a->_in0, "xsd:int"))
				{	soap_flag__in0--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__in0 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__GetAlertSchedulesRecord *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetAlertSchedulesRecord, SOAP_TYPE_ns1__GetAlertSchedulesRecord, sizeof(struct ns1__GetAlertSchedulesRecord), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__GetAlertSchedulesRecord * SOAP_FMAC2 soap_instantiate_ns1__GetAlertSchedulesRecord(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetAlertSchedulesRecord(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__GetAlertSchedulesRecord *p;
	size_t k = sizeof(struct ns1__GetAlertSchedulesRecord);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GetAlertSchedulesRecord, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__GetAlertSchedulesRecord);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__GetAlertSchedulesRecord, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__GetAlertSchedulesRecord location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetAlertSchedulesRecord(struct soap *soap, const struct ns1__GetAlertSchedulesRecord *a, const char *tag, const char *type)
{
	if (soap_out_ns1__GetAlertSchedulesRecord(soap, tag ? tag : "ns1:GetAlertSchedulesRecord", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetAlertSchedulesRecord * SOAP_FMAC4 soap_get_ns1__GetAlertSchedulesRecord(struct soap *soap, struct ns1__GetAlertSchedulesRecord *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetAlertSchedulesRecord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetAlertSchedulesRecordResponse(struct soap *soap, struct ns1__GetAlertSchedulesRecordResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_SOAP_ENC__string(soap, &a->_GetAlertSchedulesRecordReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetAlertSchedulesRecordResponse(struct soap *soap, const struct ns1__GetAlertSchedulesRecordResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->_GetAlertSchedulesRecordReturn, SOAP_TYPE_SOAP_ENC__string);
	soap_serialize_SOAP_ENC__string(soap, &a->_GetAlertSchedulesRecordReturn);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetAlertSchedulesRecordResponse(struct soap *soap, const char *tag, int id, const struct ns1__GetAlertSchedulesRecordResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetAlertSchedulesRecordResponse), type))
		return soap->error;
	if (soap_out_SOAP_ENC__string(soap, "GetAlertSchedulesRecordReturn", -1, &a->_GetAlertSchedulesRecordReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetAlertSchedulesRecordResponse * SOAP_FMAC4 soap_in_ns1__GetAlertSchedulesRecordResponse(struct soap *soap, const char *tag, struct ns1__GetAlertSchedulesRecordResponse *a, const char *type)
{
	size_t soap_flag__GetAlertSchedulesRecordReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetAlertSchedulesRecordResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetAlertSchedulesRecordResponse, sizeof(struct ns1__GetAlertSchedulesRecordResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns1__GetAlertSchedulesRecordResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__GetAlertSchedulesRecordReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_SOAP_ENC__string(soap, NULL, &a->_GetAlertSchedulesRecordReturn, "SOAP-ENC:string"))
				{	soap_flag__GetAlertSchedulesRecordReturn--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__GetAlertSchedulesRecordReturn > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__GetAlertSchedulesRecordResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetAlertSchedulesRecordResponse, SOAP_TYPE_ns1__GetAlertSchedulesRecordResponse, sizeof(struct ns1__GetAlertSchedulesRecordResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__GetAlertSchedulesRecordResponse * SOAP_FMAC2 soap_instantiate_ns1__GetAlertSchedulesRecordResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetAlertSchedulesRecordResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__GetAlertSchedulesRecordResponse *p;
	size_t k = sizeof(struct ns1__GetAlertSchedulesRecordResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GetAlertSchedulesRecordResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__GetAlertSchedulesRecordResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__GetAlertSchedulesRecordResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__GetAlertSchedulesRecordResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetAlertSchedulesRecordResponse(struct soap *soap, const struct ns1__GetAlertSchedulesRecordResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__GetAlertSchedulesRecordResponse(soap, tag ? tag : "ns1:GetAlertSchedulesRecordResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetAlertSchedulesRecordResponse * SOAP_FMAC4 soap_get_ns1__GetAlertSchedulesRecordResponse(struct soap *soap, struct ns1__GetAlertSchedulesRecordResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetAlertSchedulesRecordResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetAlertActionParameterRecord(struct soap *soap, struct ns1__GetAlertActionParameterRecord *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetAlertActionParameterRecord(struct soap *soap, const struct ns1__GetAlertActionParameterRecord *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetAlertActionParameterRecord(struct soap *soap, const char *tag, int id, const struct ns1__GetAlertActionParameterRecord *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetAlertActionParameterRecord), type))
		return soap->error;
	if (soap_out_int(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetAlertActionParameterRecord * SOAP_FMAC4 soap_in_ns1__GetAlertActionParameterRecord(struct soap *soap, const char *tag, struct ns1__GetAlertActionParameterRecord *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetAlertActionParameterRecord*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetAlertActionParameterRecord, sizeof(struct ns1__GetAlertActionParameterRecord), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__GetAlertActionParameterRecord(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, NULL, &a->_in0, "xsd:int"))
				{	soap_flag__in0--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__in0 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__GetAlertActionParameterRecord *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetAlertActionParameterRecord, SOAP_TYPE_ns1__GetAlertActionParameterRecord, sizeof(struct ns1__GetAlertActionParameterRecord), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__GetAlertActionParameterRecord * SOAP_FMAC2 soap_instantiate_ns1__GetAlertActionParameterRecord(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetAlertActionParameterRecord(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__GetAlertActionParameterRecord *p;
	size_t k = sizeof(struct ns1__GetAlertActionParameterRecord);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GetAlertActionParameterRecord, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__GetAlertActionParameterRecord);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__GetAlertActionParameterRecord, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__GetAlertActionParameterRecord location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetAlertActionParameterRecord(struct soap *soap, const struct ns1__GetAlertActionParameterRecord *a, const char *tag, const char *type)
{
	if (soap_out_ns1__GetAlertActionParameterRecord(soap, tag ? tag : "ns1:GetAlertActionParameterRecord", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetAlertActionParameterRecord * SOAP_FMAC4 soap_get_ns1__GetAlertActionParameterRecord(struct soap *soap, struct ns1__GetAlertActionParameterRecord *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetAlertActionParameterRecord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetAlertActionParameterRecordResponse(struct soap *soap, struct ns1__GetAlertActionParameterRecordResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_SOAP_ENC__string(soap, &a->_GetAlertActionParameterRecordReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetAlertActionParameterRecordResponse(struct soap *soap, const struct ns1__GetAlertActionParameterRecordResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->_GetAlertActionParameterRecordReturn, SOAP_TYPE_SOAP_ENC__string);
	soap_serialize_SOAP_ENC__string(soap, &a->_GetAlertActionParameterRecordReturn);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetAlertActionParameterRecordResponse(struct soap *soap, const char *tag, int id, const struct ns1__GetAlertActionParameterRecordResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetAlertActionParameterRecordResponse), type))
		return soap->error;
	if (soap_out_SOAP_ENC__string(soap, "GetAlertActionParameterRecordReturn", -1, &a->_GetAlertActionParameterRecordReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetAlertActionParameterRecordResponse * SOAP_FMAC4 soap_in_ns1__GetAlertActionParameterRecordResponse(struct soap *soap, const char *tag, struct ns1__GetAlertActionParameterRecordResponse *a, const char *type)
{
	size_t soap_flag__GetAlertActionParameterRecordReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetAlertActionParameterRecordResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetAlertActionParameterRecordResponse, sizeof(struct ns1__GetAlertActionParameterRecordResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns1__GetAlertActionParameterRecordResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__GetAlertActionParameterRecordReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_SOAP_ENC__string(soap, NULL, &a->_GetAlertActionParameterRecordReturn, "SOAP-ENC:string"))
				{	soap_flag__GetAlertActionParameterRecordReturn--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__GetAlertActionParameterRecordReturn > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__GetAlertActionParameterRecordResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetAlertActionParameterRecordResponse, SOAP_TYPE_ns1__GetAlertActionParameterRecordResponse, sizeof(struct ns1__GetAlertActionParameterRecordResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__GetAlertActionParameterRecordResponse * SOAP_FMAC2 soap_instantiate_ns1__GetAlertActionParameterRecordResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetAlertActionParameterRecordResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__GetAlertActionParameterRecordResponse *p;
	size_t k = sizeof(struct ns1__GetAlertActionParameterRecordResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GetAlertActionParameterRecordResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__GetAlertActionParameterRecordResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__GetAlertActionParameterRecordResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__GetAlertActionParameterRecordResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetAlertActionParameterRecordResponse(struct soap *soap, const struct ns1__GetAlertActionParameterRecordResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__GetAlertActionParameterRecordResponse(soap, tag ? tag : "ns1:GetAlertActionParameterRecordResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetAlertActionParameterRecordResponse * SOAP_FMAC4 soap_get_ns1__GetAlertActionParameterRecordResponse(struct soap *soap, struct ns1__GetAlertActionParameterRecordResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetAlertActionParameterRecordResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetAlertActionFieldsRecord(struct soap *soap, struct ns1__GetAlertActionFieldsRecord *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetAlertActionFieldsRecord(struct soap *soap, const struct ns1__GetAlertActionFieldsRecord *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetAlertActionFieldsRecord(struct soap *soap, const char *tag, int id, const struct ns1__GetAlertActionFieldsRecord *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetAlertActionFieldsRecord), type))
		return soap->error;
	if (soap_out_int(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetAlertActionFieldsRecord * SOAP_FMAC4 soap_in_ns1__GetAlertActionFieldsRecord(struct soap *soap, const char *tag, struct ns1__GetAlertActionFieldsRecord *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetAlertActionFieldsRecord*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetAlertActionFieldsRecord, sizeof(struct ns1__GetAlertActionFieldsRecord), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__GetAlertActionFieldsRecord(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, NULL, &a->_in0, "xsd:int"))
				{	soap_flag__in0--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__in0 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__GetAlertActionFieldsRecord *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetAlertActionFieldsRecord, SOAP_TYPE_ns1__GetAlertActionFieldsRecord, sizeof(struct ns1__GetAlertActionFieldsRecord), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__GetAlertActionFieldsRecord * SOAP_FMAC2 soap_instantiate_ns1__GetAlertActionFieldsRecord(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetAlertActionFieldsRecord(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__GetAlertActionFieldsRecord *p;
	size_t k = sizeof(struct ns1__GetAlertActionFieldsRecord);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GetAlertActionFieldsRecord, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__GetAlertActionFieldsRecord);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__GetAlertActionFieldsRecord, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__GetAlertActionFieldsRecord location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetAlertActionFieldsRecord(struct soap *soap, const struct ns1__GetAlertActionFieldsRecord *a, const char *tag, const char *type)
{
	if (soap_out_ns1__GetAlertActionFieldsRecord(soap, tag ? tag : "ns1:GetAlertActionFieldsRecord", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetAlertActionFieldsRecord * SOAP_FMAC4 soap_get_ns1__GetAlertActionFieldsRecord(struct soap *soap, struct ns1__GetAlertActionFieldsRecord *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetAlertActionFieldsRecord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetAlertActionFieldsRecordResponse(struct soap *soap, struct ns1__GetAlertActionFieldsRecordResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_SOAP_ENC__string(soap, &a->_GetAlertActionFieldsRecordReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetAlertActionFieldsRecordResponse(struct soap *soap, const struct ns1__GetAlertActionFieldsRecordResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->_GetAlertActionFieldsRecordReturn, SOAP_TYPE_SOAP_ENC__string);
	soap_serialize_SOAP_ENC__string(soap, &a->_GetAlertActionFieldsRecordReturn);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetAlertActionFieldsRecordResponse(struct soap *soap, const char *tag, int id, const struct ns1__GetAlertActionFieldsRecordResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetAlertActionFieldsRecordResponse), type))
		return soap->error;
	if (soap_out_SOAP_ENC__string(soap, "GetAlertActionFieldsRecordReturn", -1, &a->_GetAlertActionFieldsRecordReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetAlertActionFieldsRecordResponse * SOAP_FMAC4 soap_in_ns1__GetAlertActionFieldsRecordResponse(struct soap *soap, const char *tag, struct ns1__GetAlertActionFieldsRecordResponse *a, const char *type)
{
	size_t soap_flag__GetAlertActionFieldsRecordReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetAlertActionFieldsRecordResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetAlertActionFieldsRecordResponse, sizeof(struct ns1__GetAlertActionFieldsRecordResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns1__GetAlertActionFieldsRecordResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__GetAlertActionFieldsRecordReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_SOAP_ENC__string(soap, NULL, &a->_GetAlertActionFieldsRecordReturn, "SOAP-ENC:string"))
				{	soap_flag__GetAlertActionFieldsRecordReturn--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__GetAlertActionFieldsRecordReturn > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__GetAlertActionFieldsRecordResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetAlertActionFieldsRecordResponse, SOAP_TYPE_ns1__GetAlertActionFieldsRecordResponse, sizeof(struct ns1__GetAlertActionFieldsRecordResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__GetAlertActionFieldsRecordResponse * SOAP_FMAC2 soap_instantiate_ns1__GetAlertActionFieldsRecordResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetAlertActionFieldsRecordResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__GetAlertActionFieldsRecordResponse *p;
	size_t k = sizeof(struct ns1__GetAlertActionFieldsRecordResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GetAlertActionFieldsRecordResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__GetAlertActionFieldsRecordResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__GetAlertActionFieldsRecordResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__GetAlertActionFieldsRecordResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetAlertActionFieldsRecordResponse(struct soap *soap, const struct ns1__GetAlertActionFieldsRecordResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__GetAlertActionFieldsRecordResponse(soap, tag ? tag : "ns1:GetAlertActionFieldsRecordResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetAlertActionFieldsRecordResponse * SOAP_FMAC4 soap_get_ns1__GetAlertActionFieldsRecordResponse(struct soap *soap, struct ns1__GetAlertActionFieldsRecordResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetAlertActionFieldsRecordResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetTlkpDocumentTypesRecord(struct soap *soap, struct ns1__GetTlkpDocumentTypesRecord *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetTlkpDocumentTypesRecord(struct soap *soap, const struct ns1__GetTlkpDocumentTypesRecord *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetTlkpDocumentTypesRecord(struct soap *soap, const char *tag, int id, const struct ns1__GetTlkpDocumentTypesRecord *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetTlkpDocumentTypesRecord), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetTlkpDocumentTypesRecord * SOAP_FMAC4 soap_in_ns1__GetTlkpDocumentTypesRecord(struct soap *soap, const char *tag, struct ns1__GetTlkpDocumentTypesRecord *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetTlkpDocumentTypesRecord*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetTlkpDocumentTypesRecord, sizeof(struct ns1__GetTlkpDocumentTypesRecord), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__GetTlkpDocumentTypesRecord(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__GetTlkpDocumentTypesRecord *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetTlkpDocumentTypesRecord, SOAP_TYPE_ns1__GetTlkpDocumentTypesRecord, sizeof(struct ns1__GetTlkpDocumentTypesRecord), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__GetTlkpDocumentTypesRecord * SOAP_FMAC2 soap_instantiate_ns1__GetTlkpDocumentTypesRecord(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetTlkpDocumentTypesRecord(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__GetTlkpDocumentTypesRecord *p;
	size_t k = sizeof(struct ns1__GetTlkpDocumentTypesRecord);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GetTlkpDocumentTypesRecord, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__GetTlkpDocumentTypesRecord);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__GetTlkpDocumentTypesRecord, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__GetTlkpDocumentTypesRecord location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetTlkpDocumentTypesRecord(struct soap *soap, const struct ns1__GetTlkpDocumentTypesRecord *a, const char *tag, const char *type)
{
	if (soap_out_ns1__GetTlkpDocumentTypesRecord(soap, tag ? tag : "ns1:GetTlkpDocumentTypesRecord", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetTlkpDocumentTypesRecord * SOAP_FMAC4 soap_get_ns1__GetTlkpDocumentTypesRecord(struct soap *soap, struct ns1__GetTlkpDocumentTypesRecord *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetTlkpDocumentTypesRecord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetTlkpDocumentTypesRecordResponse(struct soap *soap, struct ns1__GetTlkpDocumentTypesRecordResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_SOAP_ENC__string(soap, &a->GetTlkpDocumentTypesRecordReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetTlkpDocumentTypesRecordResponse(struct soap *soap, const struct ns1__GetTlkpDocumentTypesRecordResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->GetTlkpDocumentTypesRecordReturn, SOAP_TYPE_SOAP_ENC__string);
	soap_serialize_SOAP_ENC__string(soap, &a->GetTlkpDocumentTypesRecordReturn);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetTlkpDocumentTypesRecordResponse(struct soap *soap, const char *tag, int id, const struct ns1__GetTlkpDocumentTypesRecordResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetTlkpDocumentTypesRecordResponse), type))
		return soap->error;
	if (soap_out_SOAP_ENC__string(soap, "GetTlkpDocumentTypesRecordReturn", -1, &a->GetTlkpDocumentTypesRecordReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetTlkpDocumentTypesRecordResponse * SOAP_FMAC4 soap_in_ns1__GetTlkpDocumentTypesRecordResponse(struct soap *soap, const char *tag, struct ns1__GetTlkpDocumentTypesRecordResponse *a, const char *type)
{
	size_t soap_flag_GetTlkpDocumentTypesRecordReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetTlkpDocumentTypesRecordResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetTlkpDocumentTypesRecordResponse, sizeof(struct ns1__GetTlkpDocumentTypesRecordResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns1__GetTlkpDocumentTypesRecordResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetTlkpDocumentTypesRecordReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_SOAP_ENC__string(soap, "GetTlkpDocumentTypesRecordReturn", &a->GetTlkpDocumentTypesRecordReturn, "SOAP-ENC:string"))
				{	soap_flag_GetTlkpDocumentTypesRecordReturn--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_GetTlkpDocumentTypesRecordReturn > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__GetTlkpDocumentTypesRecordResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetTlkpDocumentTypesRecordResponse, SOAP_TYPE_ns1__GetTlkpDocumentTypesRecordResponse, sizeof(struct ns1__GetTlkpDocumentTypesRecordResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__GetTlkpDocumentTypesRecordResponse * SOAP_FMAC2 soap_instantiate_ns1__GetTlkpDocumentTypesRecordResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetTlkpDocumentTypesRecordResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__GetTlkpDocumentTypesRecordResponse *p;
	size_t k = sizeof(struct ns1__GetTlkpDocumentTypesRecordResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GetTlkpDocumentTypesRecordResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__GetTlkpDocumentTypesRecordResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__GetTlkpDocumentTypesRecordResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__GetTlkpDocumentTypesRecordResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetTlkpDocumentTypesRecordResponse(struct soap *soap, const struct ns1__GetTlkpDocumentTypesRecordResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__GetTlkpDocumentTypesRecordResponse(soap, tag ? tag : "ns1:GetTlkpDocumentTypesRecordResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetTlkpDocumentTypesRecordResponse * SOAP_FMAC4 soap_get_ns1__GetTlkpDocumentTypesRecordResponse(struct soap *soap, struct ns1__GetTlkpDocumentTypesRecordResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetTlkpDocumentTypesRecordResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetTlkpDocumentTypesRecordByClientType(struct soap *soap, struct ns1__GetTlkpDocumentTypesRecordByClientType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetTlkpDocumentTypesRecordByClientType(struct soap *soap, const struct ns1__GetTlkpDocumentTypesRecordByClientType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetTlkpDocumentTypesRecordByClientType(struct soap *soap, const char *tag, int id, const struct ns1__GetTlkpDocumentTypesRecordByClientType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetTlkpDocumentTypesRecordByClientType), type))
		return soap->error;
	if (soap_out_int(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetTlkpDocumentTypesRecordByClientType * SOAP_FMAC4 soap_in_ns1__GetTlkpDocumentTypesRecordByClientType(struct soap *soap, const char *tag, struct ns1__GetTlkpDocumentTypesRecordByClientType *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetTlkpDocumentTypesRecordByClientType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetTlkpDocumentTypesRecordByClientType, sizeof(struct ns1__GetTlkpDocumentTypesRecordByClientType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__GetTlkpDocumentTypesRecordByClientType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, NULL, &a->_in0, "xsd:int"))
				{	soap_flag__in0--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__in0 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__GetTlkpDocumentTypesRecordByClientType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetTlkpDocumentTypesRecordByClientType, SOAP_TYPE_ns1__GetTlkpDocumentTypesRecordByClientType, sizeof(struct ns1__GetTlkpDocumentTypesRecordByClientType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__GetTlkpDocumentTypesRecordByClientType * SOAP_FMAC2 soap_instantiate_ns1__GetTlkpDocumentTypesRecordByClientType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetTlkpDocumentTypesRecordByClientType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__GetTlkpDocumentTypesRecordByClientType *p;
	size_t k = sizeof(struct ns1__GetTlkpDocumentTypesRecordByClientType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GetTlkpDocumentTypesRecordByClientType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__GetTlkpDocumentTypesRecordByClientType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__GetTlkpDocumentTypesRecordByClientType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__GetTlkpDocumentTypesRecordByClientType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetTlkpDocumentTypesRecordByClientType(struct soap *soap, const struct ns1__GetTlkpDocumentTypesRecordByClientType *a, const char *tag, const char *type)
{
	if (soap_out_ns1__GetTlkpDocumentTypesRecordByClientType(soap, tag ? tag : "ns1:GetTlkpDocumentTypesRecordByClientType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetTlkpDocumentTypesRecordByClientType * SOAP_FMAC4 soap_get_ns1__GetTlkpDocumentTypesRecordByClientType(struct soap *soap, struct ns1__GetTlkpDocumentTypesRecordByClientType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetTlkpDocumentTypesRecordByClientType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetTlkpDocumentTypesRecordByClientTypeResponse(struct soap *soap, struct ns1__GetTlkpDocumentTypesRecordByClientTypeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_SOAP_ENC__string(soap, &a->_GetTlkpDocumentTypesRecordByClientTypeReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetTlkpDocumentTypesRecordByClientTypeResponse(struct soap *soap, const struct ns1__GetTlkpDocumentTypesRecordByClientTypeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->_GetTlkpDocumentTypesRecordByClientTypeReturn, SOAP_TYPE_SOAP_ENC__string);
	soap_serialize_SOAP_ENC__string(soap, &a->_GetTlkpDocumentTypesRecordByClientTypeReturn);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetTlkpDocumentTypesRecordByClientTypeResponse(struct soap *soap, const char *tag, int id, const struct ns1__GetTlkpDocumentTypesRecordByClientTypeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetTlkpDocumentTypesRecordByClientTypeResponse), type))
		return soap->error;
	if (soap_out_SOAP_ENC__string(soap, "GetTlkpDocumentTypesRecordByClientTypeReturn", -1, &a->_GetTlkpDocumentTypesRecordByClientTypeReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetTlkpDocumentTypesRecordByClientTypeResponse * SOAP_FMAC4 soap_in_ns1__GetTlkpDocumentTypesRecordByClientTypeResponse(struct soap *soap, const char *tag, struct ns1__GetTlkpDocumentTypesRecordByClientTypeResponse *a, const char *type)
{
	size_t soap_flag__GetTlkpDocumentTypesRecordByClientTypeReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetTlkpDocumentTypesRecordByClientTypeResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetTlkpDocumentTypesRecordByClientTypeResponse, sizeof(struct ns1__GetTlkpDocumentTypesRecordByClientTypeResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns1__GetTlkpDocumentTypesRecordByClientTypeResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__GetTlkpDocumentTypesRecordByClientTypeReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_SOAP_ENC__string(soap, NULL, &a->_GetTlkpDocumentTypesRecordByClientTypeReturn, "SOAP-ENC:string"))
				{	soap_flag__GetTlkpDocumentTypesRecordByClientTypeReturn--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__GetTlkpDocumentTypesRecordByClientTypeReturn > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__GetTlkpDocumentTypesRecordByClientTypeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetTlkpDocumentTypesRecordByClientTypeResponse, SOAP_TYPE_ns1__GetTlkpDocumentTypesRecordByClientTypeResponse, sizeof(struct ns1__GetTlkpDocumentTypesRecordByClientTypeResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__GetTlkpDocumentTypesRecordByClientTypeResponse * SOAP_FMAC2 soap_instantiate_ns1__GetTlkpDocumentTypesRecordByClientTypeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetTlkpDocumentTypesRecordByClientTypeResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__GetTlkpDocumentTypesRecordByClientTypeResponse *p;
	size_t k = sizeof(struct ns1__GetTlkpDocumentTypesRecordByClientTypeResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GetTlkpDocumentTypesRecordByClientTypeResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__GetTlkpDocumentTypesRecordByClientTypeResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__GetTlkpDocumentTypesRecordByClientTypeResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__GetTlkpDocumentTypesRecordByClientTypeResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetTlkpDocumentTypesRecordByClientTypeResponse(struct soap *soap, const struct ns1__GetTlkpDocumentTypesRecordByClientTypeResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__GetTlkpDocumentTypesRecordByClientTypeResponse(soap, tag ? tag : "ns1:GetTlkpDocumentTypesRecordByClientTypeResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetTlkpDocumentTypesRecordByClientTypeResponse * SOAP_FMAC4 soap_get_ns1__GetTlkpDocumentTypesRecordByClientTypeResponse(struct soap *soap, struct ns1__GetTlkpDocumentTypesRecordByClientTypeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetTlkpDocumentTypesRecordByClientTypeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetTlkpDocumentFieldsRecord(struct soap *soap, struct ns1__GetTlkpDocumentFieldsRecord *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetTlkpDocumentFieldsRecord(struct soap *soap, const struct ns1__GetTlkpDocumentFieldsRecord *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetTlkpDocumentFieldsRecord(struct soap *soap, const char *tag, int id, const struct ns1__GetTlkpDocumentFieldsRecord *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetTlkpDocumentFieldsRecord), type))
		return soap->error;
	if (soap_out_int(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetTlkpDocumentFieldsRecord * SOAP_FMAC4 soap_in_ns1__GetTlkpDocumentFieldsRecord(struct soap *soap, const char *tag, struct ns1__GetTlkpDocumentFieldsRecord *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetTlkpDocumentFieldsRecord*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetTlkpDocumentFieldsRecord, sizeof(struct ns1__GetTlkpDocumentFieldsRecord), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__GetTlkpDocumentFieldsRecord(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, NULL, &a->_in0, "xsd:int"))
				{	soap_flag__in0--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__in0 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__GetTlkpDocumentFieldsRecord *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetTlkpDocumentFieldsRecord, SOAP_TYPE_ns1__GetTlkpDocumentFieldsRecord, sizeof(struct ns1__GetTlkpDocumentFieldsRecord), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__GetTlkpDocumentFieldsRecord * SOAP_FMAC2 soap_instantiate_ns1__GetTlkpDocumentFieldsRecord(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetTlkpDocumentFieldsRecord(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__GetTlkpDocumentFieldsRecord *p;
	size_t k = sizeof(struct ns1__GetTlkpDocumentFieldsRecord);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GetTlkpDocumentFieldsRecord, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__GetTlkpDocumentFieldsRecord);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__GetTlkpDocumentFieldsRecord, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__GetTlkpDocumentFieldsRecord location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetTlkpDocumentFieldsRecord(struct soap *soap, const struct ns1__GetTlkpDocumentFieldsRecord *a, const char *tag, const char *type)
{
	if (soap_out_ns1__GetTlkpDocumentFieldsRecord(soap, tag ? tag : "ns1:GetTlkpDocumentFieldsRecord", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetTlkpDocumentFieldsRecord * SOAP_FMAC4 soap_get_ns1__GetTlkpDocumentFieldsRecord(struct soap *soap, struct ns1__GetTlkpDocumentFieldsRecord *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetTlkpDocumentFieldsRecord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetTlkpDocumentFieldsRecordResponse(struct soap *soap, struct ns1__GetTlkpDocumentFieldsRecordResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_SOAP_ENC__string(soap, &a->_GetTlkpDocumentFieldsRecordReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetTlkpDocumentFieldsRecordResponse(struct soap *soap, const struct ns1__GetTlkpDocumentFieldsRecordResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->_GetTlkpDocumentFieldsRecordReturn, SOAP_TYPE_SOAP_ENC__string);
	soap_serialize_SOAP_ENC__string(soap, &a->_GetTlkpDocumentFieldsRecordReturn);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetTlkpDocumentFieldsRecordResponse(struct soap *soap, const char *tag, int id, const struct ns1__GetTlkpDocumentFieldsRecordResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetTlkpDocumentFieldsRecordResponse), type))
		return soap->error;
	if (soap_out_SOAP_ENC__string(soap, "GetTlkpDocumentFieldsRecordReturn", -1, &a->_GetTlkpDocumentFieldsRecordReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetTlkpDocumentFieldsRecordResponse * SOAP_FMAC4 soap_in_ns1__GetTlkpDocumentFieldsRecordResponse(struct soap *soap, const char *tag, struct ns1__GetTlkpDocumentFieldsRecordResponse *a, const char *type)
{
	size_t soap_flag__GetTlkpDocumentFieldsRecordReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetTlkpDocumentFieldsRecordResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetTlkpDocumentFieldsRecordResponse, sizeof(struct ns1__GetTlkpDocumentFieldsRecordResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns1__GetTlkpDocumentFieldsRecordResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__GetTlkpDocumentFieldsRecordReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_SOAP_ENC__string(soap, NULL, &a->_GetTlkpDocumentFieldsRecordReturn, "SOAP-ENC:string"))
				{	soap_flag__GetTlkpDocumentFieldsRecordReturn--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__GetTlkpDocumentFieldsRecordReturn > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__GetTlkpDocumentFieldsRecordResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetTlkpDocumentFieldsRecordResponse, SOAP_TYPE_ns1__GetTlkpDocumentFieldsRecordResponse, sizeof(struct ns1__GetTlkpDocumentFieldsRecordResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__GetTlkpDocumentFieldsRecordResponse * SOAP_FMAC2 soap_instantiate_ns1__GetTlkpDocumentFieldsRecordResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetTlkpDocumentFieldsRecordResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__GetTlkpDocumentFieldsRecordResponse *p;
	size_t k = sizeof(struct ns1__GetTlkpDocumentFieldsRecordResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GetTlkpDocumentFieldsRecordResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__GetTlkpDocumentFieldsRecordResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__GetTlkpDocumentFieldsRecordResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__GetTlkpDocumentFieldsRecordResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetTlkpDocumentFieldsRecordResponse(struct soap *soap, const struct ns1__GetTlkpDocumentFieldsRecordResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__GetTlkpDocumentFieldsRecordResponse(soap, tag ? tag : "ns1:GetTlkpDocumentFieldsRecordResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetTlkpDocumentFieldsRecordResponse * SOAP_FMAC4 soap_get_ns1__GetTlkpDocumentFieldsRecordResponse(struct soap *soap, struct ns1__GetTlkpDocumentFieldsRecordResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetTlkpDocumentFieldsRecordResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetTlkpDocumentFieldTypesRecord(struct soap *soap, struct ns1__GetTlkpDocumentFieldTypesRecord *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetTlkpDocumentFieldTypesRecord(struct soap *soap, const struct ns1__GetTlkpDocumentFieldTypesRecord *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetTlkpDocumentFieldTypesRecord(struct soap *soap, const char *tag, int id, const struct ns1__GetTlkpDocumentFieldTypesRecord *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetTlkpDocumentFieldTypesRecord), type))
		return soap->error;
	if (soap_out_int(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetTlkpDocumentFieldTypesRecord * SOAP_FMAC4 soap_in_ns1__GetTlkpDocumentFieldTypesRecord(struct soap *soap, const char *tag, struct ns1__GetTlkpDocumentFieldTypesRecord *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetTlkpDocumentFieldTypesRecord*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetTlkpDocumentFieldTypesRecord, sizeof(struct ns1__GetTlkpDocumentFieldTypesRecord), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__GetTlkpDocumentFieldTypesRecord(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, NULL, &a->_in0, "xsd:int"))
				{	soap_flag__in0--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__in0 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__GetTlkpDocumentFieldTypesRecord *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetTlkpDocumentFieldTypesRecord, SOAP_TYPE_ns1__GetTlkpDocumentFieldTypesRecord, sizeof(struct ns1__GetTlkpDocumentFieldTypesRecord), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__GetTlkpDocumentFieldTypesRecord * SOAP_FMAC2 soap_instantiate_ns1__GetTlkpDocumentFieldTypesRecord(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetTlkpDocumentFieldTypesRecord(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__GetTlkpDocumentFieldTypesRecord *p;
	size_t k = sizeof(struct ns1__GetTlkpDocumentFieldTypesRecord);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GetTlkpDocumentFieldTypesRecord, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__GetTlkpDocumentFieldTypesRecord);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__GetTlkpDocumentFieldTypesRecord, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__GetTlkpDocumentFieldTypesRecord location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetTlkpDocumentFieldTypesRecord(struct soap *soap, const struct ns1__GetTlkpDocumentFieldTypesRecord *a, const char *tag, const char *type)
{
	if (soap_out_ns1__GetTlkpDocumentFieldTypesRecord(soap, tag ? tag : "ns1:GetTlkpDocumentFieldTypesRecord", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetTlkpDocumentFieldTypesRecord * SOAP_FMAC4 soap_get_ns1__GetTlkpDocumentFieldTypesRecord(struct soap *soap, struct ns1__GetTlkpDocumentFieldTypesRecord *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetTlkpDocumentFieldTypesRecord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetTlkpDocumentFieldTypesRecordResponse(struct soap *soap, struct ns1__GetTlkpDocumentFieldTypesRecordResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_SOAP_ENC__string(soap, &a->_GetTlkpDocumentFieldTypesRecordReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetTlkpDocumentFieldTypesRecordResponse(struct soap *soap, const struct ns1__GetTlkpDocumentFieldTypesRecordResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->_GetTlkpDocumentFieldTypesRecordReturn, SOAP_TYPE_SOAP_ENC__string);
	soap_serialize_SOAP_ENC__string(soap, &a->_GetTlkpDocumentFieldTypesRecordReturn);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetTlkpDocumentFieldTypesRecordResponse(struct soap *soap, const char *tag, int id, const struct ns1__GetTlkpDocumentFieldTypesRecordResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetTlkpDocumentFieldTypesRecordResponse), type))
		return soap->error;
	if (soap_out_SOAP_ENC__string(soap, "GetTlkpDocumentFieldTypesRecordReturn", -1, &a->_GetTlkpDocumentFieldTypesRecordReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetTlkpDocumentFieldTypesRecordResponse * SOAP_FMAC4 soap_in_ns1__GetTlkpDocumentFieldTypesRecordResponse(struct soap *soap, const char *tag, struct ns1__GetTlkpDocumentFieldTypesRecordResponse *a, const char *type)
{
	size_t soap_flag__GetTlkpDocumentFieldTypesRecordReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetTlkpDocumentFieldTypesRecordResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetTlkpDocumentFieldTypesRecordResponse, sizeof(struct ns1__GetTlkpDocumentFieldTypesRecordResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns1__GetTlkpDocumentFieldTypesRecordResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__GetTlkpDocumentFieldTypesRecordReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_SOAP_ENC__string(soap, NULL, &a->_GetTlkpDocumentFieldTypesRecordReturn, "SOAP-ENC:string"))
				{	soap_flag__GetTlkpDocumentFieldTypesRecordReturn--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__GetTlkpDocumentFieldTypesRecordReturn > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__GetTlkpDocumentFieldTypesRecordResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetTlkpDocumentFieldTypesRecordResponse, SOAP_TYPE_ns1__GetTlkpDocumentFieldTypesRecordResponse, sizeof(struct ns1__GetTlkpDocumentFieldTypesRecordResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__GetTlkpDocumentFieldTypesRecordResponse * SOAP_FMAC2 soap_instantiate_ns1__GetTlkpDocumentFieldTypesRecordResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetTlkpDocumentFieldTypesRecordResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__GetTlkpDocumentFieldTypesRecordResponse *p;
	size_t k = sizeof(struct ns1__GetTlkpDocumentFieldTypesRecordResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GetTlkpDocumentFieldTypesRecordResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__GetTlkpDocumentFieldTypesRecordResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__GetTlkpDocumentFieldTypesRecordResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__GetTlkpDocumentFieldTypesRecordResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetTlkpDocumentFieldTypesRecordResponse(struct soap *soap, const struct ns1__GetTlkpDocumentFieldTypesRecordResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__GetTlkpDocumentFieldTypesRecordResponse(soap, tag ? tag : "ns1:GetTlkpDocumentFieldTypesRecordResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetTlkpDocumentFieldTypesRecordResponse * SOAP_FMAC4 soap_get_ns1__GetTlkpDocumentFieldTypesRecordResponse(struct soap *soap, struct ns1__GetTlkpDocumentFieldTypesRecordResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetTlkpDocumentFieldTypesRecordResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetTlkpActionsRecord(struct soap *soap, struct ns1__GetTlkpActionsRecord *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetTlkpActionsRecord(struct soap *soap, const struct ns1__GetTlkpActionsRecord *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetTlkpActionsRecord(struct soap *soap, const char *tag, int id, const struct ns1__GetTlkpActionsRecord *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetTlkpActionsRecord), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetTlkpActionsRecord * SOAP_FMAC4 soap_in_ns1__GetTlkpActionsRecord(struct soap *soap, const char *tag, struct ns1__GetTlkpActionsRecord *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetTlkpActionsRecord*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetTlkpActionsRecord, sizeof(struct ns1__GetTlkpActionsRecord), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__GetTlkpActionsRecord(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__GetTlkpActionsRecord *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetTlkpActionsRecord, SOAP_TYPE_ns1__GetTlkpActionsRecord, sizeof(struct ns1__GetTlkpActionsRecord), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__GetTlkpActionsRecord * SOAP_FMAC2 soap_instantiate_ns1__GetTlkpActionsRecord(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetTlkpActionsRecord(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__GetTlkpActionsRecord *p;
	size_t k = sizeof(struct ns1__GetTlkpActionsRecord);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GetTlkpActionsRecord, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__GetTlkpActionsRecord);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__GetTlkpActionsRecord, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__GetTlkpActionsRecord location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetTlkpActionsRecord(struct soap *soap, const struct ns1__GetTlkpActionsRecord *a, const char *tag, const char *type)
{
	if (soap_out_ns1__GetTlkpActionsRecord(soap, tag ? tag : "ns1:GetTlkpActionsRecord", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetTlkpActionsRecord * SOAP_FMAC4 soap_get_ns1__GetTlkpActionsRecord(struct soap *soap, struct ns1__GetTlkpActionsRecord *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetTlkpActionsRecord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetTlkpActionsRecordResponse(struct soap *soap, struct ns1__GetTlkpActionsRecordResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_SOAP_ENC__string(soap, &a->GetTlkpActionsRecordReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetTlkpActionsRecordResponse(struct soap *soap, const struct ns1__GetTlkpActionsRecordResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->GetTlkpActionsRecordReturn, SOAP_TYPE_SOAP_ENC__string);
	soap_serialize_SOAP_ENC__string(soap, &a->GetTlkpActionsRecordReturn);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetTlkpActionsRecordResponse(struct soap *soap, const char *tag, int id, const struct ns1__GetTlkpActionsRecordResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetTlkpActionsRecordResponse), type))
		return soap->error;
	if (soap_out_SOAP_ENC__string(soap, "GetTlkpActionsRecordReturn", -1, &a->GetTlkpActionsRecordReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetTlkpActionsRecordResponse * SOAP_FMAC4 soap_in_ns1__GetTlkpActionsRecordResponse(struct soap *soap, const char *tag, struct ns1__GetTlkpActionsRecordResponse *a, const char *type)
{
	size_t soap_flag_GetTlkpActionsRecordReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetTlkpActionsRecordResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetTlkpActionsRecordResponse, sizeof(struct ns1__GetTlkpActionsRecordResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns1__GetTlkpActionsRecordResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetTlkpActionsRecordReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_SOAP_ENC__string(soap, "GetTlkpActionsRecordReturn", &a->GetTlkpActionsRecordReturn, "SOAP-ENC:string"))
				{	soap_flag_GetTlkpActionsRecordReturn--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_GetTlkpActionsRecordReturn > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__GetTlkpActionsRecordResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetTlkpActionsRecordResponse, SOAP_TYPE_ns1__GetTlkpActionsRecordResponse, sizeof(struct ns1__GetTlkpActionsRecordResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__GetTlkpActionsRecordResponse * SOAP_FMAC2 soap_instantiate_ns1__GetTlkpActionsRecordResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetTlkpActionsRecordResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__GetTlkpActionsRecordResponse *p;
	size_t k = sizeof(struct ns1__GetTlkpActionsRecordResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GetTlkpActionsRecordResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__GetTlkpActionsRecordResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__GetTlkpActionsRecordResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__GetTlkpActionsRecordResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetTlkpActionsRecordResponse(struct soap *soap, const struct ns1__GetTlkpActionsRecordResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__GetTlkpActionsRecordResponse(soap, tag ? tag : "ns1:GetTlkpActionsRecordResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetTlkpActionsRecordResponse * SOAP_FMAC4 soap_get_ns1__GetTlkpActionsRecordResponse(struct soap *soap, struct ns1__GetTlkpActionsRecordResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetTlkpActionsRecordResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetTlkpActionsRecordByAction(struct soap *soap, struct ns1__GetTlkpActionsRecordByAction *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetTlkpActionsRecordByAction(struct soap *soap, const struct ns1__GetTlkpActionsRecordByAction *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetTlkpActionsRecordByAction(struct soap *soap, const char *tag, int id, const struct ns1__GetTlkpActionsRecordByAction *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetTlkpActionsRecordByAction), type))
		return soap->error;
	if (soap_out_int(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetTlkpActionsRecordByAction * SOAP_FMAC4 soap_in_ns1__GetTlkpActionsRecordByAction(struct soap *soap, const char *tag, struct ns1__GetTlkpActionsRecordByAction *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetTlkpActionsRecordByAction*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetTlkpActionsRecordByAction, sizeof(struct ns1__GetTlkpActionsRecordByAction), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__GetTlkpActionsRecordByAction(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, NULL, &a->_in0, "xsd:int"))
				{	soap_flag__in0--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__in0 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__GetTlkpActionsRecordByAction *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetTlkpActionsRecordByAction, SOAP_TYPE_ns1__GetTlkpActionsRecordByAction, sizeof(struct ns1__GetTlkpActionsRecordByAction), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__GetTlkpActionsRecordByAction * SOAP_FMAC2 soap_instantiate_ns1__GetTlkpActionsRecordByAction(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetTlkpActionsRecordByAction(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__GetTlkpActionsRecordByAction *p;
	size_t k = sizeof(struct ns1__GetTlkpActionsRecordByAction);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GetTlkpActionsRecordByAction, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__GetTlkpActionsRecordByAction);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__GetTlkpActionsRecordByAction, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__GetTlkpActionsRecordByAction location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetTlkpActionsRecordByAction(struct soap *soap, const struct ns1__GetTlkpActionsRecordByAction *a, const char *tag, const char *type)
{
	if (soap_out_ns1__GetTlkpActionsRecordByAction(soap, tag ? tag : "ns1:GetTlkpActionsRecordByAction", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetTlkpActionsRecordByAction * SOAP_FMAC4 soap_get_ns1__GetTlkpActionsRecordByAction(struct soap *soap, struct ns1__GetTlkpActionsRecordByAction *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetTlkpActionsRecordByAction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetTlkpActionsRecordByActionResponse(struct soap *soap, struct ns1__GetTlkpActionsRecordByActionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_SOAP_ENC__string(soap, &a->_GetTlkpActionsRecordByActionReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetTlkpActionsRecordByActionResponse(struct soap *soap, const struct ns1__GetTlkpActionsRecordByActionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->_GetTlkpActionsRecordByActionReturn, SOAP_TYPE_SOAP_ENC__string);
	soap_serialize_SOAP_ENC__string(soap, &a->_GetTlkpActionsRecordByActionReturn);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetTlkpActionsRecordByActionResponse(struct soap *soap, const char *tag, int id, const struct ns1__GetTlkpActionsRecordByActionResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetTlkpActionsRecordByActionResponse), type))
		return soap->error;
	if (soap_out_SOAP_ENC__string(soap, "GetTlkpActionsRecordByActionReturn", -1, &a->_GetTlkpActionsRecordByActionReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetTlkpActionsRecordByActionResponse * SOAP_FMAC4 soap_in_ns1__GetTlkpActionsRecordByActionResponse(struct soap *soap, const char *tag, struct ns1__GetTlkpActionsRecordByActionResponse *a, const char *type)
{
	size_t soap_flag__GetTlkpActionsRecordByActionReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetTlkpActionsRecordByActionResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetTlkpActionsRecordByActionResponse, sizeof(struct ns1__GetTlkpActionsRecordByActionResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns1__GetTlkpActionsRecordByActionResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__GetTlkpActionsRecordByActionReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_SOAP_ENC__string(soap, NULL, &a->_GetTlkpActionsRecordByActionReturn, "SOAP-ENC:string"))
				{	soap_flag__GetTlkpActionsRecordByActionReturn--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__GetTlkpActionsRecordByActionReturn > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__GetTlkpActionsRecordByActionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetTlkpActionsRecordByActionResponse, SOAP_TYPE_ns1__GetTlkpActionsRecordByActionResponse, sizeof(struct ns1__GetTlkpActionsRecordByActionResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__GetTlkpActionsRecordByActionResponse * SOAP_FMAC2 soap_instantiate_ns1__GetTlkpActionsRecordByActionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetTlkpActionsRecordByActionResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__GetTlkpActionsRecordByActionResponse *p;
	size_t k = sizeof(struct ns1__GetTlkpActionsRecordByActionResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GetTlkpActionsRecordByActionResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__GetTlkpActionsRecordByActionResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__GetTlkpActionsRecordByActionResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__GetTlkpActionsRecordByActionResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetTlkpActionsRecordByActionResponse(struct soap *soap, const struct ns1__GetTlkpActionsRecordByActionResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__GetTlkpActionsRecordByActionResponse(soap, tag ? tag : "ns1:GetTlkpActionsRecordByActionResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetTlkpActionsRecordByActionResponse * SOAP_FMAC4 soap_get_ns1__GetTlkpActionsRecordByActionResponse(struct soap *soap, struct ns1__GetTlkpActionsRecordByActionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetTlkpActionsRecordByActionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetTlkpPriorityLevelRecord(struct soap *soap, struct ns1__GetTlkpPriorityLevelRecord *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetTlkpPriorityLevelRecord(struct soap *soap, const struct ns1__GetTlkpPriorityLevelRecord *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetTlkpPriorityLevelRecord(struct soap *soap, const char *tag, int id, const struct ns1__GetTlkpPriorityLevelRecord *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetTlkpPriorityLevelRecord), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetTlkpPriorityLevelRecord * SOAP_FMAC4 soap_in_ns1__GetTlkpPriorityLevelRecord(struct soap *soap, const char *tag, struct ns1__GetTlkpPriorityLevelRecord *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetTlkpPriorityLevelRecord*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetTlkpPriorityLevelRecord, sizeof(struct ns1__GetTlkpPriorityLevelRecord), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__GetTlkpPriorityLevelRecord(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__GetTlkpPriorityLevelRecord *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetTlkpPriorityLevelRecord, SOAP_TYPE_ns1__GetTlkpPriorityLevelRecord, sizeof(struct ns1__GetTlkpPriorityLevelRecord), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__GetTlkpPriorityLevelRecord * SOAP_FMAC2 soap_instantiate_ns1__GetTlkpPriorityLevelRecord(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetTlkpPriorityLevelRecord(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__GetTlkpPriorityLevelRecord *p;
	size_t k = sizeof(struct ns1__GetTlkpPriorityLevelRecord);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GetTlkpPriorityLevelRecord, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__GetTlkpPriorityLevelRecord);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__GetTlkpPriorityLevelRecord, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__GetTlkpPriorityLevelRecord location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetTlkpPriorityLevelRecord(struct soap *soap, const struct ns1__GetTlkpPriorityLevelRecord *a, const char *tag, const char *type)
{
	if (soap_out_ns1__GetTlkpPriorityLevelRecord(soap, tag ? tag : "ns1:GetTlkpPriorityLevelRecord", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetTlkpPriorityLevelRecord * SOAP_FMAC4 soap_get_ns1__GetTlkpPriorityLevelRecord(struct soap *soap, struct ns1__GetTlkpPriorityLevelRecord *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetTlkpPriorityLevelRecord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetTlkpPriorityLevelRecordResponse(struct soap *soap, struct ns1__GetTlkpPriorityLevelRecordResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_SOAP_ENC__string(soap, &a->GetTlkpPriorityLevelRecordReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetTlkpPriorityLevelRecordResponse(struct soap *soap, const struct ns1__GetTlkpPriorityLevelRecordResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->GetTlkpPriorityLevelRecordReturn, SOAP_TYPE_SOAP_ENC__string);
	soap_serialize_SOAP_ENC__string(soap, &a->GetTlkpPriorityLevelRecordReturn);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetTlkpPriorityLevelRecordResponse(struct soap *soap, const char *tag, int id, const struct ns1__GetTlkpPriorityLevelRecordResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetTlkpPriorityLevelRecordResponse), type))
		return soap->error;
	if (soap_out_SOAP_ENC__string(soap, "GetTlkpPriorityLevelRecordReturn", -1, &a->GetTlkpPriorityLevelRecordReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetTlkpPriorityLevelRecordResponse * SOAP_FMAC4 soap_in_ns1__GetTlkpPriorityLevelRecordResponse(struct soap *soap, const char *tag, struct ns1__GetTlkpPriorityLevelRecordResponse *a, const char *type)
{
	size_t soap_flag_GetTlkpPriorityLevelRecordReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetTlkpPriorityLevelRecordResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetTlkpPriorityLevelRecordResponse, sizeof(struct ns1__GetTlkpPriorityLevelRecordResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns1__GetTlkpPriorityLevelRecordResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetTlkpPriorityLevelRecordReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_SOAP_ENC__string(soap, "GetTlkpPriorityLevelRecordReturn", &a->GetTlkpPriorityLevelRecordReturn, "SOAP-ENC:string"))
				{	soap_flag_GetTlkpPriorityLevelRecordReturn--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_GetTlkpPriorityLevelRecordReturn > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__GetTlkpPriorityLevelRecordResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetTlkpPriorityLevelRecordResponse, SOAP_TYPE_ns1__GetTlkpPriorityLevelRecordResponse, sizeof(struct ns1__GetTlkpPriorityLevelRecordResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__GetTlkpPriorityLevelRecordResponse * SOAP_FMAC2 soap_instantiate_ns1__GetTlkpPriorityLevelRecordResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetTlkpPriorityLevelRecordResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__GetTlkpPriorityLevelRecordResponse *p;
	size_t k = sizeof(struct ns1__GetTlkpPriorityLevelRecordResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GetTlkpPriorityLevelRecordResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__GetTlkpPriorityLevelRecordResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__GetTlkpPriorityLevelRecordResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__GetTlkpPriorityLevelRecordResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetTlkpPriorityLevelRecordResponse(struct soap *soap, const struct ns1__GetTlkpPriorityLevelRecordResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__GetTlkpPriorityLevelRecordResponse(soap, tag ? tag : "ns1:GetTlkpPriorityLevelRecordResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetTlkpPriorityLevelRecordResponse * SOAP_FMAC4 soap_get_ns1__GetTlkpPriorityLevelRecordResponse(struct soap *soap, struct ns1__GetTlkpPriorityLevelRecordResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetTlkpPriorityLevelRecordResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetTlkpPriorityLevelRecordByPriorityLevel(struct soap *soap, struct ns1__GetTlkpPriorityLevelRecordByPriorityLevel *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetTlkpPriorityLevelRecordByPriorityLevel(struct soap *soap, const struct ns1__GetTlkpPriorityLevelRecordByPriorityLevel *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetTlkpPriorityLevelRecordByPriorityLevel(struct soap *soap, const char *tag, int id, const struct ns1__GetTlkpPriorityLevelRecordByPriorityLevel *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetTlkpPriorityLevelRecordByPriorityLevel), type))
		return soap->error;
	if (soap_out_int(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetTlkpPriorityLevelRecordByPriorityLevel * SOAP_FMAC4 soap_in_ns1__GetTlkpPriorityLevelRecordByPriorityLevel(struct soap *soap, const char *tag, struct ns1__GetTlkpPriorityLevelRecordByPriorityLevel *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetTlkpPriorityLevelRecordByPriorityLevel*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetTlkpPriorityLevelRecordByPriorityLevel, sizeof(struct ns1__GetTlkpPriorityLevelRecordByPriorityLevel), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__GetTlkpPriorityLevelRecordByPriorityLevel(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, NULL, &a->_in0, "xsd:int"))
				{	soap_flag__in0--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__in0 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__GetTlkpPriorityLevelRecordByPriorityLevel *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetTlkpPriorityLevelRecordByPriorityLevel, SOAP_TYPE_ns1__GetTlkpPriorityLevelRecordByPriorityLevel, sizeof(struct ns1__GetTlkpPriorityLevelRecordByPriorityLevel), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__GetTlkpPriorityLevelRecordByPriorityLevel * SOAP_FMAC2 soap_instantiate_ns1__GetTlkpPriorityLevelRecordByPriorityLevel(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetTlkpPriorityLevelRecordByPriorityLevel(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__GetTlkpPriorityLevelRecordByPriorityLevel *p;
	size_t k = sizeof(struct ns1__GetTlkpPriorityLevelRecordByPriorityLevel);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GetTlkpPriorityLevelRecordByPriorityLevel, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__GetTlkpPriorityLevelRecordByPriorityLevel);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__GetTlkpPriorityLevelRecordByPriorityLevel, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__GetTlkpPriorityLevelRecordByPriorityLevel location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetTlkpPriorityLevelRecordByPriorityLevel(struct soap *soap, const struct ns1__GetTlkpPriorityLevelRecordByPriorityLevel *a, const char *tag, const char *type)
{
	if (soap_out_ns1__GetTlkpPriorityLevelRecordByPriorityLevel(soap, tag ? tag : "ns1:GetTlkpPriorityLevelRecordByPriorityLevel", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetTlkpPriorityLevelRecordByPriorityLevel * SOAP_FMAC4 soap_get_ns1__GetTlkpPriorityLevelRecordByPriorityLevel(struct soap *soap, struct ns1__GetTlkpPriorityLevelRecordByPriorityLevel *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetTlkpPriorityLevelRecordByPriorityLevel(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetTlkpPriorityLevelRecordByPriorityLevelResponse(struct soap *soap, struct ns1__GetTlkpPriorityLevelRecordByPriorityLevelResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_SOAP_ENC__string(soap, &a->_GetTlkpPriorityLevelRecordByPriorityLevelReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetTlkpPriorityLevelRecordByPriorityLevelResponse(struct soap *soap, const struct ns1__GetTlkpPriorityLevelRecordByPriorityLevelResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->_GetTlkpPriorityLevelRecordByPriorityLevelReturn, SOAP_TYPE_SOAP_ENC__string);
	soap_serialize_SOAP_ENC__string(soap, &a->_GetTlkpPriorityLevelRecordByPriorityLevelReturn);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetTlkpPriorityLevelRecordByPriorityLevelResponse(struct soap *soap, const char *tag, int id, const struct ns1__GetTlkpPriorityLevelRecordByPriorityLevelResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetTlkpPriorityLevelRecordByPriorityLevelResponse), type))
		return soap->error;
	if (soap_out_SOAP_ENC__string(soap, "GetTlkpPriorityLevelRecordByPriorityLevelReturn", -1, &a->_GetTlkpPriorityLevelRecordByPriorityLevelReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetTlkpPriorityLevelRecordByPriorityLevelResponse * SOAP_FMAC4 soap_in_ns1__GetTlkpPriorityLevelRecordByPriorityLevelResponse(struct soap *soap, const char *tag, struct ns1__GetTlkpPriorityLevelRecordByPriorityLevelResponse *a, const char *type)
{
	size_t soap_flag__GetTlkpPriorityLevelRecordByPriorityLevelReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetTlkpPriorityLevelRecordByPriorityLevelResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetTlkpPriorityLevelRecordByPriorityLevelResponse, sizeof(struct ns1__GetTlkpPriorityLevelRecordByPriorityLevelResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns1__GetTlkpPriorityLevelRecordByPriorityLevelResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__GetTlkpPriorityLevelRecordByPriorityLevelReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_SOAP_ENC__string(soap, NULL, &a->_GetTlkpPriorityLevelRecordByPriorityLevelReturn, "SOAP-ENC:string"))
				{	soap_flag__GetTlkpPriorityLevelRecordByPriorityLevelReturn--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__GetTlkpPriorityLevelRecordByPriorityLevelReturn > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__GetTlkpPriorityLevelRecordByPriorityLevelResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetTlkpPriorityLevelRecordByPriorityLevelResponse, SOAP_TYPE_ns1__GetTlkpPriorityLevelRecordByPriorityLevelResponse, sizeof(struct ns1__GetTlkpPriorityLevelRecordByPriorityLevelResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__GetTlkpPriorityLevelRecordByPriorityLevelResponse * SOAP_FMAC2 soap_instantiate_ns1__GetTlkpPriorityLevelRecordByPriorityLevelResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetTlkpPriorityLevelRecordByPriorityLevelResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__GetTlkpPriorityLevelRecordByPriorityLevelResponse *p;
	size_t k = sizeof(struct ns1__GetTlkpPriorityLevelRecordByPriorityLevelResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GetTlkpPriorityLevelRecordByPriorityLevelResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__GetTlkpPriorityLevelRecordByPriorityLevelResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__GetTlkpPriorityLevelRecordByPriorityLevelResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__GetTlkpPriorityLevelRecordByPriorityLevelResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetTlkpPriorityLevelRecordByPriorityLevelResponse(struct soap *soap, const struct ns1__GetTlkpPriorityLevelRecordByPriorityLevelResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__GetTlkpPriorityLevelRecordByPriorityLevelResponse(soap, tag ? tag : "ns1:GetTlkpPriorityLevelRecordByPriorityLevelResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetTlkpPriorityLevelRecordByPriorityLevelResponse * SOAP_FMAC4 soap_get_ns1__GetTlkpPriorityLevelRecordByPriorityLevelResponse(struct soap *soap, struct ns1__GetTlkpPriorityLevelRecordByPriorityLevelResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetTlkpPriorityLevelRecordByPriorityLevelResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetTlkpActionParametersRecord(struct soap *soap, struct ns1__GetTlkpActionParametersRecord *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetTlkpActionParametersRecord(struct soap *soap, const struct ns1__GetTlkpActionParametersRecord *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetTlkpActionParametersRecord(struct soap *soap, const char *tag, int id, const struct ns1__GetTlkpActionParametersRecord *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetTlkpActionParametersRecord), type))
		return soap->error;
	if (soap_out_int(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetTlkpActionParametersRecord * SOAP_FMAC4 soap_in_ns1__GetTlkpActionParametersRecord(struct soap *soap, const char *tag, struct ns1__GetTlkpActionParametersRecord *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetTlkpActionParametersRecord*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetTlkpActionParametersRecord, sizeof(struct ns1__GetTlkpActionParametersRecord), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__GetTlkpActionParametersRecord(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, NULL, &a->_in0, "xsd:int"))
				{	soap_flag__in0--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__in0 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__GetTlkpActionParametersRecord *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetTlkpActionParametersRecord, SOAP_TYPE_ns1__GetTlkpActionParametersRecord, sizeof(struct ns1__GetTlkpActionParametersRecord), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__GetTlkpActionParametersRecord * SOAP_FMAC2 soap_instantiate_ns1__GetTlkpActionParametersRecord(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetTlkpActionParametersRecord(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__GetTlkpActionParametersRecord *p;
	size_t k = sizeof(struct ns1__GetTlkpActionParametersRecord);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GetTlkpActionParametersRecord, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__GetTlkpActionParametersRecord);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__GetTlkpActionParametersRecord, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__GetTlkpActionParametersRecord location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetTlkpActionParametersRecord(struct soap *soap, const struct ns1__GetTlkpActionParametersRecord *a, const char *tag, const char *type)
{
	if (soap_out_ns1__GetTlkpActionParametersRecord(soap, tag ? tag : "ns1:GetTlkpActionParametersRecord", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetTlkpActionParametersRecord * SOAP_FMAC4 soap_get_ns1__GetTlkpActionParametersRecord(struct soap *soap, struct ns1__GetTlkpActionParametersRecord *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetTlkpActionParametersRecord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetTlkpActionParametersRecordResponse(struct soap *soap, struct ns1__GetTlkpActionParametersRecordResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_SOAP_ENC__string(soap, &a->_GetTlkpActionParametersRecordReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetTlkpActionParametersRecordResponse(struct soap *soap, const struct ns1__GetTlkpActionParametersRecordResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->_GetTlkpActionParametersRecordReturn, SOAP_TYPE_SOAP_ENC__string);
	soap_serialize_SOAP_ENC__string(soap, &a->_GetTlkpActionParametersRecordReturn);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetTlkpActionParametersRecordResponse(struct soap *soap, const char *tag, int id, const struct ns1__GetTlkpActionParametersRecordResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetTlkpActionParametersRecordResponse), type))
		return soap->error;
	if (soap_out_SOAP_ENC__string(soap, "GetTlkpActionParametersRecordReturn", -1, &a->_GetTlkpActionParametersRecordReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetTlkpActionParametersRecordResponse * SOAP_FMAC4 soap_in_ns1__GetTlkpActionParametersRecordResponse(struct soap *soap, const char *tag, struct ns1__GetTlkpActionParametersRecordResponse *a, const char *type)
{
	size_t soap_flag__GetTlkpActionParametersRecordReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetTlkpActionParametersRecordResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetTlkpActionParametersRecordResponse, sizeof(struct ns1__GetTlkpActionParametersRecordResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns1__GetTlkpActionParametersRecordResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__GetTlkpActionParametersRecordReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_SOAP_ENC__string(soap, NULL, &a->_GetTlkpActionParametersRecordReturn, "SOAP-ENC:string"))
				{	soap_flag__GetTlkpActionParametersRecordReturn--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__GetTlkpActionParametersRecordReturn > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__GetTlkpActionParametersRecordResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetTlkpActionParametersRecordResponse, SOAP_TYPE_ns1__GetTlkpActionParametersRecordResponse, sizeof(struct ns1__GetTlkpActionParametersRecordResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__GetTlkpActionParametersRecordResponse * SOAP_FMAC2 soap_instantiate_ns1__GetTlkpActionParametersRecordResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetTlkpActionParametersRecordResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__GetTlkpActionParametersRecordResponse *p;
	size_t k = sizeof(struct ns1__GetTlkpActionParametersRecordResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GetTlkpActionParametersRecordResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__GetTlkpActionParametersRecordResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__GetTlkpActionParametersRecordResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__GetTlkpActionParametersRecordResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetTlkpActionParametersRecordResponse(struct soap *soap, const struct ns1__GetTlkpActionParametersRecordResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__GetTlkpActionParametersRecordResponse(soap, tag ? tag : "ns1:GetTlkpActionParametersRecordResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetTlkpActionParametersRecordResponse * SOAP_FMAC4 soap_get_ns1__GetTlkpActionParametersRecordResponse(struct soap *soap, struct ns1__GetTlkpActionParametersRecordResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetTlkpActionParametersRecordResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetTlkpActionParametersRecordByParameterId(struct soap *soap, struct ns1__GetTlkpActionParametersRecordByParameterId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_in0);
	soap_default_int(soap, &a->_in1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetTlkpActionParametersRecordByParameterId(struct soap *soap, const struct ns1__GetTlkpActionParametersRecordByParameterId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetTlkpActionParametersRecordByParameterId(struct soap *soap, const char *tag, int id, const struct ns1__GetTlkpActionParametersRecordByParameterId *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetTlkpActionParametersRecordByParameterId), type))
		return soap->error;
	if (soap_out_int(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	if (soap_out_int(soap, "in1", -1, &a->_in1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetTlkpActionParametersRecordByParameterId * SOAP_FMAC4 soap_in_ns1__GetTlkpActionParametersRecordByParameterId(struct soap *soap, const char *tag, struct ns1__GetTlkpActionParametersRecordByParameterId *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	size_t soap_flag__in1 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetTlkpActionParametersRecordByParameterId*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetTlkpActionParametersRecordByParameterId, sizeof(struct ns1__GetTlkpActionParametersRecordByParameterId), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__GetTlkpActionParametersRecordByParameterId(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, NULL, &a->_in0, "xsd:int"))
				{	soap_flag__in0--;
					continue;
				}
			}
			if (soap_flag__in1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, NULL, &a->_in1, "xsd:int"))
				{	soap_flag__in1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__in0 > 0 || soap_flag__in1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__GetTlkpActionParametersRecordByParameterId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetTlkpActionParametersRecordByParameterId, SOAP_TYPE_ns1__GetTlkpActionParametersRecordByParameterId, sizeof(struct ns1__GetTlkpActionParametersRecordByParameterId), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__GetTlkpActionParametersRecordByParameterId * SOAP_FMAC2 soap_instantiate_ns1__GetTlkpActionParametersRecordByParameterId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetTlkpActionParametersRecordByParameterId(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__GetTlkpActionParametersRecordByParameterId *p;
	size_t k = sizeof(struct ns1__GetTlkpActionParametersRecordByParameterId);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GetTlkpActionParametersRecordByParameterId, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__GetTlkpActionParametersRecordByParameterId);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__GetTlkpActionParametersRecordByParameterId, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__GetTlkpActionParametersRecordByParameterId location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetTlkpActionParametersRecordByParameterId(struct soap *soap, const struct ns1__GetTlkpActionParametersRecordByParameterId *a, const char *tag, const char *type)
{
	if (soap_out_ns1__GetTlkpActionParametersRecordByParameterId(soap, tag ? tag : "ns1:GetTlkpActionParametersRecordByParameterId", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetTlkpActionParametersRecordByParameterId * SOAP_FMAC4 soap_get_ns1__GetTlkpActionParametersRecordByParameterId(struct soap *soap, struct ns1__GetTlkpActionParametersRecordByParameterId *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetTlkpActionParametersRecordByParameterId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetTlkpActionParametersRecordByParameterIdResponse(struct soap *soap, struct ns1__GetTlkpActionParametersRecordByParameterIdResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_SOAP_ENC__string(soap, &a->_GetTlkpActionParametersRecordByParameterIdReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetTlkpActionParametersRecordByParameterIdResponse(struct soap *soap, const struct ns1__GetTlkpActionParametersRecordByParameterIdResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->_GetTlkpActionParametersRecordByParameterIdReturn, SOAP_TYPE_SOAP_ENC__string);
	soap_serialize_SOAP_ENC__string(soap, &a->_GetTlkpActionParametersRecordByParameterIdReturn);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetTlkpActionParametersRecordByParameterIdResponse(struct soap *soap, const char *tag, int id, const struct ns1__GetTlkpActionParametersRecordByParameterIdResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetTlkpActionParametersRecordByParameterIdResponse), type))
		return soap->error;
	if (soap_out_SOAP_ENC__string(soap, "GetTlkpActionParametersRecordByParameterIdReturn", -1, &a->_GetTlkpActionParametersRecordByParameterIdReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetTlkpActionParametersRecordByParameterIdResponse * SOAP_FMAC4 soap_in_ns1__GetTlkpActionParametersRecordByParameterIdResponse(struct soap *soap, const char *tag, struct ns1__GetTlkpActionParametersRecordByParameterIdResponse *a, const char *type)
{
	size_t soap_flag__GetTlkpActionParametersRecordByParameterIdReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetTlkpActionParametersRecordByParameterIdResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetTlkpActionParametersRecordByParameterIdResponse, sizeof(struct ns1__GetTlkpActionParametersRecordByParameterIdResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns1__GetTlkpActionParametersRecordByParameterIdResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__GetTlkpActionParametersRecordByParameterIdReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_SOAP_ENC__string(soap, NULL, &a->_GetTlkpActionParametersRecordByParameterIdReturn, "SOAP-ENC:string"))
				{	soap_flag__GetTlkpActionParametersRecordByParameterIdReturn--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__GetTlkpActionParametersRecordByParameterIdReturn > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__GetTlkpActionParametersRecordByParameterIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetTlkpActionParametersRecordByParameterIdResponse, SOAP_TYPE_ns1__GetTlkpActionParametersRecordByParameterIdResponse, sizeof(struct ns1__GetTlkpActionParametersRecordByParameterIdResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__GetTlkpActionParametersRecordByParameterIdResponse * SOAP_FMAC2 soap_instantiate_ns1__GetTlkpActionParametersRecordByParameterIdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetTlkpActionParametersRecordByParameterIdResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__GetTlkpActionParametersRecordByParameterIdResponse *p;
	size_t k = sizeof(struct ns1__GetTlkpActionParametersRecordByParameterIdResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GetTlkpActionParametersRecordByParameterIdResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__GetTlkpActionParametersRecordByParameterIdResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__GetTlkpActionParametersRecordByParameterIdResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__GetTlkpActionParametersRecordByParameterIdResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetTlkpActionParametersRecordByParameterIdResponse(struct soap *soap, const struct ns1__GetTlkpActionParametersRecordByParameterIdResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__GetTlkpActionParametersRecordByParameterIdResponse(soap, tag ? tag : "ns1:GetTlkpActionParametersRecordByParameterIdResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetTlkpActionParametersRecordByParameterIdResponse * SOAP_FMAC4 soap_get_ns1__GetTlkpActionParametersRecordByParameterIdResponse(struct soap *soap, struct ns1__GetTlkpActionParametersRecordByParameterIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetTlkpActionParametersRecordByParameterIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SendAlert(struct soap *soap, struct ns1__SendAlert *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_in0);
	soap_default_int(soap, &a->_in1);
	soap_default_int(soap, &a->_in2);
	soap_default_int(soap, &a->_in3);
	soap_default_int(soap, &a->_in4);
	soap_default_int(soap, &a->_in5);
	soap_default_SOAP_ENC__string(soap, &a->_in6);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SendAlert(struct soap *soap, const struct ns1__SendAlert *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->_in6, SOAP_TYPE_SOAP_ENC__string);
	soap_serialize_SOAP_ENC__string(soap, &a->_in6);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SendAlert(struct soap *soap, const char *tag, int id, const struct ns1__SendAlert *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SendAlert), type))
		return soap->error;
	if (soap_out_int(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	if (soap_out_int(soap, "in1", -1, &a->_in1, ""))
		return soap->error;
	if (soap_out_int(soap, "in2", -1, &a->_in2, ""))
		return soap->error;
	if (soap_out_int(soap, "in3", -1, &a->_in3, ""))
		return soap->error;
	if (soap_out_int(soap, "in4", -1, &a->_in4, ""))
		return soap->error;
	if (soap_out_int(soap, "in5", -1, &a->_in5, ""))
		return soap->error;
	if (soap_out_SOAP_ENC__string(soap, "in6", -1, &a->_in6, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SendAlert * SOAP_FMAC4 soap_in_ns1__SendAlert(struct soap *soap, const char *tag, struct ns1__SendAlert *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	size_t soap_flag__in1 = 1;
	size_t soap_flag__in2 = 1;
	size_t soap_flag__in3 = 1;
	size_t soap_flag__in4 = 1;
	size_t soap_flag__in5 = 1;
	size_t soap_flag__in6 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SendAlert*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SendAlert, sizeof(struct ns1__SendAlert), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns1__SendAlert(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, NULL, &a->_in0, "xsd:int"))
				{	soap_flag__in0--;
					continue;
				}
			}
			if (soap_flag__in1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, NULL, &a->_in1, "xsd:int"))
				{	soap_flag__in1--;
					continue;
				}
			}
			if (soap_flag__in2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, NULL, &a->_in2, "xsd:int"))
				{	soap_flag__in2--;
					continue;
				}
			}
			if (soap_flag__in3 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, NULL, &a->_in3, "xsd:int"))
				{	soap_flag__in3--;
					continue;
				}
			}
			if (soap_flag__in4 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, NULL, &a->_in4, "xsd:int"))
				{	soap_flag__in4--;
					continue;
				}
			}
			if (soap_flag__in5 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, NULL, &a->_in5, "xsd:int"))
				{	soap_flag__in5--;
					continue;
				}
			}
			if (soap_flag__in6 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_SOAP_ENC__string(soap, NULL, &a->_in6, "SOAP-ENC:string"))
				{	soap_flag__in6--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__in0 > 0 || soap_flag__in1 > 0 || soap_flag__in2 > 0 || soap_flag__in3 > 0 || soap_flag__in4 > 0 || soap_flag__in5 > 0 || soap_flag__in6 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__SendAlert *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SendAlert, SOAP_TYPE_ns1__SendAlert, sizeof(struct ns1__SendAlert), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__SendAlert * SOAP_FMAC2 soap_instantiate_ns1__SendAlert(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SendAlert(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__SendAlert *p;
	size_t k = sizeof(struct ns1__SendAlert);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__SendAlert, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__SendAlert);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__SendAlert, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__SendAlert location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SendAlert(struct soap *soap, const struct ns1__SendAlert *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SendAlert(soap, tag ? tag : "ns1:SendAlert", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SendAlert * SOAP_FMAC4 soap_get_ns1__SendAlert(struct soap *soap, struct ns1__SendAlert *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SendAlert(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SendAlertResponse(struct soap *soap, struct ns1__SendAlertResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SendAlertResponse(struct soap *soap, const struct ns1__SendAlertResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SendAlertResponse(struct soap *soap, const char *tag, int id, const struct ns1__SendAlertResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SendAlertResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SendAlertResponse * SOAP_FMAC4 soap_in_ns1__SendAlertResponse(struct soap *soap, const char *tag, struct ns1__SendAlertResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SendAlertResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SendAlertResponse, sizeof(struct ns1__SendAlertResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SendAlertResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SendAlertResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SendAlertResponse, SOAP_TYPE_ns1__SendAlertResponse, sizeof(struct ns1__SendAlertResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__SendAlertResponse * SOAP_FMAC2 soap_instantiate_ns1__SendAlertResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SendAlertResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__SendAlertResponse *p;
	size_t k = sizeof(struct ns1__SendAlertResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__SendAlertResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__SendAlertResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__SendAlertResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__SendAlertResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SendAlertResponse(struct soap *soap, const struct ns1__SendAlertResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SendAlertResponse(soap, tag ? tag : "ns1:SendAlertResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SendAlertResponse * SOAP_FMAC4 soap_get_ns1__SendAlertResponse(struct soap *soap, struct ns1__SendAlertResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SendAlertResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SendNetworkDocument(struct soap *soap, struct ns1__SendNetworkDocument *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_SOAP_ENC__string(soap, &a->_in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SendNetworkDocument(struct soap *soap, const struct ns1__SendNetworkDocument *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->_in0, SOAP_TYPE_SOAP_ENC__string);
	soap_serialize_SOAP_ENC__string(soap, &a->_in0);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SendNetworkDocument(struct soap *soap, const char *tag, int id, const struct ns1__SendNetworkDocument *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SendNetworkDocument), type))
		return soap->error;
	if (soap_out_SOAP_ENC__string(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SendNetworkDocument * SOAP_FMAC4 soap_in_ns1__SendNetworkDocument(struct soap *soap, const char *tag, struct ns1__SendNetworkDocument *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SendNetworkDocument*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SendNetworkDocument, sizeof(struct ns1__SendNetworkDocument), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns1__SendNetworkDocument(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_SOAP_ENC__string(soap, NULL, &a->_in0, "SOAP-ENC:string"))
				{	soap_flag__in0--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__in0 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__SendNetworkDocument *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SendNetworkDocument, SOAP_TYPE_ns1__SendNetworkDocument, sizeof(struct ns1__SendNetworkDocument), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__SendNetworkDocument * SOAP_FMAC2 soap_instantiate_ns1__SendNetworkDocument(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SendNetworkDocument(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__SendNetworkDocument *p;
	size_t k = sizeof(struct ns1__SendNetworkDocument);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__SendNetworkDocument, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__SendNetworkDocument);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__SendNetworkDocument, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__SendNetworkDocument location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SendNetworkDocument(struct soap *soap, const struct ns1__SendNetworkDocument *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SendNetworkDocument(soap, tag ? tag : "ns1:SendNetworkDocument", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SendNetworkDocument * SOAP_FMAC4 soap_get_ns1__SendNetworkDocument(struct soap *soap, struct ns1__SendNetworkDocument *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SendNetworkDocument(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SendNetworkDocumentResponse(struct soap *soap, struct ns1__SendNetworkDocumentResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SendNetworkDocumentResponse(struct soap *soap, const struct ns1__SendNetworkDocumentResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SendNetworkDocumentResponse(struct soap *soap, const char *tag, int id, const struct ns1__SendNetworkDocumentResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SendNetworkDocumentResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SendNetworkDocumentResponse * SOAP_FMAC4 soap_in_ns1__SendNetworkDocumentResponse(struct soap *soap, const char *tag, struct ns1__SendNetworkDocumentResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SendNetworkDocumentResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SendNetworkDocumentResponse, sizeof(struct ns1__SendNetworkDocumentResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SendNetworkDocumentResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SendNetworkDocumentResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SendNetworkDocumentResponse, SOAP_TYPE_ns1__SendNetworkDocumentResponse, sizeof(struct ns1__SendNetworkDocumentResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__SendNetworkDocumentResponse * SOAP_FMAC2 soap_instantiate_ns1__SendNetworkDocumentResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SendNetworkDocumentResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__SendNetworkDocumentResponse *p;
	size_t k = sizeof(struct ns1__SendNetworkDocumentResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__SendNetworkDocumentResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__SendNetworkDocumentResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__SendNetworkDocumentResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__SendNetworkDocumentResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SendNetworkDocumentResponse(struct soap *soap, const struct ns1__SendNetworkDocumentResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SendNetworkDocumentResponse(soap, tag ? tag : "ns1:SendNetworkDocumentResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SendNetworkDocumentResponse * SOAP_FMAC4 soap_get_ns1__SendNetworkDocumentResponse(struct soap *soap, struct ns1__SendNetworkDocumentResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SendNetworkDocumentResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SubscribeToDocumentType(struct soap *soap, struct ns1__SubscribeToDocumentType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SubscribeToDocumentType(struct soap *soap, const struct ns1__SubscribeToDocumentType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SubscribeToDocumentType(struct soap *soap, const char *tag, int id, const struct ns1__SubscribeToDocumentType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SubscribeToDocumentType), type))
		return soap->error;
	if (soap_out_int(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SubscribeToDocumentType * SOAP_FMAC4 soap_in_ns1__SubscribeToDocumentType(struct soap *soap, const char *tag, struct ns1__SubscribeToDocumentType *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SubscribeToDocumentType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SubscribeToDocumentType, sizeof(struct ns1__SubscribeToDocumentType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SubscribeToDocumentType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, NULL, &a->_in0, "xsd:int"))
				{	soap_flag__in0--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__in0 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__SubscribeToDocumentType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SubscribeToDocumentType, SOAP_TYPE_ns1__SubscribeToDocumentType, sizeof(struct ns1__SubscribeToDocumentType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__SubscribeToDocumentType * SOAP_FMAC2 soap_instantiate_ns1__SubscribeToDocumentType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SubscribeToDocumentType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__SubscribeToDocumentType *p;
	size_t k = sizeof(struct ns1__SubscribeToDocumentType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__SubscribeToDocumentType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__SubscribeToDocumentType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__SubscribeToDocumentType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__SubscribeToDocumentType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SubscribeToDocumentType(struct soap *soap, const struct ns1__SubscribeToDocumentType *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SubscribeToDocumentType(soap, tag ? tag : "ns1:SubscribeToDocumentType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SubscribeToDocumentType * SOAP_FMAC4 soap_get_ns1__SubscribeToDocumentType(struct soap *soap, struct ns1__SubscribeToDocumentType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SubscribeToDocumentType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SubscribeToDocumentTypeResponse(struct soap *soap, struct ns1__SubscribeToDocumentTypeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SubscribeToDocumentTypeResponse(struct soap *soap, const struct ns1__SubscribeToDocumentTypeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SubscribeToDocumentTypeResponse(struct soap *soap, const char *tag, int id, const struct ns1__SubscribeToDocumentTypeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SubscribeToDocumentTypeResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SubscribeToDocumentTypeResponse * SOAP_FMAC4 soap_in_ns1__SubscribeToDocumentTypeResponse(struct soap *soap, const char *tag, struct ns1__SubscribeToDocumentTypeResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SubscribeToDocumentTypeResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SubscribeToDocumentTypeResponse, sizeof(struct ns1__SubscribeToDocumentTypeResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SubscribeToDocumentTypeResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SubscribeToDocumentTypeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SubscribeToDocumentTypeResponse, SOAP_TYPE_ns1__SubscribeToDocumentTypeResponse, sizeof(struct ns1__SubscribeToDocumentTypeResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__SubscribeToDocumentTypeResponse * SOAP_FMAC2 soap_instantiate_ns1__SubscribeToDocumentTypeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SubscribeToDocumentTypeResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__SubscribeToDocumentTypeResponse *p;
	size_t k = sizeof(struct ns1__SubscribeToDocumentTypeResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__SubscribeToDocumentTypeResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__SubscribeToDocumentTypeResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__SubscribeToDocumentTypeResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__SubscribeToDocumentTypeResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SubscribeToDocumentTypeResponse(struct soap *soap, const struct ns1__SubscribeToDocumentTypeResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SubscribeToDocumentTypeResponse(soap, tag ? tag : "ns1:SubscribeToDocumentTypeResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SubscribeToDocumentTypeResponse * SOAP_FMAC4 soap_get_ns1__SubscribeToDocumentTypeResponse(struct soap *soap, struct ns1__SubscribeToDocumentTypeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SubscribeToDocumentTypeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__UnSubscribeToDocumentType(struct soap *soap, struct ns1__UnSubscribeToDocumentType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__UnSubscribeToDocumentType(struct soap *soap, const struct ns1__UnSubscribeToDocumentType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__UnSubscribeToDocumentType(struct soap *soap, const char *tag, int id, const struct ns1__UnSubscribeToDocumentType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__UnSubscribeToDocumentType), type))
		return soap->error;
	if (soap_out_int(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__UnSubscribeToDocumentType * SOAP_FMAC4 soap_in_ns1__UnSubscribeToDocumentType(struct soap *soap, const char *tag, struct ns1__UnSubscribeToDocumentType *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__UnSubscribeToDocumentType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__UnSubscribeToDocumentType, sizeof(struct ns1__UnSubscribeToDocumentType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__UnSubscribeToDocumentType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, NULL, &a->_in0, "xsd:int"))
				{	soap_flag__in0--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__in0 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__UnSubscribeToDocumentType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__UnSubscribeToDocumentType, SOAP_TYPE_ns1__UnSubscribeToDocumentType, sizeof(struct ns1__UnSubscribeToDocumentType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__UnSubscribeToDocumentType * SOAP_FMAC2 soap_instantiate_ns1__UnSubscribeToDocumentType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__UnSubscribeToDocumentType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__UnSubscribeToDocumentType *p;
	size_t k = sizeof(struct ns1__UnSubscribeToDocumentType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__UnSubscribeToDocumentType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__UnSubscribeToDocumentType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__UnSubscribeToDocumentType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__UnSubscribeToDocumentType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__UnSubscribeToDocumentType(struct soap *soap, const struct ns1__UnSubscribeToDocumentType *a, const char *tag, const char *type)
{
	if (soap_out_ns1__UnSubscribeToDocumentType(soap, tag ? tag : "ns1:UnSubscribeToDocumentType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__UnSubscribeToDocumentType * SOAP_FMAC4 soap_get_ns1__UnSubscribeToDocumentType(struct soap *soap, struct ns1__UnSubscribeToDocumentType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__UnSubscribeToDocumentType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__UnSubscribeToDocumentTypeResponse(struct soap *soap, struct ns1__UnSubscribeToDocumentTypeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__UnSubscribeToDocumentTypeResponse(struct soap *soap, const struct ns1__UnSubscribeToDocumentTypeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__UnSubscribeToDocumentTypeResponse(struct soap *soap, const char *tag, int id, const struct ns1__UnSubscribeToDocumentTypeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__UnSubscribeToDocumentTypeResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__UnSubscribeToDocumentTypeResponse * SOAP_FMAC4 soap_in_ns1__UnSubscribeToDocumentTypeResponse(struct soap *soap, const char *tag, struct ns1__UnSubscribeToDocumentTypeResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__UnSubscribeToDocumentTypeResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__UnSubscribeToDocumentTypeResponse, sizeof(struct ns1__UnSubscribeToDocumentTypeResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__UnSubscribeToDocumentTypeResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__UnSubscribeToDocumentTypeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__UnSubscribeToDocumentTypeResponse, SOAP_TYPE_ns1__UnSubscribeToDocumentTypeResponse, sizeof(struct ns1__UnSubscribeToDocumentTypeResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__UnSubscribeToDocumentTypeResponse * SOAP_FMAC2 soap_instantiate_ns1__UnSubscribeToDocumentTypeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__UnSubscribeToDocumentTypeResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__UnSubscribeToDocumentTypeResponse *p;
	size_t k = sizeof(struct ns1__UnSubscribeToDocumentTypeResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__UnSubscribeToDocumentTypeResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__UnSubscribeToDocumentTypeResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__UnSubscribeToDocumentTypeResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__UnSubscribeToDocumentTypeResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__UnSubscribeToDocumentTypeResponse(struct soap *soap, const struct ns1__UnSubscribeToDocumentTypeResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__UnSubscribeToDocumentTypeResponse(soap, tag ? tag : "ns1:UnSubscribeToDocumentTypeResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__UnSubscribeToDocumentTypeResponse * SOAP_FMAC4 soap_get_ns1__UnSubscribeToDocumentTypeResponse(struct soap *soap, struct ns1__UnSubscribeToDocumentTypeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__UnSubscribeToDocumentTypeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SendServerUpdateNotification(struct soap *soap, struct ns1__SendServerUpdateNotification *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_SOAP_ENC__string(soap, &a->_in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SendServerUpdateNotification(struct soap *soap, const struct ns1__SendServerUpdateNotification *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->_in0, SOAP_TYPE_SOAP_ENC__string);
	soap_serialize_SOAP_ENC__string(soap, &a->_in0);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SendServerUpdateNotification(struct soap *soap, const char *tag, int id, const struct ns1__SendServerUpdateNotification *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SendServerUpdateNotification), type))
		return soap->error;
	if (soap_out_SOAP_ENC__string(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SendServerUpdateNotification * SOAP_FMAC4 soap_in_ns1__SendServerUpdateNotification(struct soap *soap, const char *tag, struct ns1__SendServerUpdateNotification *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SendServerUpdateNotification*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SendServerUpdateNotification, sizeof(struct ns1__SendServerUpdateNotification), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns1__SendServerUpdateNotification(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_SOAP_ENC__string(soap, NULL, &a->_in0, "SOAP-ENC:string"))
				{	soap_flag__in0--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__in0 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__SendServerUpdateNotification *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SendServerUpdateNotification, SOAP_TYPE_ns1__SendServerUpdateNotification, sizeof(struct ns1__SendServerUpdateNotification), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__SendServerUpdateNotification * SOAP_FMAC2 soap_instantiate_ns1__SendServerUpdateNotification(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SendServerUpdateNotification(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__SendServerUpdateNotification *p;
	size_t k = sizeof(struct ns1__SendServerUpdateNotification);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__SendServerUpdateNotification, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__SendServerUpdateNotification);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__SendServerUpdateNotification, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__SendServerUpdateNotification location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SendServerUpdateNotification(struct soap *soap, const struct ns1__SendServerUpdateNotification *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SendServerUpdateNotification(soap, tag ? tag : "ns1:SendServerUpdateNotification", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SendServerUpdateNotification * SOAP_FMAC4 soap_get_ns1__SendServerUpdateNotification(struct soap *soap, struct ns1__SendServerUpdateNotification *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SendServerUpdateNotification(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SendServerUpdateNotificationResponse(struct soap *soap, struct ns1__SendServerUpdateNotificationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SendServerUpdateNotificationResponse(struct soap *soap, const struct ns1__SendServerUpdateNotificationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SendServerUpdateNotificationResponse(struct soap *soap, const char *tag, int id, const struct ns1__SendServerUpdateNotificationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SendServerUpdateNotificationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SendServerUpdateNotificationResponse * SOAP_FMAC4 soap_in_ns1__SendServerUpdateNotificationResponse(struct soap *soap, const char *tag, struct ns1__SendServerUpdateNotificationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SendServerUpdateNotificationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SendServerUpdateNotificationResponse, sizeof(struct ns1__SendServerUpdateNotificationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SendServerUpdateNotificationResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SendServerUpdateNotificationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SendServerUpdateNotificationResponse, SOAP_TYPE_ns1__SendServerUpdateNotificationResponse, sizeof(struct ns1__SendServerUpdateNotificationResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__SendServerUpdateNotificationResponse * SOAP_FMAC2 soap_instantiate_ns1__SendServerUpdateNotificationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SendServerUpdateNotificationResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__SendServerUpdateNotificationResponse *p;
	size_t k = sizeof(struct ns1__SendServerUpdateNotificationResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__SendServerUpdateNotificationResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__SendServerUpdateNotificationResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__SendServerUpdateNotificationResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__SendServerUpdateNotificationResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SendServerUpdateNotificationResponse(struct soap *soap, const struct ns1__SendServerUpdateNotificationResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SendServerUpdateNotificationResponse(soap, tag ? tag : "ns1:SendServerUpdateNotificationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SendServerUpdateNotificationResponse * SOAP_FMAC4 soap_get_ns1__SendServerUpdateNotificationResponse(struct soap *soap, struct ns1__SendServerUpdateNotificationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SendServerUpdateNotificationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SetClientType(struct soap *soap, struct ns1__SetClientType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SetClientType(struct soap *soap, const struct ns1__SetClientType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SetClientType(struct soap *soap, const char *tag, int id, const struct ns1__SetClientType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SetClientType), type))
		return soap->error;
	if (soap_out_int(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SetClientType * SOAP_FMAC4 soap_in_ns1__SetClientType(struct soap *soap, const char *tag, struct ns1__SetClientType *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SetClientType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SetClientType, sizeof(struct ns1__SetClientType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SetClientType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, NULL, &a->_in0, "xsd:int"))
				{	soap_flag__in0--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__in0 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__SetClientType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SetClientType, SOAP_TYPE_ns1__SetClientType, sizeof(struct ns1__SetClientType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__SetClientType * SOAP_FMAC2 soap_instantiate_ns1__SetClientType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SetClientType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__SetClientType *p;
	size_t k = sizeof(struct ns1__SetClientType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__SetClientType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__SetClientType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__SetClientType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__SetClientType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SetClientType(struct soap *soap, const struct ns1__SetClientType *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SetClientType(soap, tag ? tag : "ns1:SetClientType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SetClientType * SOAP_FMAC4 soap_get_ns1__SetClientType(struct soap *soap, struct ns1__SetClientType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SetClientType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SetClientTypeResponse(struct soap *soap, struct ns1__SetClientTypeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SetClientTypeResponse(struct soap *soap, const struct ns1__SetClientTypeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SetClientTypeResponse(struct soap *soap, const char *tag, int id, const struct ns1__SetClientTypeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SetClientTypeResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SetClientTypeResponse * SOAP_FMAC4 soap_in_ns1__SetClientTypeResponse(struct soap *soap, const char *tag, struct ns1__SetClientTypeResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SetClientTypeResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SetClientTypeResponse, sizeof(struct ns1__SetClientTypeResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SetClientTypeResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SetClientTypeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SetClientTypeResponse, SOAP_TYPE_ns1__SetClientTypeResponse, sizeof(struct ns1__SetClientTypeResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__SetClientTypeResponse * SOAP_FMAC2 soap_instantiate_ns1__SetClientTypeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SetClientTypeResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__SetClientTypeResponse *p;
	size_t k = sizeof(struct ns1__SetClientTypeResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__SetClientTypeResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__SetClientTypeResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__SetClientTypeResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__SetClientTypeResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SetClientTypeResponse(struct soap *soap, const struct ns1__SetClientTypeResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SetClientTypeResponse(soap, tag ? tag : "ns1:SetClientTypeResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SetClientTypeResponse * SOAP_FMAC4 soap_get_ns1__SetClientTypeResponse(struct soap *soap, struct ns1__SetClientTypeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SetClientTypeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetRunningCenterCord(struct soap *soap, struct ns1__GetRunningCenterCord *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetRunningCenterCord(struct soap *soap, const struct ns1__GetRunningCenterCord *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetRunningCenterCord(struct soap *soap, const char *tag, int id, const struct ns1__GetRunningCenterCord *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetRunningCenterCord), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetRunningCenterCord * SOAP_FMAC4 soap_in_ns1__GetRunningCenterCord(struct soap *soap, const char *tag, struct ns1__GetRunningCenterCord *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetRunningCenterCord*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetRunningCenterCord, sizeof(struct ns1__GetRunningCenterCord), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__GetRunningCenterCord(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__GetRunningCenterCord *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetRunningCenterCord, SOAP_TYPE_ns1__GetRunningCenterCord, sizeof(struct ns1__GetRunningCenterCord), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__GetRunningCenterCord * SOAP_FMAC2 soap_instantiate_ns1__GetRunningCenterCord(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetRunningCenterCord(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__GetRunningCenterCord *p;
	size_t k = sizeof(struct ns1__GetRunningCenterCord);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GetRunningCenterCord, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__GetRunningCenterCord);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__GetRunningCenterCord, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__GetRunningCenterCord location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetRunningCenterCord(struct soap *soap, const struct ns1__GetRunningCenterCord *a, const char *tag, const char *type)
{
	if (soap_out_ns1__GetRunningCenterCord(soap, tag ? tag : "ns1:GetRunningCenterCord", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetRunningCenterCord * SOAP_FMAC4 soap_get_ns1__GetRunningCenterCord(struct soap *soap, struct ns1__GetRunningCenterCord *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetRunningCenterCord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetRunningCenterCordResponse(struct soap *soap, struct ns1__GetRunningCenterCordResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->GetRunningCenterCordReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetRunningCenterCordResponse(struct soap *soap, const struct ns1__GetRunningCenterCordResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__DCenterCordInfo(soap, &a->GetRunningCenterCordReturn);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetRunningCenterCordResponse(struct soap *soap, const char *tag, int id, const struct ns1__GetRunningCenterCordResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetRunningCenterCordResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__DCenterCordInfo(soap, "GetRunningCenterCordReturn", -1, &a->GetRunningCenterCordReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetRunningCenterCordResponse * SOAP_FMAC4 soap_in_ns1__GetRunningCenterCordResponse(struct soap *soap, const char *tag, struct ns1__GetRunningCenterCordResponse *a, const char *type)
{
	size_t soap_flag_GetRunningCenterCordReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetRunningCenterCordResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetRunningCenterCordResponse, sizeof(struct ns1__GetRunningCenterCordResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__GetRunningCenterCordResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetRunningCenterCordReturn && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__DCenterCordInfo(soap, "GetRunningCenterCordReturn", &a->GetRunningCenterCordReturn, "ns1:DCenterCordInfo"))
				{	soap_flag_GetRunningCenterCordReturn--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__GetRunningCenterCordResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetRunningCenterCordResponse, SOAP_TYPE_ns1__GetRunningCenterCordResponse, sizeof(struct ns1__GetRunningCenterCordResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__GetRunningCenterCordResponse * SOAP_FMAC2 soap_instantiate_ns1__GetRunningCenterCordResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetRunningCenterCordResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__GetRunningCenterCordResponse *p;
	size_t k = sizeof(struct ns1__GetRunningCenterCordResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GetRunningCenterCordResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__GetRunningCenterCordResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__GetRunningCenterCordResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__GetRunningCenterCordResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetRunningCenterCordResponse(struct soap *soap, const struct ns1__GetRunningCenterCordResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__GetRunningCenterCordResponse(soap, tag ? tag : "ns1:GetRunningCenterCordResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetRunningCenterCordResponse * SOAP_FMAC4 soap_get_ns1__GetRunningCenterCordResponse(struct soap *soap, struct ns1__GetRunningCenterCordResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetRunningCenterCordResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__DeleteAlert(struct soap *soap, struct ns1__DeleteAlert *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__DeleteAlert(struct soap *soap, const struct ns1__DeleteAlert *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DeleteAlert(struct soap *soap, const char *tag, int id, const struct ns1__DeleteAlert *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DeleteAlert), type))
		return soap->error;
	if (soap_out_int(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__DeleteAlert * SOAP_FMAC4 soap_in_ns1__DeleteAlert(struct soap *soap, const char *tag, struct ns1__DeleteAlert *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__DeleteAlert*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DeleteAlert, sizeof(struct ns1__DeleteAlert), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__DeleteAlert(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, NULL, &a->_in0, "xsd:int"))
				{	soap_flag__in0--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__in0 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__DeleteAlert *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DeleteAlert, SOAP_TYPE_ns1__DeleteAlert, sizeof(struct ns1__DeleteAlert), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__DeleteAlert * SOAP_FMAC2 soap_instantiate_ns1__DeleteAlert(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__DeleteAlert(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__DeleteAlert *p;
	size_t k = sizeof(struct ns1__DeleteAlert);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__DeleteAlert, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__DeleteAlert);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__DeleteAlert, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__DeleteAlert location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__DeleteAlert(struct soap *soap, const struct ns1__DeleteAlert *a, const char *tag, const char *type)
{
	if (soap_out_ns1__DeleteAlert(soap, tag ? tag : "ns1:DeleteAlert", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__DeleteAlert * SOAP_FMAC4 soap_get_ns1__DeleteAlert(struct soap *soap, struct ns1__DeleteAlert *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DeleteAlert(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__DeleteAlertResponse(struct soap *soap, struct ns1__DeleteAlertResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__DeleteAlertResponse(struct soap *soap, const struct ns1__DeleteAlertResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DeleteAlertResponse(struct soap *soap, const char *tag, int id, const struct ns1__DeleteAlertResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DeleteAlertResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__DeleteAlertResponse * SOAP_FMAC4 soap_in_ns1__DeleteAlertResponse(struct soap *soap, const char *tag, struct ns1__DeleteAlertResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__DeleteAlertResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DeleteAlertResponse, sizeof(struct ns1__DeleteAlertResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__DeleteAlertResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__DeleteAlertResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DeleteAlertResponse, SOAP_TYPE_ns1__DeleteAlertResponse, sizeof(struct ns1__DeleteAlertResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__DeleteAlertResponse * SOAP_FMAC2 soap_instantiate_ns1__DeleteAlertResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__DeleteAlertResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__DeleteAlertResponse *p;
	size_t k = sizeof(struct ns1__DeleteAlertResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__DeleteAlertResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__DeleteAlertResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__DeleteAlertResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__DeleteAlertResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__DeleteAlertResponse(struct soap *soap, const struct ns1__DeleteAlertResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__DeleteAlertResponse(soap, tag ? tag : "ns1:DeleteAlertResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__DeleteAlertResponse * SOAP_FMAC4 soap_get_ns1__DeleteAlertResponse(struct soap *soap, struct ns1__DeleteAlertResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DeleteAlertResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__DeleteAlertEvaluation(struct soap *soap, struct ns1__DeleteAlertEvaluation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__DeleteAlertEvaluation(struct soap *soap, const struct ns1__DeleteAlertEvaluation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DeleteAlertEvaluation(struct soap *soap, const char *tag, int id, const struct ns1__DeleteAlertEvaluation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DeleteAlertEvaluation), type))
		return soap->error;
	if (soap_out_int(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__DeleteAlertEvaluation * SOAP_FMAC4 soap_in_ns1__DeleteAlertEvaluation(struct soap *soap, const char *tag, struct ns1__DeleteAlertEvaluation *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__DeleteAlertEvaluation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DeleteAlertEvaluation, sizeof(struct ns1__DeleteAlertEvaluation), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__DeleteAlertEvaluation(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, NULL, &a->_in0, "xsd:int"))
				{	soap_flag__in0--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__in0 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__DeleteAlertEvaluation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DeleteAlertEvaluation, SOAP_TYPE_ns1__DeleteAlertEvaluation, sizeof(struct ns1__DeleteAlertEvaluation), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__DeleteAlertEvaluation * SOAP_FMAC2 soap_instantiate_ns1__DeleteAlertEvaluation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__DeleteAlertEvaluation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__DeleteAlertEvaluation *p;
	size_t k = sizeof(struct ns1__DeleteAlertEvaluation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__DeleteAlertEvaluation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__DeleteAlertEvaluation);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__DeleteAlertEvaluation, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__DeleteAlertEvaluation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__DeleteAlertEvaluation(struct soap *soap, const struct ns1__DeleteAlertEvaluation *a, const char *tag, const char *type)
{
	if (soap_out_ns1__DeleteAlertEvaluation(soap, tag ? tag : "ns1:DeleteAlertEvaluation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__DeleteAlertEvaluation * SOAP_FMAC4 soap_get_ns1__DeleteAlertEvaluation(struct soap *soap, struct ns1__DeleteAlertEvaluation *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DeleteAlertEvaluation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__DeleteAlertEvaluationResponse(struct soap *soap, struct ns1__DeleteAlertEvaluationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__DeleteAlertEvaluationResponse(struct soap *soap, const struct ns1__DeleteAlertEvaluationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DeleteAlertEvaluationResponse(struct soap *soap, const char *tag, int id, const struct ns1__DeleteAlertEvaluationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DeleteAlertEvaluationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__DeleteAlertEvaluationResponse * SOAP_FMAC4 soap_in_ns1__DeleteAlertEvaluationResponse(struct soap *soap, const char *tag, struct ns1__DeleteAlertEvaluationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__DeleteAlertEvaluationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DeleteAlertEvaluationResponse, sizeof(struct ns1__DeleteAlertEvaluationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__DeleteAlertEvaluationResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__DeleteAlertEvaluationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DeleteAlertEvaluationResponse, SOAP_TYPE_ns1__DeleteAlertEvaluationResponse, sizeof(struct ns1__DeleteAlertEvaluationResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__DeleteAlertEvaluationResponse * SOAP_FMAC2 soap_instantiate_ns1__DeleteAlertEvaluationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__DeleteAlertEvaluationResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__DeleteAlertEvaluationResponse *p;
	size_t k = sizeof(struct ns1__DeleteAlertEvaluationResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__DeleteAlertEvaluationResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__DeleteAlertEvaluationResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__DeleteAlertEvaluationResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__DeleteAlertEvaluationResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__DeleteAlertEvaluationResponse(struct soap *soap, const struct ns1__DeleteAlertEvaluationResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__DeleteAlertEvaluationResponse(soap, tag ? tag : "ns1:DeleteAlertEvaluationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__DeleteAlertEvaluationResponse * SOAP_FMAC4 soap_get_ns1__DeleteAlertEvaluationResponse(struct soap *soap, struct ns1__DeleteAlertEvaluationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DeleteAlertEvaluationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__DeleteAlertEvaluation2(struct soap *soap, struct ns1__DeleteAlertEvaluation2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_in0);
	soap_default_int(soap, &a->_in1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__DeleteAlertEvaluation2(struct soap *soap, const struct ns1__DeleteAlertEvaluation2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DeleteAlertEvaluation2(struct soap *soap, const char *tag, int id, const struct ns1__DeleteAlertEvaluation2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DeleteAlertEvaluation2), type))
		return soap->error;
	if (soap_out_int(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	if (soap_out_int(soap, "in1", -1, &a->_in1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__DeleteAlertEvaluation2 * SOAP_FMAC4 soap_in_ns1__DeleteAlertEvaluation2(struct soap *soap, const char *tag, struct ns1__DeleteAlertEvaluation2 *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	size_t soap_flag__in1 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__DeleteAlertEvaluation2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DeleteAlertEvaluation2, sizeof(struct ns1__DeleteAlertEvaluation2), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__DeleteAlertEvaluation2(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, NULL, &a->_in0, "xsd:int"))
				{	soap_flag__in0--;
					continue;
				}
			}
			if (soap_flag__in1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, NULL, &a->_in1, "xsd:int"))
				{	soap_flag__in1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__in0 > 0 || soap_flag__in1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__DeleteAlertEvaluation2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DeleteAlertEvaluation2, SOAP_TYPE_ns1__DeleteAlertEvaluation2, sizeof(struct ns1__DeleteAlertEvaluation2), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__DeleteAlertEvaluation2 * SOAP_FMAC2 soap_instantiate_ns1__DeleteAlertEvaluation2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__DeleteAlertEvaluation2(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__DeleteAlertEvaluation2 *p;
	size_t k = sizeof(struct ns1__DeleteAlertEvaluation2);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__DeleteAlertEvaluation2, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__DeleteAlertEvaluation2);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__DeleteAlertEvaluation2, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__DeleteAlertEvaluation2 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__DeleteAlertEvaluation2(struct soap *soap, const struct ns1__DeleteAlertEvaluation2 *a, const char *tag, const char *type)
{
	if (soap_out_ns1__DeleteAlertEvaluation2(soap, tag ? tag : "ns1:DeleteAlertEvaluation2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__DeleteAlertEvaluation2 * SOAP_FMAC4 soap_get_ns1__DeleteAlertEvaluation2(struct soap *soap, struct ns1__DeleteAlertEvaluation2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DeleteAlertEvaluation2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__DeleteAlertEvaluation2Response(struct soap *soap, struct ns1__DeleteAlertEvaluation2Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__DeleteAlertEvaluation2Response(struct soap *soap, const struct ns1__DeleteAlertEvaluation2Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DeleteAlertEvaluation2Response(struct soap *soap, const char *tag, int id, const struct ns1__DeleteAlertEvaluation2Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DeleteAlertEvaluation2Response), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__DeleteAlertEvaluation2Response * SOAP_FMAC4 soap_in_ns1__DeleteAlertEvaluation2Response(struct soap *soap, const char *tag, struct ns1__DeleteAlertEvaluation2Response *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__DeleteAlertEvaluation2Response*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DeleteAlertEvaluation2Response, sizeof(struct ns1__DeleteAlertEvaluation2Response), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__DeleteAlertEvaluation2Response(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__DeleteAlertEvaluation2Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DeleteAlertEvaluation2Response, SOAP_TYPE_ns1__DeleteAlertEvaluation2Response, sizeof(struct ns1__DeleteAlertEvaluation2Response), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__DeleteAlertEvaluation2Response * SOAP_FMAC2 soap_instantiate_ns1__DeleteAlertEvaluation2Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__DeleteAlertEvaluation2Response(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__DeleteAlertEvaluation2Response *p;
	size_t k = sizeof(struct ns1__DeleteAlertEvaluation2Response);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__DeleteAlertEvaluation2Response, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__DeleteAlertEvaluation2Response);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__DeleteAlertEvaluation2Response, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__DeleteAlertEvaluation2Response location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__DeleteAlertEvaluation2Response(struct soap *soap, const struct ns1__DeleteAlertEvaluation2Response *a, const char *tag, const char *type)
{
	if (soap_out_ns1__DeleteAlertEvaluation2Response(soap, tag ? tag : "ns1:DeleteAlertEvaluation2Response", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__DeleteAlertEvaluation2Response * SOAP_FMAC4 soap_get_ns1__DeleteAlertEvaluation2Response(struct soap *soap, struct ns1__DeleteAlertEvaluation2Response *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DeleteAlertEvaluation2Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__DeleteAlertAction(struct soap *soap, struct ns1__DeleteAlertAction *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__DeleteAlertAction(struct soap *soap, const struct ns1__DeleteAlertAction *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DeleteAlertAction(struct soap *soap, const char *tag, int id, const struct ns1__DeleteAlertAction *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DeleteAlertAction), type))
		return soap->error;
	if (soap_out_int(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__DeleteAlertAction * SOAP_FMAC4 soap_in_ns1__DeleteAlertAction(struct soap *soap, const char *tag, struct ns1__DeleteAlertAction *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__DeleteAlertAction*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DeleteAlertAction, sizeof(struct ns1__DeleteAlertAction), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__DeleteAlertAction(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, NULL, &a->_in0, "xsd:int"))
				{	soap_flag__in0--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__in0 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__DeleteAlertAction *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DeleteAlertAction, SOAP_TYPE_ns1__DeleteAlertAction, sizeof(struct ns1__DeleteAlertAction), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__DeleteAlertAction * SOAP_FMAC2 soap_instantiate_ns1__DeleteAlertAction(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__DeleteAlertAction(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__DeleteAlertAction *p;
	size_t k = sizeof(struct ns1__DeleteAlertAction);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__DeleteAlertAction, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__DeleteAlertAction);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__DeleteAlertAction, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__DeleteAlertAction location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__DeleteAlertAction(struct soap *soap, const struct ns1__DeleteAlertAction *a, const char *tag, const char *type)
{
	if (soap_out_ns1__DeleteAlertAction(soap, tag ? tag : "ns1:DeleteAlertAction", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__DeleteAlertAction * SOAP_FMAC4 soap_get_ns1__DeleteAlertAction(struct soap *soap, struct ns1__DeleteAlertAction *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DeleteAlertAction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__DeleteAlertActionResponse(struct soap *soap, struct ns1__DeleteAlertActionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__DeleteAlertActionResponse(struct soap *soap, const struct ns1__DeleteAlertActionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DeleteAlertActionResponse(struct soap *soap, const char *tag, int id, const struct ns1__DeleteAlertActionResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DeleteAlertActionResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__DeleteAlertActionResponse * SOAP_FMAC4 soap_in_ns1__DeleteAlertActionResponse(struct soap *soap, const char *tag, struct ns1__DeleteAlertActionResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__DeleteAlertActionResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DeleteAlertActionResponse, sizeof(struct ns1__DeleteAlertActionResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__DeleteAlertActionResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__DeleteAlertActionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DeleteAlertActionResponse, SOAP_TYPE_ns1__DeleteAlertActionResponse, sizeof(struct ns1__DeleteAlertActionResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__DeleteAlertActionResponse * SOAP_FMAC2 soap_instantiate_ns1__DeleteAlertActionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__DeleteAlertActionResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__DeleteAlertActionResponse *p;
	size_t k = sizeof(struct ns1__DeleteAlertActionResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__DeleteAlertActionResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__DeleteAlertActionResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__DeleteAlertActionResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__DeleteAlertActionResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__DeleteAlertActionResponse(struct soap *soap, const struct ns1__DeleteAlertActionResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__DeleteAlertActionResponse(soap, tag ? tag : "ns1:DeleteAlertActionResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__DeleteAlertActionResponse * SOAP_FMAC4 soap_get_ns1__DeleteAlertActionResponse(struct soap *soap, struct ns1__DeleteAlertActionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DeleteAlertActionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__DeleteAlertAction2(struct soap *soap, struct ns1__DeleteAlertAction2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__DeleteAlertAction2(struct soap *soap, const struct ns1__DeleteAlertAction2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DeleteAlertAction2(struct soap *soap, const char *tag, int id, const struct ns1__DeleteAlertAction2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DeleteAlertAction2), type))
		return soap->error;
	if (soap_out_int(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__DeleteAlertAction2 * SOAP_FMAC4 soap_in_ns1__DeleteAlertAction2(struct soap *soap, const char *tag, struct ns1__DeleteAlertAction2 *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__DeleteAlertAction2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DeleteAlertAction2, sizeof(struct ns1__DeleteAlertAction2), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__DeleteAlertAction2(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, NULL, &a->_in0, "xsd:int"))
				{	soap_flag__in0--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__in0 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__DeleteAlertAction2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DeleteAlertAction2, SOAP_TYPE_ns1__DeleteAlertAction2, sizeof(struct ns1__DeleteAlertAction2), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__DeleteAlertAction2 * SOAP_FMAC2 soap_instantiate_ns1__DeleteAlertAction2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__DeleteAlertAction2(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__DeleteAlertAction2 *p;
	size_t k = sizeof(struct ns1__DeleteAlertAction2);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__DeleteAlertAction2, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__DeleteAlertAction2);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__DeleteAlertAction2, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__DeleteAlertAction2 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__DeleteAlertAction2(struct soap *soap, const struct ns1__DeleteAlertAction2 *a, const char *tag, const char *type)
{
	if (soap_out_ns1__DeleteAlertAction2(soap, tag ? tag : "ns1:DeleteAlertAction2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__DeleteAlertAction2 * SOAP_FMAC4 soap_get_ns1__DeleteAlertAction2(struct soap *soap, struct ns1__DeleteAlertAction2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DeleteAlertAction2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__DeleteAlertAction2Response(struct soap *soap, struct ns1__DeleteAlertAction2Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__DeleteAlertAction2Response(struct soap *soap, const struct ns1__DeleteAlertAction2Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DeleteAlertAction2Response(struct soap *soap, const char *tag, int id, const struct ns1__DeleteAlertAction2Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DeleteAlertAction2Response), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__DeleteAlertAction2Response * SOAP_FMAC4 soap_in_ns1__DeleteAlertAction2Response(struct soap *soap, const char *tag, struct ns1__DeleteAlertAction2Response *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__DeleteAlertAction2Response*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DeleteAlertAction2Response, sizeof(struct ns1__DeleteAlertAction2Response), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__DeleteAlertAction2Response(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__DeleteAlertAction2Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DeleteAlertAction2Response, SOAP_TYPE_ns1__DeleteAlertAction2Response, sizeof(struct ns1__DeleteAlertAction2Response), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__DeleteAlertAction2Response * SOAP_FMAC2 soap_instantiate_ns1__DeleteAlertAction2Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__DeleteAlertAction2Response(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__DeleteAlertAction2Response *p;
	size_t k = sizeof(struct ns1__DeleteAlertAction2Response);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__DeleteAlertAction2Response, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__DeleteAlertAction2Response);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__DeleteAlertAction2Response, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__DeleteAlertAction2Response location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__DeleteAlertAction2Response(struct soap *soap, const struct ns1__DeleteAlertAction2Response *a, const char *tag, const char *type)
{
	if (soap_out_ns1__DeleteAlertAction2Response(soap, tag ? tag : "ns1:DeleteAlertAction2Response", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__DeleteAlertAction2Response * SOAP_FMAC4 soap_get_ns1__DeleteAlertAction2Response(struct soap *soap, struct ns1__DeleteAlertAction2Response *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DeleteAlertAction2Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__DeleteAlertSchedule(struct soap *soap, struct ns1__DeleteAlertSchedule *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__DeleteAlertSchedule(struct soap *soap, const struct ns1__DeleteAlertSchedule *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DeleteAlertSchedule(struct soap *soap, const char *tag, int id, const struct ns1__DeleteAlertSchedule *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DeleteAlertSchedule), type))
		return soap->error;
	if (soap_out_int(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__DeleteAlertSchedule * SOAP_FMAC4 soap_in_ns1__DeleteAlertSchedule(struct soap *soap, const char *tag, struct ns1__DeleteAlertSchedule *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__DeleteAlertSchedule*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DeleteAlertSchedule, sizeof(struct ns1__DeleteAlertSchedule), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__DeleteAlertSchedule(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, NULL, &a->_in0, "xsd:int"))
				{	soap_flag__in0--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__in0 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__DeleteAlertSchedule *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DeleteAlertSchedule, SOAP_TYPE_ns1__DeleteAlertSchedule, sizeof(struct ns1__DeleteAlertSchedule), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__DeleteAlertSchedule * SOAP_FMAC2 soap_instantiate_ns1__DeleteAlertSchedule(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__DeleteAlertSchedule(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__DeleteAlertSchedule *p;
	size_t k = sizeof(struct ns1__DeleteAlertSchedule);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__DeleteAlertSchedule, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__DeleteAlertSchedule);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__DeleteAlertSchedule, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__DeleteAlertSchedule location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__DeleteAlertSchedule(struct soap *soap, const struct ns1__DeleteAlertSchedule *a, const char *tag, const char *type)
{
	if (soap_out_ns1__DeleteAlertSchedule(soap, tag ? tag : "ns1:DeleteAlertSchedule", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__DeleteAlertSchedule * SOAP_FMAC4 soap_get_ns1__DeleteAlertSchedule(struct soap *soap, struct ns1__DeleteAlertSchedule *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DeleteAlertSchedule(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__DeleteAlertScheduleResponse(struct soap *soap, struct ns1__DeleteAlertScheduleResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__DeleteAlertScheduleResponse(struct soap *soap, const struct ns1__DeleteAlertScheduleResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DeleteAlertScheduleResponse(struct soap *soap, const char *tag, int id, const struct ns1__DeleteAlertScheduleResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DeleteAlertScheduleResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__DeleteAlertScheduleResponse * SOAP_FMAC4 soap_in_ns1__DeleteAlertScheduleResponse(struct soap *soap, const char *tag, struct ns1__DeleteAlertScheduleResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__DeleteAlertScheduleResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DeleteAlertScheduleResponse, sizeof(struct ns1__DeleteAlertScheduleResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__DeleteAlertScheduleResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__DeleteAlertScheduleResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DeleteAlertScheduleResponse, SOAP_TYPE_ns1__DeleteAlertScheduleResponse, sizeof(struct ns1__DeleteAlertScheduleResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__DeleteAlertScheduleResponse * SOAP_FMAC2 soap_instantiate_ns1__DeleteAlertScheduleResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__DeleteAlertScheduleResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__DeleteAlertScheduleResponse *p;
	size_t k = sizeof(struct ns1__DeleteAlertScheduleResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__DeleteAlertScheduleResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__DeleteAlertScheduleResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__DeleteAlertScheduleResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__DeleteAlertScheduleResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__DeleteAlertScheduleResponse(struct soap *soap, const struct ns1__DeleteAlertScheduleResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__DeleteAlertScheduleResponse(soap, tag ? tag : "ns1:DeleteAlertScheduleResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__DeleteAlertScheduleResponse * SOAP_FMAC4 soap_get_ns1__DeleteAlertScheduleResponse(struct soap *soap, struct ns1__DeleteAlertScheduleResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DeleteAlertScheduleResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__DeleteAlertScheduleByScheduleId(struct soap *soap, struct ns1__DeleteAlertScheduleByScheduleId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__DeleteAlertScheduleByScheduleId(struct soap *soap, const struct ns1__DeleteAlertScheduleByScheduleId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DeleteAlertScheduleByScheduleId(struct soap *soap, const char *tag, int id, const struct ns1__DeleteAlertScheduleByScheduleId *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DeleteAlertScheduleByScheduleId), type))
		return soap->error;
	if (soap_out_int(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__DeleteAlertScheduleByScheduleId * SOAP_FMAC4 soap_in_ns1__DeleteAlertScheduleByScheduleId(struct soap *soap, const char *tag, struct ns1__DeleteAlertScheduleByScheduleId *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__DeleteAlertScheduleByScheduleId*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DeleteAlertScheduleByScheduleId, sizeof(struct ns1__DeleteAlertScheduleByScheduleId), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__DeleteAlertScheduleByScheduleId(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, NULL, &a->_in0, "xsd:int"))
				{	soap_flag__in0--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__in0 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__DeleteAlertScheduleByScheduleId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DeleteAlertScheduleByScheduleId, SOAP_TYPE_ns1__DeleteAlertScheduleByScheduleId, sizeof(struct ns1__DeleteAlertScheduleByScheduleId), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__DeleteAlertScheduleByScheduleId * SOAP_FMAC2 soap_instantiate_ns1__DeleteAlertScheduleByScheduleId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__DeleteAlertScheduleByScheduleId(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__DeleteAlertScheduleByScheduleId *p;
	size_t k = sizeof(struct ns1__DeleteAlertScheduleByScheduleId);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__DeleteAlertScheduleByScheduleId, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__DeleteAlertScheduleByScheduleId);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__DeleteAlertScheduleByScheduleId, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__DeleteAlertScheduleByScheduleId location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__DeleteAlertScheduleByScheduleId(struct soap *soap, const struct ns1__DeleteAlertScheduleByScheduleId *a, const char *tag, const char *type)
{
	if (soap_out_ns1__DeleteAlertScheduleByScheduleId(soap, tag ? tag : "ns1:DeleteAlertScheduleByScheduleId", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__DeleteAlertScheduleByScheduleId * SOAP_FMAC4 soap_get_ns1__DeleteAlertScheduleByScheduleId(struct soap *soap, struct ns1__DeleteAlertScheduleByScheduleId *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DeleteAlertScheduleByScheduleId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__DeleteAlertScheduleByScheduleIdResponse(struct soap *soap, struct ns1__DeleteAlertScheduleByScheduleIdResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__DeleteAlertScheduleByScheduleIdResponse(struct soap *soap, const struct ns1__DeleteAlertScheduleByScheduleIdResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DeleteAlertScheduleByScheduleIdResponse(struct soap *soap, const char *tag, int id, const struct ns1__DeleteAlertScheduleByScheduleIdResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DeleteAlertScheduleByScheduleIdResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__DeleteAlertScheduleByScheduleIdResponse * SOAP_FMAC4 soap_in_ns1__DeleteAlertScheduleByScheduleIdResponse(struct soap *soap, const char *tag, struct ns1__DeleteAlertScheduleByScheduleIdResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__DeleteAlertScheduleByScheduleIdResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DeleteAlertScheduleByScheduleIdResponse, sizeof(struct ns1__DeleteAlertScheduleByScheduleIdResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__DeleteAlertScheduleByScheduleIdResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__DeleteAlertScheduleByScheduleIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DeleteAlertScheduleByScheduleIdResponse, SOAP_TYPE_ns1__DeleteAlertScheduleByScheduleIdResponse, sizeof(struct ns1__DeleteAlertScheduleByScheduleIdResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__DeleteAlertScheduleByScheduleIdResponse * SOAP_FMAC2 soap_instantiate_ns1__DeleteAlertScheduleByScheduleIdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__DeleteAlertScheduleByScheduleIdResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__DeleteAlertScheduleByScheduleIdResponse *p;
	size_t k = sizeof(struct ns1__DeleteAlertScheduleByScheduleIdResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__DeleteAlertScheduleByScheduleIdResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__DeleteAlertScheduleByScheduleIdResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__DeleteAlertScheduleByScheduleIdResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__DeleteAlertScheduleByScheduleIdResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__DeleteAlertScheduleByScheduleIdResponse(struct soap *soap, const struct ns1__DeleteAlertScheduleByScheduleIdResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__DeleteAlertScheduleByScheduleIdResponse(soap, tag ? tag : "ns1:DeleteAlertScheduleByScheduleIdResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__DeleteAlertScheduleByScheduleIdResponse * SOAP_FMAC4 soap_get_ns1__DeleteAlertScheduleByScheduleIdResponse(struct soap *soap, struct ns1__DeleteAlertScheduleByScheduleIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DeleteAlertScheduleByScheduleIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__DeleteAlertActionParameter(struct soap *soap, struct ns1__DeleteAlertActionParameter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__DeleteAlertActionParameter(struct soap *soap, const struct ns1__DeleteAlertActionParameter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DeleteAlertActionParameter(struct soap *soap, const char *tag, int id, const struct ns1__DeleteAlertActionParameter *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DeleteAlertActionParameter), type))
		return soap->error;
	if (soap_out_int(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__DeleteAlertActionParameter * SOAP_FMAC4 soap_in_ns1__DeleteAlertActionParameter(struct soap *soap, const char *tag, struct ns1__DeleteAlertActionParameter *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__DeleteAlertActionParameter*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DeleteAlertActionParameter, sizeof(struct ns1__DeleteAlertActionParameter), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__DeleteAlertActionParameter(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, NULL, &a->_in0, "xsd:int"))
				{	soap_flag__in0--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__in0 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__DeleteAlertActionParameter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DeleteAlertActionParameter, SOAP_TYPE_ns1__DeleteAlertActionParameter, sizeof(struct ns1__DeleteAlertActionParameter), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__DeleteAlertActionParameter * SOAP_FMAC2 soap_instantiate_ns1__DeleteAlertActionParameter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__DeleteAlertActionParameter(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__DeleteAlertActionParameter *p;
	size_t k = sizeof(struct ns1__DeleteAlertActionParameter);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__DeleteAlertActionParameter, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__DeleteAlertActionParameter);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__DeleteAlertActionParameter, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__DeleteAlertActionParameter location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__DeleteAlertActionParameter(struct soap *soap, const struct ns1__DeleteAlertActionParameter *a, const char *tag, const char *type)
{
	if (soap_out_ns1__DeleteAlertActionParameter(soap, tag ? tag : "ns1:DeleteAlertActionParameter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__DeleteAlertActionParameter * SOAP_FMAC4 soap_get_ns1__DeleteAlertActionParameter(struct soap *soap, struct ns1__DeleteAlertActionParameter *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DeleteAlertActionParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__DeleteAlertActionParameterResponse(struct soap *soap, struct ns1__DeleteAlertActionParameterResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__DeleteAlertActionParameterResponse(struct soap *soap, const struct ns1__DeleteAlertActionParameterResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DeleteAlertActionParameterResponse(struct soap *soap, const char *tag, int id, const struct ns1__DeleteAlertActionParameterResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DeleteAlertActionParameterResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__DeleteAlertActionParameterResponse * SOAP_FMAC4 soap_in_ns1__DeleteAlertActionParameterResponse(struct soap *soap, const char *tag, struct ns1__DeleteAlertActionParameterResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__DeleteAlertActionParameterResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DeleteAlertActionParameterResponse, sizeof(struct ns1__DeleteAlertActionParameterResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__DeleteAlertActionParameterResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__DeleteAlertActionParameterResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DeleteAlertActionParameterResponse, SOAP_TYPE_ns1__DeleteAlertActionParameterResponse, sizeof(struct ns1__DeleteAlertActionParameterResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__DeleteAlertActionParameterResponse * SOAP_FMAC2 soap_instantiate_ns1__DeleteAlertActionParameterResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__DeleteAlertActionParameterResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__DeleteAlertActionParameterResponse *p;
	size_t k = sizeof(struct ns1__DeleteAlertActionParameterResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__DeleteAlertActionParameterResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__DeleteAlertActionParameterResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__DeleteAlertActionParameterResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__DeleteAlertActionParameterResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__DeleteAlertActionParameterResponse(struct soap *soap, const struct ns1__DeleteAlertActionParameterResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__DeleteAlertActionParameterResponse(soap, tag ? tag : "ns1:DeleteAlertActionParameterResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__DeleteAlertActionParameterResponse * SOAP_FMAC4 soap_get_ns1__DeleteAlertActionParameterResponse(struct soap *soap, struct ns1__DeleteAlertActionParameterResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DeleteAlertActionParameterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__DeleteAlertActionParameter2(struct soap *soap, struct ns1__DeleteAlertActionParameter2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_in0);
	soap_default_int(soap, &a->_in1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__DeleteAlertActionParameter2(struct soap *soap, const struct ns1__DeleteAlertActionParameter2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DeleteAlertActionParameter2(struct soap *soap, const char *tag, int id, const struct ns1__DeleteAlertActionParameter2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DeleteAlertActionParameter2), type))
		return soap->error;
	if (soap_out_int(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	if (soap_out_int(soap, "in1", -1, &a->_in1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__DeleteAlertActionParameter2 * SOAP_FMAC4 soap_in_ns1__DeleteAlertActionParameter2(struct soap *soap, const char *tag, struct ns1__DeleteAlertActionParameter2 *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	size_t soap_flag__in1 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__DeleteAlertActionParameter2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DeleteAlertActionParameter2, sizeof(struct ns1__DeleteAlertActionParameter2), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__DeleteAlertActionParameter2(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, NULL, &a->_in0, "xsd:int"))
				{	soap_flag__in0--;
					continue;
				}
			}
			if (soap_flag__in1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, NULL, &a->_in1, "xsd:int"))
				{	soap_flag__in1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__in0 > 0 || soap_flag__in1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__DeleteAlertActionParameter2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DeleteAlertActionParameter2, SOAP_TYPE_ns1__DeleteAlertActionParameter2, sizeof(struct ns1__DeleteAlertActionParameter2), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__DeleteAlertActionParameter2 * SOAP_FMAC2 soap_instantiate_ns1__DeleteAlertActionParameter2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__DeleteAlertActionParameter2(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__DeleteAlertActionParameter2 *p;
	size_t k = sizeof(struct ns1__DeleteAlertActionParameter2);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__DeleteAlertActionParameter2, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__DeleteAlertActionParameter2);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__DeleteAlertActionParameter2, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__DeleteAlertActionParameter2 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__DeleteAlertActionParameter2(struct soap *soap, const struct ns1__DeleteAlertActionParameter2 *a, const char *tag, const char *type)
{
	if (soap_out_ns1__DeleteAlertActionParameter2(soap, tag ? tag : "ns1:DeleteAlertActionParameter2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__DeleteAlertActionParameter2 * SOAP_FMAC4 soap_get_ns1__DeleteAlertActionParameter2(struct soap *soap, struct ns1__DeleteAlertActionParameter2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DeleteAlertActionParameter2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__DeleteAlertActionParameter2Response(struct soap *soap, struct ns1__DeleteAlertActionParameter2Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__DeleteAlertActionParameter2Response(struct soap *soap, const struct ns1__DeleteAlertActionParameter2Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DeleteAlertActionParameter2Response(struct soap *soap, const char *tag, int id, const struct ns1__DeleteAlertActionParameter2Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DeleteAlertActionParameter2Response), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__DeleteAlertActionParameter2Response * SOAP_FMAC4 soap_in_ns1__DeleteAlertActionParameter2Response(struct soap *soap, const char *tag, struct ns1__DeleteAlertActionParameter2Response *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__DeleteAlertActionParameter2Response*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DeleteAlertActionParameter2Response, sizeof(struct ns1__DeleteAlertActionParameter2Response), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__DeleteAlertActionParameter2Response(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__DeleteAlertActionParameter2Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DeleteAlertActionParameter2Response, SOAP_TYPE_ns1__DeleteAlertActionParameter2Response, sizeof(struct ns1__DeleteAlertActionParameter2Response), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__DeleteAlertActionParameter2Response * SOAP_FMAC2 soap_instantiate_ns1__DeleteAlertActionParameter2Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__DeleteAlertActionParameter2Response(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__DeleteAlertActionParameter2Response *p;
	size_t k = sizeof(struct ns1__DeleteAlertActionParameter2Response);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__DeleteAlertActionParameter2Response, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__DeleteAlertActionParameter2Response);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__DeleteAlertActionParameter2Response, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__DeleteAlertActionParameter2Response location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__DeleteAlertActionParameter2Response(struct soap *soap, const struct ns1__DeleteAlertActionParameter2Response *a, const char *tag, const char *type)
{
	if (soap_out_ns1__DeleteAlertActionParameter2Response(soap, tag ? tag : "ns1:DeleteAlertActionParameter2Response", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__DeleteAlertActionParameter2Response * SOAP_FMAC4 soap_get_ns1__DeleteAlertActionParameter2Response(struct soap *soap, struct ns1__DeleteAlertActionParameter2Response *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DeleteAlertActionParameter2Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__DeleteAlertActionField(struct soap *soap, struct ns1__DeleteAlertActionField *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__DeleteAlertActionField(struct soap *soap, const struct ns1__DeleteAlertActionField *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DeleteAlertActionField(struct soap *soap, const char *tag, int id, const struct ns1__DeleteAlertActionField *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DeleteAlertActionField), type))
		return soap->error;
	if (soap_out_int(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__DeleteAlertActionField * SOAP_FMAC4 soap_in_ns1__DeleteAlertActionField(struct soap *soap, const char *tag, struct ns1__DeleteAlertActionField *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__DeleteAlertActionField*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DeleteAlertActionField, sizeof(struct ns1__DeleteAlertActionField), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__DeleteAlertActionField(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, NULL, &a->_in0, "xsd:int"))
				{	soap_flag__in0--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__in0 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__DeleteAlertActionField *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DeleteAlertActionField, SOAP_TYPE_ns1__DeleteAlertActionField, sizeof(struct ns1__DeleteAlertActionField), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__DeleteAlertActionField * SOAP_FMAC2 soap_instantiate_ns1__DeleteAlertActionField(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__DeleteAlertActionField(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__DeleteAlertActionField *p;
	size_t k = sizeof(struct ns1__DeleteAlertActionField);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__DeleteAlertActionField, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__DeleteAlertActionField);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__DeleteAlertActionField, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__DeleteAlertActionField location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__DeleteAlertActionField(struct soap *soap, const struct ns1__DeleteAlertActionField *a, const char *tag, const char *type)
{
	if (soap_out_ns1__DeleteAlertActionField(soap, tag ? tag : "ns1:DeleteAlertActionField", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__DeleteAlertActionField * SOAP_FMAC4 soap_get_ns1__DeleteAlertActionField(struct soap *soap, struct ns1__DeleteAlertActionField *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DeleteAlertActionField(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__DeleteAlertActionFieldResponse(struct soap *soap, struct ns1__DeleteAlertActionFieldResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__DeleteAlertActionFieldResponse(struct soap *soap, const struct ns1__DeleteAlertActionFieldResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DeleteAlertActionFieldResponse(struct soap *soap, const char *tag, int id, const struct ns1__DeleteAlertActionFieldResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DeleteAlertActionFieldResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__DeleteAlertActionFieldResponse * SOAP_FMAC4 soap_in_ns1__DeleteAlertActionFieldResponse(struct soap *soap, const char *tag, struct ns1__DeleteAlertActionFieldResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__DeleteAlertActionFieldResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DeleteAlertActionFieldResponse, sizeof(struct ns1__DeleteAlertActionFieldResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__DeleteAlertActionFieldResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__DeleteAlertActionFieldResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DeleteAlertActionFieldResponse, SOAP_TYPE_ns1__DeleteAlertActionFieldResponse, sizeof(struct ns1__DeleteAlertActionFieldResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__DeleteAlertActionFieldResponse * SOAP_FMAC2 soap_instantiate_ns1__DeleteAlertActionFieldResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__DeleteAlertActionFieldResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__DeleteAlertActionFieldResponse *p;
	size_t k = sizeof(struct ns1__DeleteAlertActionFieldResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__DeleteAlertActionFieldResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__DeleteAlertActionFieldResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__DeleteAlertActionFieldResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__DeleteAlertActionFieldResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__DeleteAlertActionFieldResponse(struct soap *soap, const struct ns1__DeleteAlertActionFieldResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__DeleteAlertActionFieldResponse(soap, tag ? tag : "ns1:DeleteAlertActionFieldResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__DeleteAlertActionFieldResponse * SOAP_FMAC4 soap_get_ns1__DeleteAlertActionFieldResponse(struct soap *soap, struct ns1__DeleteAlertActionFieldResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DeleteAlertActionFieldResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__DeleteAlertActionField2(struct soap *soap, struct ns1__DeleteAlertActionField2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_in0);
	soap_default_int(soap, &a->_in1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__DeleteAlertActionField2(struct soap *soap, const struct ns1__DeleteAlertActionField2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DeleteAlertActionField2(struct soap *soap, const char *tag, int id, const struct ns1__DeleteAlertActionField2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DeleteAlertActionField2), type))
		return soap->error;
	if (soap_out_int(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	if (soap_out_int(soap, "in1", -1, &a->_in1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__DeleteAlertActionField2 * SOAP_FMAC4 soap_in_ns1__DeleteAlertActionField2(struct soap *soap, const char *tag, struct ns1__DeleteAlertActionField2 *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	size_t soap_flag__in1 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__DeleteAlertActionField2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DeleteAlertActionField2, sizeof(struct ns1__DeleteAlertActionField2), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__DeleteAlertActionField2(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, NULL, &a->_in0, "xsd:int"))
				{	soap_flag__in0--;
					continue;
				}
			}
			if (soap_flag__in1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, NULL, &a->_in1, "xsd:int"))
				{	soap_flag__in1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__in0 > 0 || soap_flag__in1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__DeleteAlertActionField2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DeleteAlertActionField2, SOAP_TYPE_ns1__DeleteAlertActionField2, sizeof(struct ns1__DeleteAlertActionField2), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__DeleteAlertActionField2 * SOAP_FMAC2 soap_instantiate_ns1__DeleteAlertActionField2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__DeleteAlertActionField2(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__DeleteAlertActionField2 *p;
	size_t k = sizeof(struct ns1__DeleteAlertActionField2);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__DeleteAlertActionField2, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__DeleteAlertActionField2);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__DeleteAlertActionField2, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__DeleteAlertActionField2 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__DeleteAlertActionField2(struct soap *soap, const struct ns1__DeleteAlertActionField2 *a, const char *tag, const char *type)
{
	if (soap_out_ns1__DeleteAlertActionField2(soap, tag ? tag : "ns1:DeleteAlertActionField2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__DeleteAlertActionField2 * SOAP_FMAC4 soap_get_ns1__DeleteAlertActionField2(struct soap *soap, struct ns1__DeleteAlertActionField2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DeleteAlertActionField2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__DeleteAlertActionField2Response(struct soap *soap, struct ns1__DeleteAlertActionField2Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__DeleteAlertActionField2Response(struct soap *soap, const struct ns1__DeleteAlertActionField2Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DeleteAlertActionField2Response(struct soap *soap, const char *tag, int id, const struct ns1__DeleteAlertActionField2Response *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DeleteAlertActionField2Response), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__DeleteAlertActionField2Response * SOAP_FMAC4 soap_in_ns1__DeleteAlertActionField2Response(struct soap *soap, const char *tag, struct ns1__DeleteAlertActionField2Response *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__DeleteAlertActionField2Response*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DeleteAlertActionField2Response, sizeof(struct ns1__DeleteAlertActionField2Response), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__DeleteAlertActionField2Response(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__DeleteAlertActionField2Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DeleteAlertActionField2Response, SOAP_TYPE_ns1__DeleteAlertActionField2Response, sizeof(struct ns1__DeleteAlertActionField2Response), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__DeleteAlertActionField2Response * SOAP_FMAC2 soap_instantiate_ns1__DeleteAlertActionField2Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__DeleteAlertActionField2Response(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__DeleteAlertActionField2Response *p;
	size_t k = sizeof(struct ns1__DeleteAlertActionField2Response);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__DeleteAlertActionField2Response, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__DeleteAlertActionField2Response);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__DeleteAlertActionField2Response, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__DeleteAlertActionField2Response location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__DeleteAlertActionField2Response(struct soap *soap, const struct ns1__DeleteAlertActionField2Response *a, const char *tag, const char *type)
{
	if (soap_out_ns1__DeleteAlertActionField2Response(soap, tag ? tag : "ns1:DeleteAlertActionField2Response", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__DeleteAlertActionField2Response * SOAP_FMAC4 soap_get_ns1__DeleteAlertActionField2Response(struct soap *soap, struct ns1__DeleteAlertActionField2Response *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DeleteAlertActionField2Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__AcknowledgeSystemAlert(struct soap *soap, struct ns1__AcknowledgeSystemAlert *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_in0);
	soap_default_SOAP_ENC__string(soap, &a->_in1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__AcknowledgeSystemAlert(struct soap *soap, const struct ns1__AcknowledgeSystemAlert *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->_in1, SOAP_TYPE_SOAP_ENC__string);
	soap_serialize_SOAP_ENC__string(soap, &a->_in1);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AcknowledgeSystemAlert(struct soap *soap, const char *tag, int id, const struct ns1__AcknowledgeSystemAlert *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AcknowledgeSystemAlert), type))
		return soap->error;
	if (soap_out_int(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	if (soap_out_SOAP_ENC__string(soap, "in1", -1, &a->_in1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__AcknowledgeSystemAlert * SOAP_FMAC4 soap_in_ns1__AcknowledgeSystemAlert(struct soap *soap, const char *tag, struct ns1__AcknowledgeSystemAlert *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	size_t soap_flag__in1 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__AcknowledgeSystemAlert*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AcknowledgeSystemAlert, sizeof(struct ns1__AcknowledgeSystemAlert), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns1__AcknowledgeSystemAlert(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, NULL, &a->_in0, "xsd:int"))
				{	soap_flag__in0--;
					continue;
				}
			}
			if (soap_flag__in1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_SOAP_ENC__string(soap, NULL, &a->_in1, "SOAP-ENC:string"))
				{	soap_flag__in1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__in0 > 0 || soap_flag__in1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__AcknowledgeSystemAlert *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__AcknowledgeSystemAlert, SOAP_TYPE_ns1__AcknowledgeSystemAlert, sizeof(struct ns1__AcknowledgeSystemAlert), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__AcknowledgeSystemAlert * SOAP_FMAC2 soap_instantiate_ns1__AcknowledgeSystemAlert(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__AcknowledgeSystemAlert(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__AcknowledgeSystemAlert *p;
	size_t k = sizeof(struct ns1__AcknowledgeSystemAlert);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__AcknowledgeSystemAlert, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__AcknowledgeSystemAlert);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__AcknowledgeSystemAlert, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__AcknowledgeSystemAlert location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__AcknowledgeSystemAlert(struct soap *soap, const struct ns1__AcknowledgeSystemAlert *a, const char *tag, const char *type)
{
	if (soap_out_ns1__AcknowledgeSystemAlert(soap, tag ? tag : "ns1:AcknowledgeSystemAlert", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__AcknowledgeSystemAlert * SOAP_FMAC4 soap_get_ns1__AcknowledgeSystemAlert(struct soap *soap, struct ns1__AcknowledgeSystemAlert *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AcknowledgeSystemAlert(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__AcknowledgeSystemAlertResponse(struct soap *soap, struct ns1__AcknowledgeSystemAlertResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__AcknowledgeSystemAlertResponse(struct soap *soap, const struct ns1__AcknowledgeSystemAlertResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AcknowledgeSystemAlertResponse(struct soap *soap, const char *tag, int id, const struct ns1__AcknowledgeSystemAlertResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AcknowledgeSystemAlertResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__AcknowledgeSystemAlertResponse * SOAP_FMAC4 soap_in_ns1__AcknowledgeSystemAlertResponse(struct soap *soap, const char *tag, struct ns1__AcknowledgeSystemAlertResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__AcknowledgeSystemAlertResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AcknowledgeSystemAlertResponse, sizeof(struct ns1__AcknowledgeSystemAlertResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__AcknowledgeSystemAlertResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__AcknowledgeSystemAlertResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__AcknowledgeSystemAlertResponse, SOAP_TYPE_ns1__AcknowledgeSystemAlertResponse, sizeof(struct ns1__AcknowledgeSystemAlertResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__AcknowledgeSystemAlertResponse * SOAP_FMAC2 soap_instantiate_ns1__AcknowledgeSystemAlertResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__AcknowledgeSystemAlertResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__AcknowledgeSystemAlertResponse *p;
	size_t k = sizeof(struct ns1__AcknowledgeSystemAlertResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__AcknowledgeSystemAlertResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__AcknowledgeSystemAlertResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__AcknowledgeSystemAlertResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__AcknowledgeSystemAlertResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__AcknowledgeSystemAlertResponse(struct soap *soap, const struct ns1__AcknowledgeSystemAlertResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__AcknowledgeSystemAlertResponse(soap, tag ? tag : "ns1:AcknowledgeSystemAlertResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__AcknowledgeSystemAlertResponse * SOAP_FMAC4 soap_get_ns1__AcknowledgeSystemAlertResponse(struct soap *soap, struct ns1__AcknowledgeSystemAlertResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AcknowledgeSystemAlertResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__AcknowledgeApplicationAlert(struct soap *soap, struct ns1__AcknowledgeApplicationAlert *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_in0);
	soap_default_SOAP_ENC__string(soap, &a->_in1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__AcknowledgeApplicationAlert(struct soap *soap, const struct ns1__AcknowledgeApplicationAlert *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->_in1, SOAP_TYPE_SOAP_ENC__string);
	soap_serialize_SOAP_ENC__string(soap, &a->_in1);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AcknowledgeApplicationAlert(struct soap *soap, const char *tag, int id, const struct ns1__AcknowledgeApplicationAlert *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AcknowledgeApplicationAlert), type))
		return soap->error;
	if (soap_out_int(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	if (soap_out_SOAP_ENC__string(soap, "in1", -1, &a->_in1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__AcknowledgeApplicationAlert * SOAP_FMAC4 soap_in_ns1__AcknowledgeApplicationAlert(struct soap *soap, const char *tag, struct ns1__AcknowledgeApplicationAlert *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	size_t soap_flag__in1 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__AcknowledgeApplicationAlert*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AcknowledgeApplicationAlert, sizeof(struct ns1__AcknowledgeApplicationAlert), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns1__AcknowledgeApplicationAlert(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, NULL, &a->_in0, "xsd:int"))
				{	soap_flag__in0--;
					continue;
				}
			}
			if (soap_flag__in1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_SOAP_ENC__string(soap, NULL, &a->_in1, "SOAP-ENC:string"))
				{	soap_flag__in1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__in0 > 0 || soap_flag__in1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__AcknowledgeApplicationAlert *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__AcknowledgeApplicationAlert, SOAP_TYPE_ns1__AcknowledgeApplicationAlert, sizeof(struct ns1__AcknowledgeApplicationAlert), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__AcknowledgeApplicationAlert * SOAP_FMAC2 soap_instantiate_ns1__AcknowledgeApplicationAlert(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__AcknowledgeApplicationAlert(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__AcknowledgeApplicationAlert *p;
	size_t k = sizeof(struct ns1__AcknowledgeApplicationAlert);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__AcknowledgeApplicationAlert, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__AcknowledgeApplicationAlert);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__AcknowledgeApplicationAlert, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__AcknowledgeApplicationAlert location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__AcknowledgeApplicationAlert(struct soap *soap, const struct ns1__AcknowledgeApplicationAlert *a, const char *tag, const char *type)
{
	if (soap_out_ns1__AcknowledgeApplicationAlert(soap, tag ? tag : "ns1:AcknowledgeApplicationAlert", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__AcknowledgeApplicationAlert * SOAP_FMAC4 soap_get_ns1__AcknowledgeApplicationAlert(struct soap *soap, struct ns1__AcknowledgeApplicationAlert *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AcknowledgeApplicationAlert(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__AcknowledgeApplicationAlertResponse(struct soap *soap, struct ns1__AcknowledgeApplicationAlertResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__AcknowledgeApplicationAlertResponse(struct soap *soap, const struct ns1__AcknowledgeApplicationAlertResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AcknowledgeApplicationAlertResponse(struct soap *soap, const char *tag, int id, const struct ns1__AcknowledgeApplicationAlertResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AcknowledgeApplicationAlertResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__AcknowledgeApplicationAlertResponse * SOAP_FMAC4 soap_in_ns1__AcknowledgeApplicationAlertResponse(struct soap *soap, const char *tag, struct ns1__AcknowledgeApplicationAlertResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__AcknowledgeApplicationAlertResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AcknowledgeApplicationAlertResponse, sizeof(struct ns1__AcknowledgeApplicationAlertResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__AcknowledgeApplicationAlertResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__AcknowledgeApplicationAlertResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__AcknowledgeApplicationAlertResponse, SOAP_TYPE_ns1__AcknowledgeApplicationAlertResponse, sizeof(struct ns1__AcknowledgeApplicationAlertResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__AcknowledgeApplicationAlertResponse * SOAP_FMAC2 soap_instantiate_ns1__AcknowledgeApplicationAlertResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__AcknowledgeApplicationAlertResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__AcknowledgeApplicationAlertResponse *p;
	size_t k = sizeof(struct ns1__AcknowledgeApplicationAlertResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__AcknowledgeApplicationAlertResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__AcknowledgeApplicationAlertResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__AcknowledgeApplicationAlertResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__AcknowledgeApplicationAlertResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__AcknowledgeApplicationAlertResponse(struct soap *soap, const struct ns1__AcknowledgeApplicationAlertResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__AcknowledgeApplicationAlertResponse(soap, tag ? tag : "ns1:AcknowledgeApplicationAlertResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__AcknowledgeApplicationAlertResponse * SOAP_FMAC4 soap_get_ns1__AcknowledgeApplicationAlertResponse(struct soap *soap, struct ns1__AcknowledgeApplicationAlertResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AcknowledgeApplicationAlertResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetSystemAlerts(struct soap *soap, struct ns1__GetSystemAlerts *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetSystemAlerts(struct soap *soap, const struct ns1__GetSystemAlerts *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetSystemAlerts(struct soap *soap, const char *tag, int id, const struct ns1__GetSystemAlerts *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetSystemAlerts), type))
		return soap->error;
	if (soap_out_int(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetSystemAlerts * SOAP_FMAC4 soap_in_ns1__GetSystemAlerts(struct soap *soap, const char *tag, struct ns1__GetSystemAlerts *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetSystemAlerts*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetSystemAlerts, sizeof(struct ns1__GetSystemAlerts), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__GetSystemAlerts(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, NULL, &a->_in0, "xsd:int"))
				{	soap_flag__in0--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__in0 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__GetSystemAlerts *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetSystemAlerts, SOAP_TYPE_ns1__GetSystemAlerts, sizeof(struct ns1__GetSystemAlerts), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__GetSystemAlerts * SOAP_FMAC2 soap_instantiate_ns1__GetSystemAlerts(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetSystemAlerts(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__GetSystemAlerts *p;
	size_t k = sizeof(struct ns1__GetSystemAlerts);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GetSystemAlerts, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__GetSystemAlerts);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__GetSystemAlerts, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__GetSystemAlerts location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetSystemAlerts(struct soap *soap, const struct ns1__GetSystemAlerts *a, const char *tag, const char *type)
{
	if (soap_out_ns1__GetSystemAlerts(soap, tag ? tag : "ns1:GetSystemAlerts", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetSystemAlerts * SOAP_FMAC4 soap_get_ns1__GetSystemAlerts(struct soap *soap, struct ns1__GetSystemAlerts *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetSystemAlerts(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetSystemAlertsResponse(struct soap *soap, struct ns1__GetSystemAlertsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_SOAP_ENC__string(soap, &a->_GetSystemAlertsReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetSystemAlertsResponse(struct soap *soap, const struct ns1__GetSystemAlertsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->_GetSystemAlertsReturn, SOAP_TYPE_SOAP_ENC__string);
	soap_serialize_SOAP_ENC__string(soap, &a->_GetSystemAlertsReturn);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetSystemAlertsResponse(struct soap *soap, const char *tag, int id, const struct ns1__GetSystemAlertsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetSystemAlertsResponse), type))
		return soap->error;
	if (soap_out_SOAP_ENC__string(soap, "GetSystemAlertsReturn", -1, &a->_GetSystemAlertsReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetSystemAlertsResponse * SOAP_FMAC4 soap_in_ns1__GetSystemAlertsResponse(struct soap *soap, const char *tag, struct ns1__GetSystemAlertsResponse *a, const char *type)
{
	size_t soap_flag__GetSystemAlertsReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetSystemAlertsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetSystemAlertsResponse, sizeof(struct ns1__GetSystemAlertsResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns1__GetSystemAlertsResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__GetSystemAlertsReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_SOAP_ENC__string(soap, NULL, &a->_GetSystemAlertsReturn, "SOAP-ENC:string"))
				{	soap_flag__GetSystemAlertsReturn--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__GetSystemAlertsReturn > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__GetSystemAlertsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetSystemAlertsResponse, SOAP_TYPE_ns1__GetSystemAlertsResponse, sizeof(struct ns1__GetSystemAlertsResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__GetSystemAlertsResponse * SOAP_FMAC2 soap_instantiate_ns1__GetSystemAlertsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetSystemAlertsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__GetSystemAlertsResponse *p;
	size_t k = sizeof(struct ns1__GetSystemAlertsResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GetSystemAlertsResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__GetSystemAlertsResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__GetSystemAlertsResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__GetSystemAlertsResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetSystemAlertsResponse(struct soap *soap, const struct ns1__GetSystemAlertsResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__GetSystemAlertsResponse(soap, tag ? tag : "ns1:GetSystemAlertsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetSystemAlertsResponse * SOAP_FMAC4 soap_get_ns1__GetSystemAlertsResponse(struct soap *soap, struct ns1__GetSystemAlertsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetSystemAlertsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetSystemAlertsByStartDate(struct soap *soap, struct ns1__GetSystemAlertsByStartDate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_SOAP_ENC__string(soap, &a->_in0);
	soap_default_int(soap, &a->_in1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetSystemAlertsByStartDate(struct soap *soap, const struct ns1__GetSystemAlertsByStartDate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->_in0, SOAP_TYPE_SOAP_ENC__string);
	soap_serialize_SOAP_ENC__string(soap, &a->_in0);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetSystemAlertsByStartDate(struct soap *soap, const char *tag, int id, const struct ns1__GetSystemAlertsByStartDate *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetSystemAlertsByStartDate), type))
		return soap->error;
	if (soap_out_SOAP_ENC__string(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	if (soap_out_int(soap, "in1", -1, &a->_in1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetSystemAlertsByStartDate * SOAP_FMAC4 soap_in_ns1__GetSystemAlertsByStartDate(struct soap *soap, const char *tag, struct ns1__GetSystemAlertsByStartDate *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	size_t soap_flag__in1 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetSystemAlertsByStartDate*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetSystemAlertsByStartDate, sizeof(struct ns1__GetSystemAlertsByStartDate), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns1__GetSystemAlertsByStartDate(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_SOAP_ENC__string(soap, NULL, &a->_in0, "SOAP-ENC:string"))
				{	soap_flag__in0--;
					continue;
				}
			}
			if (soap_flag__in1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, NULL, &a->_in1, "xsd:int"))
				{	soap_flag__in1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__in0 > 0 || soap_flag__in1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__GetSystemAlertsByStartDate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetSystemAlertsByStartDate, SOAP_TYPE_ns1__GetSystemAlertsByStartDate, sizeof(struct ns1__GetSystemAlertsByStartDate), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__GetSystemAlertsByStartDate * SOAP_FMAC2 soap_instantiate_ns1__GetSystemAlertsByStartDate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetSystemAlertsByStartDate(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__GetSystemAlertsByStartDate *p;
	size_t k = sizeof(struct ns1__GetSystemAlertsByStartDate);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GetSystemAlertsByStartDate, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__GetSystemAlertsByStartDate);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__GetSystemAlertsByStartDate, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__GetSystemAlertsByStartDate location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetSystemAlertsByStartDate(struct soap *soap, const struct ns1__GetSystemAlertsByStartDate *a, const char *tag, const char *type)
{
	if (soap_out_ns1__GetSystemAlertsByStartDate(soap, tag ? tag : "ns1:GetSystemAlertsByStartDate", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetSystemAlertsByStartDate * SOAP_FMAC4 soap_get_ns1__GetSystemAlertsByStartDate(struct soap *soap, struct ns1__GetSystemAlertsByStartDate *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetSystemAlertsByStartDate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetSystemAlertsByStartDateResponse(struct soap *soap, struct ns1__GetSystemAlertsByStartDateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_SOAP_ENC__string(soap, &a->_GetSystemAlertsByStartDateReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetSystemAlertsByStartDateResponse(struct soap *soap, const struct ns1__GetSystemAlertsByStartDateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->_GetSystemAlertsByStartDateReturn, SOAP_TYPE_SOAP_ENC__string);
	soap_serialize_SOAP_ENC__string(soap, &a->_GetSystemAlertsByStartDateReturn);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetSystemAlertsByStartDateResponse(struct soap *soap, const char *tag, int id, const struct ns1__GetSystemAlertsByStartDateResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetSystemAlertsByStartDateResponse), type))
		return soap->error;
	if (soap_out_SOAP_ENC__string(soap, "GetSystemAlertsByStartDateReturn", -1, &a->_GetSystemAlertsByStartDateReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetSystemAlertsByStartDateResponse * SOAP_FMAC4 soap_in_ns1__GetSystemAlertsByStartDateResponse(struct soap *soap, const char *tag, struct ns1__GetSystemAlertsByStartDateResponse *a, const char *type)
{
	size_t soap_flag__GetSystemAlertsByStartDateReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetSystemAlertsByStartDateResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetSystemAlertsByStartDateResponse, sizeof(struct ns1__GetSystemAlertsByStartDateResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns1__GetSystemAlertsByStartDateResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__GetSystemAlertsByStartDateReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_SOAP_ENC__string(soap, NULL, &a->_GetSystemAlertsByStartDateReturn, "SOAP-ENC:string"))
				{	soap_flag__GetSystemAlertsByStartDateReturn--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__GetSystemAlertsByStartDateReturn > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__GetSystemAlertsByStartDateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetSystemAlertsByStartDateResponse, SOAP_TYPE_ns1__GetSystemAlertsByStartDateResponse, sizeof(struct ns1__GetSystemAlertsByStartDateResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__GetSystemAlertsByStartDateResponse * SOAP_FMAC2 soap_instantiate_ns1__GetSystemAlertsByStartDateResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetSystemAlertsByStartDateResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__GetSystemAlertsByStartDateResponse *p;
	size_t k = sizeof(struct ns1__GetSystemAlertsByStartDateResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GetSystemAlertsByStartDateResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__GetSystemAlertsByStartDateResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__GetSystemAlertsByStartDateResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__GetSystemAlertsByStartDateResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetSystemAlertsByStartDateResponse(struct soap *soap, const struct ns1__GetSystemAlertsByStartDateResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__GetSystemAlertsByStartDateResponse(soap, tag ? tag : "ns1:GetSystemAlertsByStartDateResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetSystemAlertsByStartDateResponse * SOAP_FMAC4 soap_get_ns1__GetSystemAlertsByStartDateResponse(struct soap *soap, struct ns1__GetSystemAlertsByStartDateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetSystemAlertsByStartDateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetSystemAlertsFilter(struct soap *soap, struct ns1__GetSystemAlertsFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_SOAP_ENC__string(soap, &a->_in0);
	soap_default_SOAP_ENC__string(soap, &a->_in1);
	soap_default_int(soap, &a->_in2);
	soap_default_int(soap, &a->_in3);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetSystemAlertsFilter(struct soap *soap, const struct ns1__GetSystemAlertsFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->_in0, SOAP_TYPE_SOAP_ENC__string);
	soap_serialize_SOAP_ENC__string(soap, &a->_in0);
	soap_embedded(soap, &a->_in1, SOAP_TYPE_SOAP_ENC__string);
	soap_serialize_SOAP_ENC__string(soap, &a->_in1);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetSystemAlertsFilter(struct soap *soap, const char *tag, int id, const struct ns1__GetSystemAlertsFilter *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetSystemAlertsFilter), type))
		return soap->error;
	if (soap_out_SOAP_ENC__string(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	if (soap_out_SOAP_ENC__string(soap, "in1", -1, &a->_in1, ""))
		return soap->error;
	if (soap_out_int(soap, "in2", -1, &a->_in2, ""))
		return soap->error;
	if (soap_out_int(soap, "in3", -1, &a->_in3, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetSystemAlertsFilter * SOAP_FMAC4 soap_in_ns1__GetSystemAlertsFilter(struct soap *soap, const char *tag, struct ns1__GetSystemAlertsFilter *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	size_t soap_flag__in1 = 1;
	size_t soap_flag__in2 = 1;
	size_t soap_flag__in3 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetSystemAlertsFilter*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetSystemAlertsFilter, sizeof(struct ns1__GetSystemAlertsFilter), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns1__GetSystemAlertsFilter(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_SOAP_ENC__string(soap, NULL, &a->_in0, "SOAP-ENC:string"))
				{	soap_flag__in0--;
					continue;
				}
			}
			if (soap_flag__in1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_SOAP_ENC__string(soap, NULL, &a->_in1, "SOAP-ENC:string"))
				{	soap_flag__in1--;
					continue;
				}
			}
			if (soap_flag__in2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, NULL, &a->_in2, "xsd:int"))
				{	soap_flag__in2--;
					continue;
				}
			}
			if (soap_flag__in3 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, NULL, &a->_in3, "xsd:int"))
				{	soap_flag__in3--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__in0 > 0 || soap_flag__in1 > 0 || soap_flag__in2 > 0 || soap_flag__in3 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__GetSystemAlertsFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetSystemAlertsFilter, SOAP_TYPE_ns1__GetSystemAlertsFilter, sizeof(struct ns1__GetSystemAlertsFilter), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__GetSystemAlertsFilter * SOAP_FMAC2 soap_instantiate_ns1__GetSystemAlertsFilter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetSystemAlertsFilter(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__GetSystemAlertsFilter *p;
	size_t k = sizeof(struct ns1__GetSystemAlertsFilter);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GetSystemAlertsFilter, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__GetSystemAlertsFilter);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__GetSystemAlertsFilter, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__GetSystemAlertsFilter location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetSystemAlertsFilter(struct soap *soap, const struct ns1__GetSystemAlertsFilter *a, const char *tag, const char *type)
{
	if (soap_out_ns1__GetSystemAlertsFilter(soap, tag ? tag : "ns1:GetSystemAlertsFilter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetSystemAlertsFilter * SOAP_FMAC4 soap_get_ns1__GetSystemAlertsFilter(struct soap *soap, struct ns1__GetSystemAlertsFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetSystemAlertsFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetSystemAlertsFilterResponse(struct soap *soap, struct ns1__GetSystemAlertsFilterResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_SOAP_ENC__string(soap, &a->_GetSystemAlertsFilterReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetSystemAlertsFilterResponse(struct soap *soap, const struct ns1__GetSystemAlertsFilterResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->_GetSystemAlertsFilterReturn, SOAP_TYPE_SOAP_ENC__string);
	soap_serialize_SOAP_ENC__string(soap, &a->_GetSystemAlertsFilterReturn);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetSystemAlertsFilterResponse(struct soap *soap, const char *tag, int id, const struct ns1__GetSystemAlertsFilterResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetSystemAlertsFilterResponse), type))
		return soap->error;
	if (soap_out_SOAP_ENC__string(soap, "GetSystemAlertsFilterReturn", -1, &a->_GetSystemAlertsFilterReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetSystemAlertsFilterResponse * SOAP_FMAC4 soap_in_ns1__GetSystemAlertsFilterResponse(struct soap *soap, const char *tag, struct ns1__GetSystemAlertsFilterResponse *a, const char *type)
{
	size_t soap_flag__GetSystemAlertsFilterReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetSystemAlertsFilterResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetSystemAlertsFilterResponse, sizeof(struct ns1__GetSystemAlertsFilterResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns1__GetSystemAlertsFilterResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__GetSystemAlertsFilterReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_SOAP_ENC__string(soap, NULL, &a->_GetSystemAlertsFilterReturn, "SOAP-ENC:string"))
				{	soap_flag__GetSystemAlertsFilterReturn--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__GetSystemAlertsFilterReturn > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__GetSystemAlertsFilterResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetSystemAlertsFilterResponse, SOAP_TYPE_ns1__GetSystemAlertsFilterResponse, sizeof(struct ns1__GetSystemAlertsFilterResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__GetSystemAlertsFilterResponse * SOAP_FMAC2 soap_instantiate_ns1__GetSystemAlertsFilterResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetSystemAlertsFilterResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__GetSystemAlertsFilterResponse *p;
	size_t k = sizeof(struct ns1__GetSystemAlertsFilterResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GetSystemAlertsFilterResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__GetSystemAlertsFilterResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__GetSystemAlertsFilterResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__GetSystemAlertsFilterResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetSystemAlertsFilterResponse(struct soap *soap, const struct ns1__GetSystemAlertsFilterResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__GetSystemAlertsFilterResponse(soap, tag ? tag : "ns1:GetSystemAlertsFilterResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetSystemAlertsFilterResponse * SOAP_FMAC4 soap_get_ns1__GetSystemAlertsFilterResponse(struct soap *soap, struct ns1__GetSystemAlertsFilterResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetSystemAlertsFilterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetApplicationAlertsFilter(struct soap *soap, struct ns1__GetApplicationAlertsFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_SOAP_ENC__string(soap, &a->_in0);
	soap_default_SOAP_ENC__string(soap, &a->_in1);
	soap_default_SOAP_ENC__string(soap, &a->_in2);
	soap_default_int(soap, &a->_in3);
	soap_default_int(soap, &a->_in4);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetApplicationAlertsFilter(struct soap *soap, const struct ns1__GetApplicationAlertsFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->_in0, SOAP_TYPE_SOAP_ENC__string);
	soap_serialize_SOAP_ENC__string(soap, &a->_in0);
	soap_embedded(soap, &a->_in1, SOAP_TYPE_SOAP_ENC__string);
	soap_serialize_SOAP_ENC__string(soap, &a->_in1);
	soap_embedded(soap, &a->_in2, SOAP_TYPE_SOAP_ENC__string);
	soap_serialize_SOAP_ENC__string(soap, &a->_in2);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetApplicationAlertsFilter(struct soap *soap, const char *tag, int id, const struct ns1__GetApplicationAlertsFilter *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetApplicationAlertsFilter), type))
		return soap->error;
	if (soap_out_SOAP_ENC__string(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	if (soap_out_SOAP_ENC__string(soap, "in1", -1, &a->_in1, ""))
		return soap->error;
	if (soap_out_SOAP_ENC__string(soap, "in2", -1, &a->_in2, ""))
		return soap->error;
	if (soap_out_int(soap, "in3", -1, &a->_in3, ""))
		return soap->error;
	if (soap_out_int(soap, "in4", -1, &a->_in4, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetApplicationAlertsFilter * SOAP_FMAC4 soap_in_ns1__GetApplicationAlertsFilter(struct soap *soap, const char *tag, struct ns1__GetApplicationAlertsFilter *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	size_t soap_flag__in1 = 1;
	size_t soap_flag__in2 = 1;
	size_t soap_flag__in3 = 1;
	size_t soap_flag__in4 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetApplicationAlertsFilter*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetApplicationAlertsFilter, sizeof(struct ns1__GetApplicationAlertsFilter), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns1__GetApplicationAlertsFilter(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_SOAP_ENC__string(soap, NULL, &a->_in0, "SOAP-ENC:string"))
				{	soap_flag__in0--;
					continue;
				}
			}
			if (soap_flag__in1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_SOAP_ENC__string(soap, NULL, &a->_in1, "SOAP-ENC:string"))
				{	soap_flag__in1--;
					continue;
				}
			}
			if (soap_flag__in2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_SOAP_ENC__string(soap, NULL, &a->_in2, "SOAP-ENC:string"))
				{	soap_flag__in2--;
					continue;
				}
			}
			if (soap_flag__in3 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, NULL, &a->_in3, "xsd:int"))
				{	soap_flag__in3--;
					continue;
				}
			}
			if (soap_flag__in4 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, NULL, &a->_in4, "xsd:int"))
				{	soap_flag__in4--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__in0 > 0 || soap_flag__in1 > 0 || soap_flag__in2 > 0 || soap_flag__in3 > 0 || soap_flag__in4 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__GetApplicationAlertsFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetApplicationAlertsFilter, SOAP_TYPE_ns1__GetApplicationAlertsFilter, sizeof(struct ns1__GetApplicationAlertsFilter), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__GetApplicationAlertsFilter * SOAP_FMAC2 soap_instantiate_ns1__GetApplicationAlertsFilter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetApplicationAlertsFilter(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__GetApplicationAlertsFilter *p;
	size_t k = sizeof(struct ns1__GetApplicationAlertsFilter);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GetApplicationAlertsFilter, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__GetApplicationAlertsFilter);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__GetApplicationAlertsFilter, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__GetApplicationAlertsFilter location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetApplicationAlertsFilter(struct soap *soap, const struct ns1__GetApplicationAlertsFilter *a, const char *tag, const char *type)
{
	if (soap_out_ns1__GetApplicationAlertsFilter(soap, tag ? tag : "ns1:GetApplicationAlertsFilter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetApplicationAlertsFilter * SOAP_FMAC4 soap_get_ns1__GetApplicationAlertsFilter(struct soap *soap, struct ns1__GetApplicationAlertsFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetApplicationAlertsFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetApplicationAlertsFilterResponse(struct soap *soap, struct ns1__GetApplicationAlertsFilterResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_SOAP_ENC__string(soap, &a->_GetApplicationAlertsFilterReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetApplicationAlertsFilterResponse(struct soap *soap, const struct ns1__GetApplicationAlertsFilterResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->_GetApplicationAlertsFilterReturn, SOAP_TYPE_SOAP_ENC__string);
	soap_serialize_SOAP_ENC__string(soap, &a->_GetApplicationAlertsFilterReturn);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetApplicationAlertsFilterResponse(struct soap *soap, const char *tag, int id, const struct ns1__GetApplicationAlertsFilterResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetApplicationAlertsFilterResponse), type))
		return soap->error;
	if (soap_out_SOAP_ENC__string(soap, "GetApplicationAlertsFilterReturn", -1, &a->_GetApplicationAlertsFilterReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetApplicationAlertsFilterResponse * SOAP_FMAC4 soap_in_ns1__GetApplicationAlertsFilterResponse(struct soap *soap, const char *tag, struct ns1__GetApplicationAlertsFilterResponse *a, const char *type)
{
	size_t soap_flag__GetApplicationAlertsFilterReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetApplicationAlertsFilterResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetApplicationAlertsFilterResponse, sizeof(struct ns1__GetApplicationAlertsFilterResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns1__GetApplicationAlertsFilterResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__GetApplicationAlertsFilterReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_SOAP_ENC__string(soap, NULL, &a->_GetApplicationAlertsFilterReturn, "SOAP-ENC:string"))
				{	soap_flag__GetApplicationAlertsFilterReturn--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__GetApplicationAlertsFilterReturn > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__GetApplicationAlertsFilterResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetApplicationAlertsFilterResponse, SOAP_TYPE_ns1__GetApplicationAlertsFilterResponse, sizeof(struct ns1__GetApplicationAlertsFilterResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__GetApplicationAlertsFilterResponse * SOAP_FMAC2 soap_instantiate_ns1__GetApplicationAlertsFilterResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetApplicationAlertsFilterResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__GetApplicationAlertsFilterResponse *p;
	size_t k = sizeof(struct ns1__GetApplicationAlertsFilterResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GetApplicationAlertsFilterResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__GetApplicationAlertsFilterResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__GetApplicationAlertsFilterResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__GetApplicationAlertsFilterResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetApplicationAlertsFilterResponse(struct soap *soap, const struct ns1__GetApplicationAlertsFilterResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__GetApplicationAlertsFilterResponse(soap, tag ? tag : "ns1:GetApplicationAlertsFilterResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetApplicationAlertsFilterResponse * SOAP_FMAC4 soap_get_ns1__GetApplicationAlertsFilterResponse(struct soap *soap, struct ns1__GetApplicationAlertsFilterResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetApplicationAlertsFilterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetApplicationAlerts(struct soap *soap, struct ns1__GetApplicationAlerts *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_SOAP_ENC__string(soap, &a->_in0);
	soap_default_int(soap, &a->_in1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetApplicationAlerts(struct soap *soap, const struct ns1__GetApplicationAlerts *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->_in0, SOAP_TYPE_SOAP_ENC__string);
	soap_serialize_SOAP_ENC__string(soap, &a->_in0);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetApplicationAlerts(struct soap *soap, const char *tag, int id, const struct ns1__GetApplicationAlerts *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetApplicationAlerts), type))
		return soap->error;
	if (soap_out_SOAP_ENC__string(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	if (soap_out_int(soap, "in1", -1, &a->_in1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetApplicationAlerts * SOAP_FMAC4 soap_in_ns1__GetApplicationAlerts(struct soap *soap, const char *tag, struct ns1__GetApplicationAlerts *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	size_t soap_flag__in1 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetApplicationAlerts*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetApplicationAlerts, sizeof(struct ns1__GetApplicationAlerts), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns1__GetApplicationAlerts(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_SOAP_ENC__string(soap, NULL, &a->_in0, "SOAP-ENC:string"))
				{	soap_flag__in0--;
					continue;
				}
			}
			if (soap_flag__in1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, NULL, &a->_in1, "xsd:int"))
				{	soap_flag__in1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__in0 > 0 || soap_flag__in1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__GetApplicationAlerts *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetApplicationAlerts, SOAP_TYPE_ns1__GetApplicationAlerts, sizeof(struct ns1__GetApplicationAlerts), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__GetApplicationAlerts * SOAP_FMAC2 soap_instantiate_ns1__GetApplicationAlerts(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetApplicationAlerts(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__GetApplicationAlerts *p;
	size_t k = sizeof(struct ns1__GetApplicationAlerts);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GetApplicationAlerts, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__GetApplicationAlerts);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__GetApplicationAlerts, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__GetApplicationAlerts location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetApplicationAlerts(struct soap *soap, const struct ns1__GetApplicationAlerts *a, const char *tag, const char *type)
{
	if (soap_out_ns1__GetApplicationAlerts(soap, tag ? tag : "ns1:GetApplicationAlerts", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetApplicationAlerts * SOAP_FMAC4 soap_get_ns1__GetApplicationAlerts(struct soap *soap, struct ns1__GetApplicationAlerts *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetApplicationAlerts(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetApplicationAlertsResponse(struct soap *soap, struct ns1__GetApplicationAlertsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_SOAP_ENC__string(soap, &a->_GetApplicationAlertsReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetApplicationAlertsResponse(struct soap *soap, const struct ns1__GetApplicationAlertsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->_GetApplicationAlertsReturn, SOAP_TYPE_SOAP_ENC__string);
	soap_serialize_SOAP_ENC__string(soap, &a->_GetApplicationAlertsReturn);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetApplicationAlertsResponse(struct soap *soap, const char *tag, int id, const struct ns1__GetApplicationAlertsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetApplicationAlertsResponse), type))
		return soap->error;
	if (soap_out_SOAP_ENC__string(soap, "GetApplicationAlertsReturn", -1, &a->_GetApplicationAlertsReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetApplicationAlertsResponse * SOAP_FMAC4 soap_in_ns1__GetApplicationAlertsResponse(struct soap *soap, const char *tag, struct ns1__GetApplicationAlertsResponse *a, const char *type)
{
	size_t soap_flag__GetApplicationAlertsReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetApplicationAlertsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetApplicationAlertsResponse, sizeof(struct ns1__GetApplicationAlertsResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns1__GetApplicationAlertsResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__GetApplicationAlertsReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_SOAP_ENC__string(soap, NULL, &a->_GetApplicationAlertsReturn, "SOAP-ENC:string"))
				{	soap_flag__GetApplicationAlertsReturn--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__GetApplicationAlertsReturn > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__GetApplicationAlertsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetApplicationAlertsResponse, SOAP_TYPE_ns1__GetApplicationAlertsResponse, sizeof(struct ns1__GetApplicationAlertsResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__GetApplicationAlertsResponse * SOAP_FMAC2 soap_instantiate_ns1__GetApplicationAlertsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetApplicationAlertsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__GetApplicationAlertsResponse *p;
	size_t k = sizeof(struct ns1__GetApplicationAlertsResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GetApplicationAlertsResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__GetApplicationAlertsResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__GetApplicationAlertsResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__GetApplicationAlertsResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetApplicationAlertsResponse(struct soap *soap, const struct ns1__GetApplicationAlertsResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__GetApplicationAlertsResponse(soap, tag ? tag : "ns1:GetApplicationAlertsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetApplicationAlertsResponse * SOAP_FMAC4 soap_get_ns1__GetApplicationAlertsResponse(struct soap *soap, struct ns1__GetApplicationAlertsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetApplicationAlertsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetApplicationAlertsByStartDate(struct soap *soap, struct ns1__GetApplicationAlertsByStartDate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_SOAP_ENC__string(soap, &a->_in0);
	soap_default_SOAP_ENC__string(soap, &a->_in1);
	soap_default_int(soap, &a->_in2);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetApplicationAlertsByStartDate(struct soap *soap, const struct ns1__GetApplicationAlertsByStartDate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->_in0, SOAP_TYPE_SOAP_ENC__string);
	soap_serialize_SOAP_ENC__string(soap, &a->_in0);
	soap_embedded(soap, &a->_in1, SOAP_TYPE_SOAP_ENC__string);
	soap_serialize_SOAP_ENC__string(soap, &a->_in1);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetApplicationAlertsByStartDate(struct soap *soap, const char *tag, int id, const struct ns1__GetApplicationAlertsByStartDate *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetApplicationAlertsByStartDate), type))
		return soap->error;
	if (soap_out_SOAP_ENC__string(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	if (soap_out_SOAP_ENC__string(soap, "in1", -1, &a->_in1, ""))
		return soap->error;
	if (soap_out_int(soap, "in2", -1, &a->_in2, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetApplicationAlertsByStartDate * SOAP_FMAC4 soap_in_ns1__GetApplicationAlertsByStartDate(struct soap *soap, const char *tag, struct ns1__GetApplicationAlertsByStartDate *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	size_t soap_flag__in1 = 1;
	size_t soap_flag__in2 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetApplicationAlertsByStartDate*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetApplicationAlertsByStartDate, sizeof(struct ns1__GetApplicationAlertsByStartDate), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns1__GetApplicationAlertsByStartDate(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_SOAP_ENC__string(soap, NULL, &a->_in0, "SOAP-ENC:string"))
				{	soap_flag__in0--;
					continue;
				}
			}
			if (soap_flag__in1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_SOAP_ENC__string(soap, NULL, &a->_in1, "SOAP-ENC:string"))
				{	soap_flag__in1--;
					continue;
				}
			}
			if (soap_flag__in2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, NULL, &a->_in2, "xsd:int"))
				{	soap_flag__in2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__in0 > 0 || soap_flag__in1 > 0 || soap_flag__in2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__GetApplicationAlertsByStartDate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetApplicationAlertsByStartDate, SOAP_TYPE_ns1__GetApplicationAlertsByStartDate, sizeof(struct ns1__GetApplicationAlertsByStartDate), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__GetApplicationAlertsByStartDate * SOAP_FMAC2 soap_instantiate_ns1__GetApplicationAlertsByStartDate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetApplicationAlertsByStartDate(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__GetApplicationAlertsByStartDate *p;
	size_t k = sizeof(struct ns1__GetApplicationAlertsByStartDate);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GetApplicationAlertsByStartDate, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__GetApplicationAlertsByStartDate);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__GetApplicationAlertsByStartDate, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__GetApplicationAlertsByStartDate location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetApplicationAlertsByStartDate(struct soap *soap, const struct ns1__GetApplicationAlertsByStartDate *a, const char *tag, const char *type)
{
	if (soap_out_ns1__GetApplicationAlertsByStartDate(soap, tag ? tag : "ns1:GetApplicationAlertsByStartDate", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetApplicationAlertsByStartDate * SOAP_FMAC4 soap_get_ns1__GetApplicationAlertsByStartDate(struct soap *soap, struct ns1__GetApplicationAlertsByStartDate *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetApplicationAlertsByStartDate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetApplicationAlertsByStartDateResponse(struct soap *soap, struct ns1__GetApplicationAlertsByStartDateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_SOAP_ENC__string(soap, &a->_GetApplicationAlertsByStartDateReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetApplicationAlertsByStartDateResponse(struct soap *soap, const struct ns1__GetApplicationAlertsByStartDateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->_GetApplicationAlertsByStartDateReturn, SOAP_TYPE_SOAP_ENC__string);
	soap_serialize_SOAP_ENC__string(soap, &a->_GetApplicationAlertsByStartDateReturn);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetApplicationAlertsByStartDateResponse(struct soap *soap, const char *tag, int id, const struct ns1__GetApplicationAlertsByStartDateResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetApplicationAlertsByStartDateResponse), type))
		return soap->error;
	if (soap_out_SOAP_ENC__string(soap, "GetApplicationAlertsByStartDateReturn", -1, &a->_GetApplicationAlertsByStartDateReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetApplicationAlertsByStartDateResponse * SOAP_FMAC4 soap_in_ns1__GetApplicationAlertsByStartDateResponse(struct soap *soap, const char *tag, struct ns1__GetApplicationAlertsByStartDateResponse *a, const char *type)
{
	size_t soap_flag__GetApplicationAlertsByStartDateReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetApplicationAlertsByStartDateResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetApplicationAlertsByStartDateResponse, sizeof(struct ns1__GetApplicationAlertsByStartDateResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns1__GetApplicationAlertsByStartDateResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__GetApplicationAlertsByStartDateReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_SOAP_ENC__string(soap, NULL, &a->_GetApplicationAlertsByStartDateReturn, "SOAP-ENC:string"))
				{	soap_flag__GetApplicationAlertsByStartDateReturn--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__GetApplicationAlertsByStartDateReturn > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__GetApplicationAlertsByStartDateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetApplicationAlertsByStartDateResponse, SOAP_TYPE_ns1__GetApplicationAlertsByStartDateResponse, sizeof(struct ns1__GetApplicationAlertsByStartDateResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__GetApplicationAlertsByStartDateResponse * SOAP_FMAC2 soap_instantiate_ns1__GetApplicationAlertsByStartDateResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetApplicationAlertsByStartDateResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__GetApplicationAlertsByStartDateResponse *p;
	size_t k = sizeof(struct ns1__GetApplicationAlertsByStartDateResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GetApplicationAlertsByStartDateResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__GetApplicationAlertsByStartDateResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__GetApplicationAlertsByStartDateResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__GetApplicationAlertsByStartDateResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetApplicationAlertsByStartDateResponse(struct soap *soap, const struct ns1__GetApplicationAlertsByStartDateResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__GetApplicationAlertsByStartDateResponse(soap, tag ? tag : "ns1:GetApplicationAlertsByStartDateResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetApplicationAlertsByStartDateResponse * SOAP_FMAC4 soap_get_ns1__GetApplicationAlertsByStartDateResponse(struct soap *soap, struct ns1__GetApplicationAlertsByStartDateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetApplicationAlertsByStartDateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetTlkpSystemAlertTypesRecord(struct soap *soap, struct ns1__GetTlkpSystemAlertTypesRecord *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetTlkpSystemAlertTypesRecord(struct soap *soap, const struct ns1__GetTlkpSystemAlertTypesRecord *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetTlkpSystemAlertTypesRecord(struct soap *soap, const char *tag, int id, const struct ns1__GetTlkpSystemAlertTypesRecord *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetTlkpSystemAlertTypesRecord), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetTlkpSystemAlertTypesRecord * SOAP_FMAC4 soap_in_ns1__GetTlkpSystemAlertTypesRecord(struct soap *soap, const char *tag, struct ns1__GetTlkpSystemAlertTypesRecord *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetTlkpSystemAlertTypesRecord*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetTlkpSystemAlertTypesRecord, sizeof(struct ns1__GetTlkpSystemAlertTypesRecord), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__GetTlkpSystemAlertTypesRecord(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__GetTlkpSystemAlertTypesRecord *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetTlkpSystemAlertTypesRecord, SOAP_TYPE_ns1__GetTlkpSystemAlertTypesRecord, sizeof(struct ns1__GetTlkpSystemAlertTypesRecord), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__GetTlkpSystemAlertTypesRecord * SOAP_FMAC2 soap_instantiate_ns1__GetTlkpSystemAlertTypesRecord(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetTlkpSystemAlertTypesRecord(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__GetTlkpSystemAlertTypesRecord *p;
	size_t k = sizeof(struct ns1__GetTlkpSystemAlertTypesRecord);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GetTlkpSystemAlertTypesRecord, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__GetTlkpSystemAlertTypesRecord);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__GetTlkpSystemAlertTypesRecord, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__GetTlkpSystemAlertTypesRecord location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetTlkpSystemAlertTypesRecord(struct soap *soap, const struct ns1__GetTlkpSystemAlertTypesRecord *a, const char *tag, const char *type)
{
	if (soap_out_ns1__GetTlkpSystemAlertTypesRecord(soap, tag ? tag : "ns1:GetTlkpSystemAlertTypesRecord", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetTlkpSystemAlertTypesRecord * SOAP_FMAC4 soap_get_ns1__GetTlkpSystemAlertTypesRecord(struct soap *soap, struct ns1__GetTlkpSystemAlertTypesRecord *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetTlkpSystemAlertTypesRecord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetTlkpSystemAlertTypesRecordResponse(struct soap *soap, struct ns1__GetTlkpSystemAlertTypesRecordResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_SOAP_ENC__string(soap, &a->GetTlkpSystemAlertTypesRecordReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetTlkpSystemAlertTypesRecordResponse(struct soap *soap, const struct ns1__GetTlkpSystemAlertTypesRecordResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->GetTlkpSystemAlertTypesRecordReturn, SOAP_TYPE_SOAP_ENC__string);
	soap_serialize_SOAP_ENC__string(soap, &a->GetTlkpSystemAlertTypesRecordReturn);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetTlkpSystemAlertTypesRecordResponse(struct soap *soap, const char *tag, int id, const struct ns1__GetTlkpSystemAlertTypesRecordResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetTlkpSystemAlertTypesRecordResponse), type))
		return soap->error;
	if (soap_out_SOAP_ENC__string(soap, "GetTlkpSystemAlertTypesRecordReturn", -1, &a->GetTlkpSystemAlertTypesRecordReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetTlkpSystemAlertTypesRecordResponse * SOAP_FMAC4 soap_in_ns1__GetTlkpSystemAlertTypesRecordResponse(struct soap *soap, const char *tag, struct ns1__GetTlkpSystemAlertTypesRecordResponse *a, const char *type)
{
	size_t soap_flag_GetTlkpSystemAlertTypesRecordReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetTlkpSystemAlertTypesRecordResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetTlkpSystemAlertTypesRecordResponse, sizeof(struct ns1__GetTlkpSystemAlertTypesRecordResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns1__GetTlkpSystemAlertTypesRecordResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetTlkpSystemAlertTypesRecordReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_SOAP_ENC__string(soap, "GetTlkpSystemAlertTypesRecordReturn", &a->GetTlkpSystemAlertTypesRecordReturn, "SOAP-ENC:string"))
				{	soap_flag_GetTlkpSystemAlertTypesRecordReturn--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_GetTlkpSystemAlertTypesRecordReturn > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__GetTlkpSystemAlertTypesRecordResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetTlkpSystemAlertTypesRecordResponse, SOAP_TYPE_ns1__GetTlkpSystemAlertTypesRecordResponse, sizeof(struct ns1__GetTlkpSystemAlertTypesRecordResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__GetTlkpSystemAlertTypesRecordResponse * SOAP_FMAC2 soap_instantiate_ns1__GetTlkpSystemAlertTypesRecordResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetTlkpSystemAlertTypesRecordResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__GetTlkpSystemAlertTypesRecordResponse *p;
	size_t k = sizeof(struct ns1__GetTlkpSystemAlertTypesRecordResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GetTlkpSystemAlertTypesRecordResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__GetTlkpSystemAlertTypesRecordResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__GetTlkpSystemAlertTypesRecordResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__GetTlkpSystemAlertTypesRecordResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetTlkpSystemAlertTypesRecordResponse(struct soap *soap, const struct ns1__GetTlkpSystemAlertTypesRecordResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__GetTlkpSystemAlertTypesRecordResponse(soap, tag ? tag : "ns1:GetTlkpSystemAlertTypesRecordResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetTlkpSystemAlertTypesRecordResponse * SOAP_FMAC4 soap_get_ns1__GetTlkpSystemAlertTypesRecordResponse(struct soap *soap, struct ns1__GetTlkpSystemAlertTypesRecordResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetTlkpSystemAlertTypesRecordResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetTlkpSystemAlertActionsRecord(struct soap *soap, struct ns1__GetTlkpSystemAlertActionsRecord *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetTlkpSystemAlertActionsRecord(struct soap *soap, const struct ns1__GetTlkpSystemAlertActionsRecord *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetTlkpSystemAlertActionsRecord(struct soap *soap, const char *tag, int id, const struct ns1__GetTlkpSystemAlertActionsRecord *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetTlkpSystemAlertActionsRecord), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetTlkpSystemAlertActionsRecord * SOAP_FMAC4 soap_in_ns1__GetTlkpSystemAlertActionsRecord(struct soap *soap, const char *tag, struct ns1__GetTlkpSystemAlertActionsRecord *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetTlkpSystemAlertActionsRecord*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetTlkpSystemAlertActionsRecord, sizeof(struct ns1__GetTlkpSystemAlertActionsRecord), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__GetTlkpSystemAlertActionsRecord(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__GetTlkpSystemAlertActionsRecord *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetTlkpSystemAlertActionsRecord, SOAP_TYPE_ns1__GetTlkpSystemAlertActionsRecord, sizeof(struct ns1__GetTlkpSystemAlertActionsRecord), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__GetTlkpSystemAlertActionsRecord * SOAP_FMAC2 soap_instantiate_ns1__GetTlkpSystemAlertActionsRecord(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetTlkpSystemAlertActionsRecord(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__GetTlkpSystemAlertActionsRecord *p;
	size_t k = sizeof(struct ns1__GetTlkpSystemAlertActionsRecord);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GetTlkpSystemAlertActionsRecord, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__GetTlkpSystemAlertActionsRecord);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__GetTlkpSystemAlertActionsRecord, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__GetTlkpSystemAlertActionsRecord location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetTlkpSystemAlertActionsRecord(struct soap *soap, const struct ns1__GetTlkpSystemAlertActionsRecord *a, const char *tag, const char *type)
{
	if (soap_out_ns1__GetTlkpSystemAlertActionsRecord(soap, tag ? tag : "ns1:GetTlkpSystemAlertActionsRecord", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetTlkpSystemAlertActionsRecord * SOAP_FMAC4 soap_get_ns1__GetTlkpSystemAlertActionsRecord(struct soap *soap, struct ns1__GetTlkpSystemAlertActionsRecord *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetTlkpSystemAlertActionsRecord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetTlkpSystemAlertActionsRecordResponse(struct soap *soap, struct ns1__GetTlkpSystemAlertActionsRecordResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_SOAP_ENC__string(soap, &a->GetTlkpSystemAlertActionsRecordReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetTlkpSystemAlertActionsRecordResponse(struct soap *soap, const struct ns1__GetTlkpSystemAlertActionsRecordResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->GetTlkpSystemAlertActionsRecordReturn, SOAP_TYPE_SOAP_ENC__string);
	soap_serialize_SOAP_ENC__string(soap, &a->GetTlkpSystemAlertActionsRecordReturn);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetTlkpSystemAlertActionsRecordResponse(struct soap *soap, const char *tag, int id, const struct ns1__GetTlkpSystemAlertActionsRecordResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetTlkpSystemAlertActionsRecordResponse), type))
		return soap->error;
	if (soap_out_SOAP_ENC__string(soap, "GetTlkpSystemAlertActionsRecordReturn", -1, &a->GetTlkpSystemAlertActionsRecordReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetTlkpSystemAlertActionsRecordResponse * SOAP_FMAC4 soap_in_ns1__GetTlkpSystemAlertActionsRecordResponse(struct soap *soap, const char *tag, struct ns1__GetTlkpSystemAlertActionsRecordResponse *a, const char *type)
{
	size_t soap_flag_GetTlkpSystemAlertActionsRecordReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetTlkpSystemAlertActionsRecordResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetTlkpSystemAlertActionsRecordResponse, sizeof(struct ns1__GetTlkpSystemAlertActionsRecordResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns1__GetTlkpSystemAlertActionsRecordResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetTlkpSystemAlertActionsRecordReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_SOAP_ENC__string(soap, "GetTlkpSystemAlertActionsRecordReturn", &a->GetTlkpSystemAlertActionsRecordReturn, "SOAP-ENC:string"))
				{	soap_flag_GetTlkpSystemAlertActionsRecordReturn--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_GetTlkpSystemAlertActionsRecordReturn > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__GetTlkpSystemAlertActionsRecordResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetTlkpSystemAlertActionsRecordResponse, SOAP_TYPE_ns1__GetTlkpSystemAlertActionsRecordResponse, sizeof(struct ns1__GetTlkpSystemAlertActionsRecordResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__GetTlkpSystemAlertActionsRecordResponse * SOAP_FMAC2 soap_instantiate_ns1__GetTlkpSystemAlertActionsRecordResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetTlkpSystemAlertActionsRecordResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__GetTlkpSystemAlertActionsRecordResponse *p;
	size_t k = sizeof(struct ns1__GetTlkpSystemAlertActionsRecordResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GetTlkpSystemAlertActionsRecordResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__GetTlkpSystemAlertActionsRecordResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__GetTlkpSystemAlertActionsRecordResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__GetTlkpSystemAlertActionsRecordResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetTlkpSystemAlertActionsRecordResponse(struct soap *soap, const struct ns1__GetTlkpSystemAlertActionsRecordResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__GetTlkpSystemAlertActionsRecordResponse(soap, tag ? tag : "ns1:GetTlkpSystemAlertActionsRecordResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetTlkpSystemAlertActionsRecordResponse * SOAP_FMAC4 soap_get_ns1__GetTlkpSystemAlertActionsRecordResponse(struct soap *soap, struct ns1__GetTlkpSystemAlertActionsRecordResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetTlkpSystemAlertActionsRecordResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetTlkpSystemAlertStatesRecord(struct soap *soap, struct ns1__GetTlkpSystemAlertStatesRecord *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetTlkpSystemAlertStatesRecord(struct soap *soap, const struct ns1__GetTlkpSystemAlertStatesRecord *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetTlkpSystemAlertStatesRecord(struct soap *soap, const char *tag, int id, const struct ns1__GetTlkpSystemAlertStatesRecord *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetTlkpSystemAlertStatesRecord), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetTlkpSystemAlertStatesRecord * SOAP_FMAC4 soap_in_ns1__GetTlkpSystemAlertStatesRecord(struct soap *soap, const char *tag, struct ns1__GetTlkpSystemAlertStatesRecord *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetTlkpSystemAlertStatesRecord*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetTlkpSystemAlertStatesRecord, sizeof(struct ns1__GetTlkpSystemAlertStatesRecord), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__GetTlkpSystemAlertStatesRecord(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__GetTlkpSystemAlertStatesRecord *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetTlkpSystemAlertStatesRecord, SOAP_TYPE_ns1__GetTlkpSystemAlertStatesRecord, sizeof(struct ns1__GetTlkpSystemAlertStatesRecord), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__GetTlkpSystemAlertStatesRecord * SOAP_FMAC2 soap_instantiate_ns1__GetTlkpSystemAlertStatesRecord(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetTlkpSystemAlertStatesRecord(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__GetTlkpSystemAlertStatesRecord *p;
	size_t k = sizeof(struct ns1__GetTlkpSystemAlertStatesRecord);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GetTlkpSystemAlertStatesRecord, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__GetTlkpSystemAlertStatesRecord);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__GetTlkpSystemAlertStatesRecord, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__GetTlkpSystemAlertStatesRecord location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetTlkpSystemAlertStatesRecord(struct soap *soap, const struct ns1__GetTlkpSystemAlertStatesRecord *a, const char *tag, const char *type)
{
	if (soap_out_ns1__GetTlkpSystemAlertStatesRecord(soap, tag ? tag : "ns1:GetTlkpSystemAlertStatesRecord", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetTlkpSystemAlertStatesRecord * SOAP_FMAC4 soap_get_ns1__GetTlkpSystemAlertStatesRecord(struct soap *soap, struct ns1__GetTlkpSystemAlertStatesRecord *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetTlkpSystemAlertStatesRecord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetTlkpSystemAlertStatesRecordResponse(struct soap *soap, struct ns1__GetTlkpSystemAlertStatesRecordResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_SOAP_ENC__string(soap, &a->GetTlkpSystemAlertStatesRecordReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetTlkpSystemAlertStatesRecordResponse(struct soap *soap, const struct ns1__GetTlkpSystemAlertStatesRecordResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->GetTlkpSystemAlertStatesRecordReturn, SOAP_TYPE_SOAP_ENC__string);
	soap_serialize_SOAP_ENC__string(soap, &a->GetTlkpSystemAlertStatesRecordReturn);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetTlkpSystemAlertStatesRecordResponse(struct soap *soap, const char *tag, int id, const struct ns1__GetTlkpSystemAlertStatesRecordResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetTlkpSystemAlertStatesRecordResponse), type))
		return soap->error;
	if (soap_out_SOAP_ENC__string(soap, "GetTlkpSystemAlertStatesRecordReturn", -1, &a->GetTlkpSystemAlertStatesRecordReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetTlkpSystemAlertStatesRecordResponse * SOAP_FMAC4 soap_in_ns1__GetTlkpSystemAlertStatesRecordResponse(struct soap *soap, const char *tag, struct ns1__GetTlkpSystemAlertStatesRecordResponse *a, const char *type)
{
	size_t soap_flag_GetTlkpSystemAlertStatesRecordReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetTlkpSystemAlertStatesRecordResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetTlkpSystemAlertStatesRecordResponse, sizeof(struct ns1__GetTlkpSystemAlertStatesRecordResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns1__GetTlkpSystemAlertStatesRecordResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetTlkpSystemAlertStatesRecordReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_SOAP_ENC__string(soap, "GetTlkpSystemAlertStatesRecordReturn", &a->GetTlkpSystemAlertStatesRecordReturn, "SOAP-ENC:string"))
				{	soap_flag_GetTlkpSystemAlertStatesRecordReturn--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_GetTlkpSystemAlertStatesRecordReturn > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__GetTlkpSystemAlertStatesRecordResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetTlkpSystemAlertStatesRecordResponse, SOAP_TYPE_ns1__GetTlkpSystemAlertStatesRecordResponse, sizeof(struct ns1__GetTlkpSystemAlertStatesRecordResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__GetTlkpSystemAlertStatesRecordResponse * SOAP_FMAC2 soap_instantiate_ns1__GetTlkpSystemAlertStatesRecordResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetTlkpSystemAlertStatesRecordResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__GetTlkpSystemAlertStatesRecordResponse *p;
	size_t k = sizeof(struct ns1__GetTlkpSystemAlertStatesRecordResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GetTlkpSystemAlertStatesRecordResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__GetTlkpSystemAlertStatesRecordResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__GetTlkpSystemAlertStatesRecordResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__GetTlkpSystemAlertStatesRecordResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetTlkpSystemAlertStatesRecordResponse(struct soap *soap, const struct ns1__GetTlkpSystemAlertStatesRecordResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__GetTlkpSystemAlertStatesRecordResponse(soap, tag ? tag : "ns1:GetTlkpSystemAlertStatesRecordResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetTlkpSystemAlertStatesRecordResponse * SOAP_FMAC4 soap_get_ns1__GetTlkpSystemAlertStatesRecordResponse(struct soap *soap, struct ns1__GetTlkpSystemAlertStatesRecordResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetTlkpSystemAlertStatesRecordResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetServerRecord(struct soap *soap, struct ns1__GetServerRecord *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetServerRecord(struct soap *soap, const struct ns1__GetServerRecord *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetServerRecord(struct soap *soap, const char *tag, int id, const struct ns1__GetServerRecord *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetServerRecord), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetServerRecord * SOAP_FMAC4 soap_in_ns1__GetServerRecord(struct soap *soap, const char *tag, struct ns1__GetServerRecord *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetServerRecord*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetServerRecord, sizeof(struct ns1__GetServerRecord), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__GetServerRecord(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__GetServerRecord *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetServerRecord, SOAP_TYPE_ns1__GetServerRecord, sizeof(struct ns1__GetServerRecord), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__GetServerRecord * SOAP_FMAC2 soap_instantiate_ns1__GetServerRecord(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetServerRecord(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__GetServerRecord *p;
	size_t k = sizeof(struct ns1__GetServerRecord);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GetServerRecord, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__GetServerRecord);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__GetServerRecord, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__GetServerRecord location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetServerRecord(struct soap *soap, const struct ns1__GetServerRecord *a, const char *tag, const char *type)
{
	if (soap_out_ns1__GetServerRecord(soap, tag ? tag : "ns1:GetServerRecord", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetServerRecord * SOAP_FMAC4 soap_get_ns1__GetServerRecord(struct soap *soap, struct ns1__GetServerRecord *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetServerRecord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetServerRecordResponse(struct soap *soap, struct ns1__GetServerRecordResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_SOAP_ENC__string(soap, &a->GetServerRecordReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetServerRecordResponse(struct soap *soap, const struct ns1__GetServerRecordResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->GetServerRecordReturn, SOAP_TYPE_SOAP_ENC__string);
	soap_serialize_SOAP_ENC__string(soap, &a->GetServerRecordReturn);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetServerRecordResponse(struct soap *soap, const char *tag, int id, const struct ns1__GetServerRecordResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetServerRecordResponse), type))
		return soap->error;
	if (soap_out_SOAP_ENC__string(soap, "GetServerRecordReturn", -1, &a->GetServerRecordReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetServerRecordResponse * SOAP_FMAC4 soap_in_ns1__GetServerRecordResponse(struct soap *soap, const char *tag, struct ns1__GetServerRecordResponse *a, const char *type)
{
	size_t soap_flag_GetServerRecordReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetServerRecordResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetServerRecordResponse, sizeof(struct ns1__GetServerRecordResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns1__GetServerRecordResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetServerRecordReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_SOAP_ENC__string(soap, "GetServerRecordReturn", &a->GetServerRecordReturn, "SOAP-ENC:string"))
				{	soap_flag_GetServerRecordReturn--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_GetServerRecordReturn > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__GetServerRecordResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetServerRecordResponse, SOAP_TYPE_ns1__GetServerRecordResponse, sizeof(struct ns1__GetServerRecordResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__GetServerRecordResponse * SOAP_FMAC2 soap_instantiate_ns1__GetServerRecordResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetServerRecordResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__GetServerRecordResponse *p;
	size_t k = sizeof(struct ns1__GetServerRecordResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GetServerRecordResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__GetServerRecordResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__GetServerRecordResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__GetServerRecordResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetServerRecordResponse(struct soap *soap, const struct ns1__GetServerRecordResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__GetServerRecordResponse(soap, tag ? tag : "ns1:GetServerRecordResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetServerRecordResponse * SOAP_FMAC4 soap_get_ns1__GetServerRecordResponse(struct soap *soap, struct ns1__GetServerRecordResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetServerRecordResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetServerTypeRecord(struct soap *soap, struct ns1__GetServerTypeRecord *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetServerTypeRecord(struct soap *soap, const struct ns1__GetServerTypeRecord *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetServerTypeRecord(struct soap *soap, const char *tag, int id, const struct ns1__GetServerTypeRecord *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetServerTypeRecord), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetServerTypeRecord * SOAP_FMAC4 soap_in_ns1__GetServerTypeRecord(struct soap *soap, const char *tag, struct ns1__GetServerTypeRecord *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetServerTypeRecord*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetServerTypeRecord, sizeof(struct ns1__GetServerTypeRecord), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__GetServerTypeRecord(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__GetServerTypeRecord *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetServerTypeRecord, SOAP_TYPE_ns1__GetServerTypeRecord, sizeof(struct ns1__GetServerTypeRecord), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__GetServerTypeRecord * SOAP_FMAC2 soap_instantiate_ns1__GetServerTypeRecord(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetServerTypeRecord(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__GetServerTypeRecord *p;
	size_t k = sizeof(struct ns1__GetServerTypeRecord);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GetServerTypeRecord, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__GetServerTypeRecord);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__GetServerTypeRecord, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__GetServerTypeRecord location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetServerTypeRecord(struct soap *soap, const struct ns1__GetServerTypeRecord *a, const char *tag, const char *type)
{
	if (soap_out_ns1__GetServerTypeRecord(soap, tag ? tag : "ns1:GetServerTypeRecord", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetServerTypeRecord * SOAP_FMAC4 soap_get_ns1__GetServerTypeRecord(struct soap *soap, struct ns1__GetServerTypeRecord *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetServerTypeRecord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetServerTypeRecordResponse(struct soap *soap, struct ns1__GetServerTypeRecordResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_SOAP_ENC__string(soap, &a->GetServerTypeRecordReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetServerTypeRecordResponse(struct soap *soap, const struct ns1__GetServerTypeRecordResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->GetServerTypeRecordReturn, SOAP_TYPE_SOAP_ENC__string);
	soap_serialize_SOAP_ENC__string(soap, &a->GetServerTypeRecordReturn);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetServerTypeRecordResponse(struct soap *soap, const char *tag, int id, const struct ns1__GetServerTypeRecordResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetServerTypeRecordResponse), type))
		return soap->error;
	if (soap_out_SOAP_ENC__string(soap, "GetServerTypeRecordReturn", -1, &a->GetServerTypeRecordReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetServerTypeRecordResponse * SOAP_FMAC4 soap_in_ns1__GetServerTypeRecordResponse(struct soap *soap, const char *tag, struct ns1__GetServerTypeRecordResponse *a, const char *type)
{
	size_t soap_flag_GetServerTypeRecordReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetServerTypeRecordResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetServerTypeRecordResponse, sizeof(struct ns1__GetServerTypeRecordResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns1__GetServerTypeRecordResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetServerTypeRecordReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_SOAP_ENC__string(soap, "GetServerTypeRecordReturn", &a->GetServerTypeRecordReturn, "SOAP-ENC:string"))
				{	soap_flag_GetServerTypeRecordReturn--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_GetServerTypeRecordReturn > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__GetServerTypeRecordResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetServerTypeRecordResponse, SOAP_TYPE_ns1__GetServerTypeRecordResponse, sizeof(struct ns1__GetServerTypeRecordResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__GetServerTypeRecordResponse * SOAP_FMAC2 soap_instantiate_ns1__GetServerTypeRecordResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetServerTypeRecordResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__GetServerTypeRecordResponse *p;
	size_t k = sizeof(struct ns1__GetServerTypeRecordResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GetServerTypeRecordResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__GetServerTypeRecordResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__GetServerTypeRecordResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__GetServerTypeRecordResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetServerTypeRecordResponse(struct soap *soap, const struct ns1__GetServerTypeRecordResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__GetServerTypeRecordResponse(soap, tag ? tag : "ns1:GetServerTypeRecordResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetServerTypeRecordResponse * SOAP_FMAC4 soap_get_ns1__GetServerTypeRecordResponse(struct soap *soap, struct ns1__GetServerTypeRecordResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetServerTypeRecordResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetSiteRecord(struct soap *soap, struct ns1__GetSiteRecord *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetSiteRecord(struct soap *soap, const struct ns1__GetSiteRecord *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetSiteRecord(struct soap *soap, const char *tag, int id, const struct ns1__GetSiteRecord *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetSiteRecord), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetSiteRecord * SOAP_FMAC4 soap_in_ns1__GetSiteRecord(struct soap *soap, const char *tag, struct ns1__GetSiteRecord *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetSiteRecord*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetSiteRecord, sizeof(struct ns1__GetSiteRecord), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__GetSiteRecord(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__GetSiteRecord *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetSiteRecord, SOAP_TYPE_ns1__GetSiteRecord, sizeof(struct ns1__GetSiteRecord), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__GetSiteRecord * SOAP_FMAC2 soap_instantiate_ns1__GetSiteRecord(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetSiteRecord(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__GetSiteRecord *p;
	size_t k = sizeof(struct ns1__GetSiteRecord);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GetSiteRecord, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__GetSiteRecord);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__GetSiteRecord, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__GetSiteRecord location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetSiteRecord(struct soap *soap, const struct ns1__GetSiteRecord *a, const char *tag, const char *type)
{
	if (soap_out_ns1__GetSiteRecord(soap, tag ? tag : "ns1:GetSiteRecord", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetSiteRecord * SOAP_FMAC4 soap_get_ns1__GetSiteRecord(struct soap *soap, struct ns1__GetSiteRecord *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetSiteRecord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetSiteRecordResponse(struct soap *soap, struct ns1__GetSiteRecordResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_SOAP_ENC__string(soap, &a->GetSiteRecordReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetSiteRecordResponse(struct soap *soap, const struct ns1__GetSiteRecordResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->GetSiteRecordReturn, SOAP_TYPE_SOAP_ENC__string);
	soap_serialize_SOAP_ENC__string(soap, &a->GetSiteRecordReturn);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetSiteRecordResponse(struct soap *soap, const char *tag, int id, const struct ns1__GetSiteRecordResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetSiteRecordResponse), type))
		return soap->error;
	if (soap_out_SOAP_ENC__string(soap, "GetSiteRecordReturn", -1, &a->GetSiteRecordReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetSiteRecordResponse * SOAP_FMAC4 soap_in_ns1__GetSiteRecordResponse(struct soap *soap, const char *tag, struct ns1__GetSiteRecordResponse *a, const char *type)
{
	size_t soap_flag_GetSiteRecordReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetSiteRecordResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetSiteRecordResponse, sizeof(struct ns1__GetSiteRecordResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns1__GetSiteRecordResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetSiteRecordReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_SOAP_ENC__string(soap, "GetSiteRecordReturn", &a->GetSiteRecordReturn, "SOAP-ENC:string"))
				{	soap_flag_GetSiteRecordReturn--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_GetSiteRecordReturn > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__GetSiteRecordResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetSiteRecordResponse, SOAP_TYPE_ns1__GetSiteRecordResponse, sizeof(struct ns1__GetSiteRecordResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__GetSiteRecordResponse * SOAP_FMAC2 soap_instantiate_ns1__GetSiteRecordResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetSiteRecordResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__GetSiteRecordResponse *p;
	size_t k = sizeof(struct ns1__GetSiteRecordResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GetSiteRecordResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__GetSiteRecordResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__GetSiteRecordResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__GetSiteRecordResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetSiteRecordResponse(struct soap *soap, const struct ns1__GetSiteRecordResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__GetSiteRecordResponse(soap, tag ? tag : "ns1:GetSiteRecordResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetSiteRecordResponse * SOAP_FMAC4 soap_get_ns1__GetSiteRecordResponse(struct soap *soap, struct ns1__GetSiteRecordResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetSiteRecordResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ClearApplicationAlert(struct soap *soap, struct ns1__ClearApplicationAlert *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ClearApplicationAlert(struct soap *soap, const struct ns1__ClearApplicationAlert *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ClearApplicationAlert(struct soap *soap, const char *tag, int id, const struct ns1__ClearApplicationAlert *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ClearApplicationAlert), type))
		return soap->error;
	if (soap_out_int(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__ClearApplicationAlert * SOAP_FMAC4 soap_in_ns1__ClearApplicationAlert(struct soap *soap, const char *tag, struct ns1__ClearApplicationAlert *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__ClearApplicationAlert*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ClearApplicationAlert, sizeof(struct ns1__ClearApplicationAlert), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__ClearApplicationAlert(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, NULL, &a->_in0, "xsd:int"))
				{	soap_flag__in0--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__in0 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__ClearApplicationAlert *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ClearApplicationAlert, SOAP_TYPE_ns1__ClearApplicationAlert, sizeof(struct ns1__ClearApplicationAlert), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__ClearApplicationAlert * SOAP_FMAC2 soap_instantiate_ns1__ClearApplicationAlert(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ClearApplicationAlert(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__ClearApplicationAlert *p;
	size_t k = sizeof(struct ns1__ClearApplicationAlert);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__ClearApplicationAlert, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__ClearApplicationAlert);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__ClearApplicationAlert, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__ClearApplicationAlert location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ClearApplicationAlert(struct soap *soap, const struct ns1__ClearApplicationAlert *a, const char *tag, const char *type)
{
	if (soap_out_ns1__ClearApplicationAlert(soap, tag ? tag : "ns1:ClearApplicationAlert", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ClearApplicationAlert * SOAP_FMAC4 soap_get_ns1__ClearApplicationAlert(struct soap *soap, struct ns1__ClearApplicationAlert *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ClearApplicationAlert(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ClearApplicationAlertResponse(struct soap *soap, struct ns1__ClearApplicationAlertResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ClearApplicationAlertResponse(struct soap *soap, const struct ns1__ClearApplicationAlertResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ClearApplicationAlertResponse(struct soap *soap, const char *tag, int id, const struct ns1__ClearApplicationAlertResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ClearApplicationAlertResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__ClearApplicationAlertResponse * SOAP_FMAC4 soap_in_ns1__ClearApplicationAlertResponse(struct soap *soap, const char *tag, struct ns1__ClearApplicationAlertResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__ClearApplicationAlertResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ClearApplicationAlertResponse, sizeof(struct ns1__ClearApplicationAlertResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__ClearApplicationAlertResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__ClearApplicationAlertResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ClearApplicationAlertResponse, SOAP_TYPE_ns1__ClearApplicationAlertResponse, sizeof(struct ns1__ClearApplicationAlertResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__ClearApplicationAlertResponse * SOAP_FMAC2 soap_instantiate_ns1__ClearApplicationAlertResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ClearApplicationAlertResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__ClearApplicationAlertResponse *p;
	size_t k = sizeof(struct ns1__ClearApplicationAlertResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__ClearApplicationAlertResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__ClearApplicationAlertResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__ClearApplicationAlertResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__ClearApplicationAlertResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ClearApplicationAlertResponse(struct soap *soap, const struct ns1__ClearApplicationAlertResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__ClearApplicationAlertResponse(soap, tag ? tag : "ns1:ClearApplicationAlertResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ClearApplicationAlertResponse * SOAP_FMAC4 soap_get_ns1__ClearApplicationAlertResponse(struct soap *soap, struct ns1__ClearApplicationAlertResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ClearApplicationAlertResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ClearSystemAlert(struct soap *soap, struct ns1__ClearSystemAlert *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ClearSystemAlert(struct soap *soap, const struct ns1__ClearSystemAlert *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ClearSystemAlert(struct soap *soap, const char *tag, int id, const struct ns1__ClearSystemAlert *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ClearSystemAlert), type))
		return soap->error;
	if (soap_out_int(soap, "in0", -1, &a->_in0, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__ClearSystemAlert * SOAP_FMAC4 soap_in_ns1__ClearSystemAlert(struct soap *soap, const char *tag, struct ns1__ClearSystemAlert *a, const char *type)
{
	size_t soap_flag__in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__ClearSystemAlert*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ClearSystemAlert, sizeof(struct ns1__ClearSystemAlert), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__ClearSystemAlert(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, NULL, &a->_in0, "xsd:int"))
				{	soap_flag__in0--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__in0 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__ClearSystemAlert *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ClearSystemAlert, SOAP_TYPE_ns1__ClearSystemAlert, sizeof(struct ns1__ClearSystemAlert), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__ClearSystemAlert * SOAP_FMAC2 soap_instantiate_ns1__ClearSystemAlert(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ClearSystemAlert(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__ClearSystemAlert *p;
	size_t k = sizeof(struct ns1__ClearSystemAlert);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__ClearSystemAlert, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__ClearSystemAlert);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__ClearSystemAlert, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__ClearSystemAlert location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ClearSystemAlert(struct soap *soap, const struct ns1__ClearSystemAlert *a, const char *tag, const char *type)
{
	if (soap_out_ns1__ClearSystemAlert(soap, tag ? tag : "ns1:ClearSystemAlert", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ClearSystemAlert * SOAP_FMAC4 soap_get_ns1__ClearSystemAlert(struct soap *soap, struct ns1__ClearSystemAlert *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ClearSystemAlert(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ClearSystemAlertResponse(struct soap *soap, struct ns1__ClearSystemAlertResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ClearSystemAlertResponse(struct soap *soap, const struct ns1__ClearSystemAlertResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ClearSystemAlertResponse(struct soap *soap, const char *tag, int id, const struct ns1__ClearSystemAlertResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ClearSystemAlertResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__ClearSystemAlertResponse * SOAP_FMAC4 soap_in_ns1__ClearSystemAlertResponse(struct soap *soap, const char *tag, struct ns1__ClearSystemAlertResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__ClearSystemAlertResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ClearSystemAlertResponse, sizeof(struct ns1__ClearSystemAlertResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__ClearSystemAlertResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__ClearSystemAlertResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ClearSystemAlertResponse, SOAP_TYPE_ns1__ClearSystemAlertResponse, sizeof(struct ns1__ClearSystemAlertResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__ClearSystemAlertResponse * SOAP_FMAC2 soap_instantiate_ns1__ClearSystemAlertResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ClearSystemAlertResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__ClearSystemAlertResponse *p;
	size_t k = sizeof(struct ns1__ClearSystemAlertResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__ClearSystemAlertResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__ClearSystemAlertResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__ClearSystemAlertResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__ClearSystemAlertResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ClearSystemAlertResponse(struct soap *soap, const struct ns1__ClearSystemAlertResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__ClearSystemAlertResponse(soap, tag ? tag : "ns1:ClearSystemAlertResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ClearSystemAlertResponse * SOAP_FMAC4 soap_get_ns1__ClearSystemAlertResponse(struct soap *soap, struct ns1__ClearSystemAlertResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ClearSystemAlertResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetVersion(struct soap *soap, struct ns1__GetVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetVersion(struct soap *soap, const struct ns1__GetVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetVersion(struct soap *soap, const char *tag, int id, const struct ns1__GetVersion *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetVersion), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetVersion * SOAP_FMAC4 soap_in_ns1__GetVersion(struct soap *soap, const char *tag, struct ns1__GetVersion *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetVersion*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetVersion, sizeof(struct ns1__GetVersion), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__GetVersion(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__GetVersion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetVersion, SOAP_TYPE_ns1__GetVersion, sizeof(struct ns1__GetVersion), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__GetVersion * SOAP_FMAC2 soap_instantiate_ns1__GetVersion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetVersion(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__GetVersion *p;
	size_t k = sizeof(struct ns1__GetVersion);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GetVersion, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__GetVersion);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__GetVersion, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__GetVersion location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetVersion(struct soap *soap, const struct ns1__GetVersion *a, const char *tag, const char *type)
{
	if (soap_out_ns1__GetVersion(soap, tag ? tag : "ns1:GetVersion", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetVersion * SOAP_FMAC4 soap_get_ns1__GetVersion(struct soap *soap, struct ns1__GetVersion *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetVersionResponse(struct soap *soap, struct ns1__GetVersionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_SOAP_ENC__string(soap, &a->GetVersionReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetVersionResponse(struct soap *soap, const struct ns1__GetVersionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->GetVersionReturn, SOAP_TYPE_SOAP_ENC__string);
	soap_serialize_SOAP_ENC__string(soap, &a->GetVersionReturn);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetVersionResponse(struct soap *soap, const char *tag, int id, const struct ns1__GetVersionResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetVersionResponse), type))
		return soap->error;
	if (soap_out_SOAP_ENC__string(soap, "GetVersionReturn", -1, &a->GetVersionReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetVersionResponse * SOAP_FMAC4 soap_in_ns1__GetVersionResponse(struct soap *soap, const char *tag, struct ns1__GetVersionResponse *a, const char *type)
{
	size_t soap_flag_GetVersionReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetVersionResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetVersionResponse, sizeof(struct ns1__GetVersionResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns1__GetVersionResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetVersionReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_SOAP_ENC__string(soap, "GetVersionReturn", &a->GetVersionReturn, "SOAP-ENC:string"))
				{	soap_flag_GetVersionReturn--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_GetVersionReturn > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__GetVersionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetVersionResponse, SOAP_TYPE_ns1__GetVersionResponse, sizeof(struct ns1__GetVersionResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__GetVersionResponse * SOAP_FMAC2 soap_instantiate_ns1__GetVersionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetVersionResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__GetVersionResponse *p;
	size_t k = sizeof(struct ns1__GetVersionResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__GetVersionResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__GetVersionResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__GetVersionResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__GetVersionResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetVersionResponse(struct soap *soap, const struct ns1__GetVersionResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__GetVersionResponse(soap, tag ? tag : "ns1:GetVersionResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetVersionResponse * SOAP_FMAC4 soap_get_ns1__GetVersionResponse(struct soap *soap, struct ns1__GetVersionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetVersionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code, &mark);
	if (id < 0)
		return soap->error;
	(void)soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__DCenterCordInfo(struct soap *soap, ns1__DCenterCordInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__DCenterCordInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__DCenterCordInfo(struct soap *soap, const char *tag, int id, ns1__DCenterCordInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__DCenterCordInfo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__DCenterCordInfo ? type : NULL);
}

SOAP_FMAC3 ns1__DCenterCordInfo ** SOAP_FMAC4 soap_in_PointerTons1__DCenterCordInfo(struct soap *soap, const char *tag, ns1__DCenterCordInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__DCenterCordInfo **)soap_malloc(soap, sizeof(ns1__DCenterCordInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__DCenterCordInfo *)soap_instantiate_ns1__DCenterCordInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__DCenterCordInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__DCenterCordInfo, sizeof(ns1__DCenterCordInfo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__DCenterCordInfo(struct soap *soap, ns1__DCenterCordInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__DCenterCordInfo(soap, tag ? tag : "ns1:DCenterCordInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__DCenterCordInfo ** SOAP_FMAC4 soap_get_PointerTons1__DCenterCordInfo(struct soap *soap, ns1__DCenterCordInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__DCenterCordInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENC__string(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENC__string))
		soap_serialize_SOAP_ENC__string(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENC__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENC__string, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENC__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToSOAP_ENC__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENC__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENC__string, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENC__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENC__string(soap, tag ? tag : "SOAP-ENC:string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToSOAP_ENC__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENC__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__QName(soap, tag ? tag : "QName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_new_string(struct soap *soap, int n)
{
	char * *a = static_cast<char * *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char *)));
	for (char * *p = a; p && n--; ++p)
		soap_default_string(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
